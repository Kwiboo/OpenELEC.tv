From 08fd49d51c0733e8033f85fc527758ec5d76315a Mon Sep 17 00:00:00 2001
From: Tobias Hieta <tobias@hieta.se>
Date: Tue, 23 Dec 2014 15:12:11 +0100
Subject: [PATCH 01/38] Added 1.3.5 release notes.

---
 plex/ReleaseNotes/1.3.5.txt | 5 +++++
 1 file changed, 5 insertions(+)
 create mode 100644 plex/ReleaseNotes/1.3.5.txt

diff --git a/plex/ReleaseNotes/1.3.5.txt b/plex/ReleaseNotes/1.3.5.txt
new file mode 100644
index 0000000..b585861
--- /dev/null
+++ b/plex/ReleaseNotes/1.3.5.txt
@@ -0,0 +1,5 @@
+Fixes:
+  - Fix playlist playback ordering.
+  - Fix a edge case where bestServer would not match the correct server.
+  - Increase timeout for pre-play loading, since we check the files on
+    disk it might cause the disks to spin up and we need to increase it.

From d18db700609ceeebb26fd62ee78d95ddbdd778a7 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 10:11:13 +0100
Subject: [PATCH 02/38] Add rapidxml to global includes

---
 CMakeLists.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 108d85b..f2e6977 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -113,7 +113,7 @@ include_directories(
   ${root}/xbmc/settings
   ${root}/lib
   ${CMAKE_BINARY_DIR}/lib/cpluff/cpluff-prefix/src/cpluff/libcpluff
-  
+  ${root}/plex/Third-Party/rapidxml
   ${root}/tools/darwin/depends/libcrystalhd
   ${root}/xbmc/cores/AudioEngine
 )

From 745d6a46f10e6ba47976d412a4988a9b10e340f4 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 10:12:13 +0100
Subject: [PATCH 03/38] Fix FindPython.cmake on r-pi

---
 plex/CMakeModules/FindPython.cmake | 40 ++++++++++++++++++++++++--------------
 1 file changed, 25 insertions(+), 15 deletions(-)

diff --git a/plex/CMakeModules/FindPython.cmake b/plex/CMakeModules/FindPython.cmake
index 3618034..ffb1e82 100644
--- a/plex/CMakeModules/FindPython.cmake
+++ b/plex/CMakeModules/FindPython.cmake
@@ -59,11 +59,15 @@ set(PYTHON_EXEC "${PYTHON_EXEC_}" CACHE FILEPATH "Path to Python interpreter")
 string(REGEX REPLACE "/bin/python.*" "" PYTHON_PREFIX "${PYTHON_EXEC_}")
 string(REGEX REPLACE "/bin/python.*" "" PYTHON_PREFIX2 "${PYTHON_EXEC}")
 
-execute_process(COMMAND "${PYTHON_EXEC}" "-c"
-    "import sys; print('%d.%d' % (sys.version_info[0],sys.version_info[1]))"
-    OUTPUT_VARIABLE PYTHON_VERSION
-    OUTPUT_STRIP_TRAILING_WHITESPACE)
-string(REPLACE "." "" PYTHON_VERSION_NO_DOTS ${PYTHON_VERSION})
+if (TARGET_RPI)
+    string(REGEX REPLACE ".*/bin/python" "" PYTHON_VERSION "${PYTHON_EXEC}") # grab version from executable name
+else()
+    execute_process(COMMAND "${PYTHON_EXEC}" "-c"
+        "import sys; print('%d.%d' % (sys.version_info[0],sys.version_info[1]))"
+        OUTPUT_VARIABLE PYTHON_VERSION
+        OUTPUT_STRIP_TRAILING_WHITESPACE)
+    string(REPLACE "." "" PYTHON_VERSION_NO_DOTS ${PYTHON_VERSION})
+endif()
 
 find_library(PYTHON_LIBRARIES 
     NAMES "python${PYTHON_VERSION_NO_DOTS}" "python${PYTHON_VERSION}"
@@ -80,11 +84,15 @@ find_path(PYTHON_INCLUDE_DIRS "Python.h"
     PATH_SUFFIXES python${PYTHON_VERSION} python${PYTHON_VERSION}m
     DOC "Python include directories" NO_DEFAULT_PATH)
 
-execute_process(COMMAND "${PYTHON_EXEC}" "-c"
-    "from distutils.sysconfig import get_python_lib; print(get_python_lib())"
-    OUTPUT_VARIABLE PYTHON_SITE_MODULES_
-    OUTPUT_STRIP_TRAILING_WHITESPACE)
-string(REGEX REPLACE "^${PYTHON_PREFIX2}/" "" PYTHON_SITE_MODULES "${PYTHON_SITE_MODULES_}")
+if (TARGET_RPI)
+    set(PYTHON_SITE_MODULES "${PYTHON_PREFIX}/lib/site-packages" CACHE FILEPATH "Path to Python site modules")
+else()
+    execute_process(COMMAND "${PYTHON_EXEC}" "-c"
+        "from distutils.sysconfig import get_python_lib; print(get_python_lib())"
+        OUTPUT_VARIABLE PYTHON_SITE_MODULES_
+        OUTPUT_STRIP_TRAILING_WHITESPACE)
+    string(REGEX REPLACE "^${PYTHON_PREFIX2}/" "" PYTHON_SITE_MODULES "${PYTHON_SITE_MODULES_}")
+endif()
 
 function(find_python_module module)
     string(TOUPPER ${module} module_upper)
@@ -100,11 +108,13 @@ function(find_python_module module)
     if(NOT PY_${module_upper})
         # A module's location is usually a directory, but for binary modules
         # it's a .so file.
-        execute_process(COMMAND "${PYTHON_EXEC}" "-c"
-            "import re, ${module}; print(re.compile('/__init__.py.*').sub('',${module}.__file__))"
-            RESULT_VARIABLE _${module}_status
-            OUTPUT_VARIABLE _${module}_location
-            ERROR_QUIET OUTPUT_STRIP_TRAILING_WHITESPACE)
+        if (NOT TARGET_RPI)
+            execute_process(COMMAND "${PYTHON_EXEC}" "-c"
+                "import re, ${module}; print(re.compile('/__init__.py.*').sub('',${module}.__file__))"
+                RESULT_VARIABLE _${module}_status
+                OUTPUT_VARIABLE _${module}_location
+                ERROR_QUIET OUTPUT_STRIP_TRAILING_WHITESPACE)
+        endif()
         if(NOT _${module}_status)
             set(PY_${module_upper} ${_${module}_location} CACHE STRING
                 "Location of Python module ${module}")

From 5e970c47947dd5c9a0a1e20435aa3ab315bfc8be Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 10:13:11 +0100
Subject: [PATCH 04/38] Compile fastmemcpy-arm.S

---
 xbmc/CMakeLists.txt     | 4 ++++
 xbmc/utils/fastmemcpy.h | 2 +-
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/xbmc/CMakeLists.txt b/xbmc/CMakeLists.txt
index 538d62b..edc16f9 100644
--- a/xbmc/CMakeLists.txt
+++ b/xbmc/CMakeLists.txt
@@ -39,6 +39,10 @@ set(SRCS ${xbmc_SRCS} ${ALL_SRCS})
 ADD_MSVC_PRECOMPILED_HEADER("pch.h" "win32/pch.cpp" SRCS)
 #ADD_MSVC_PRECOMPILED_HEADER("${root}/xbmc/win32/pch.h" "${root}/xbmc/win32/pch.cpp" ALL_SRCS)
 
+enable_language(ASM)
+set_property(SOURCE ./utils/fastmemcpy-arm.S PROPERTY LANGUAGE ASM)
+list(APPEND SRCS ./utils/fastmemcpy-arm.S)
+
 add_library(xbmc STATIC ${SRCS})
 set_target_properties(xbmc PROPERTIES
   XCODE_ATTRIBUTE_GCC_PREFIX_HEADER ${plexdir}/pch_plex.h
diff --git a/xbmc/utils/fastmemcpy.h b/xbmc/utils/fastmemcpy.h
index 4aa1433..2b40b76 100644
--- a/xbmc/utils/fastmemcpy.h
+++ b/xbmc/utils/fastmemcpy.h
@@ -23,7 +23,7 @@
 extern "C" {
 #endif
 
-#if !defined(_WIN32) && !defined(__ppc__) && !defined(__powerpc__) && !defined(TARGET_ANDROID) && !defined(TARGET_DARWIN_IOS) && !defined(TARGET_RASPBERRY_PI)
+#if !defined(_WIN32) && !defined(__ppc__) && !defined(__powerpc__) && !defined(TARGET_ANDROID) && !defined(TARGET_DARWIN_IOS)
 void * fast_memcpy(void * to, const void * from, size_t len);
 //#define fast_memcpy memcpy
 #else

From 107b55abba80336cc24eac3891732bc40b58e667 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 10:13:38 +0100
Subject: [PATCH 05/38] Compile yuv2rgb.neon.S

---
 xbmc/CMakeLists.txt | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/CMakeLists.txt b/xbmc/CMakeLists.txt
index edc16f9..3ed1b2e 100644
--- a/xbmc/CMakeLists.txt
+++ b/xbmc/CMakeLists.txt
@@ -40,7 +40,9 @@ ADD_MSVC_PRECOMPILED_HEADER("pch.h" "win32/pch.cpp" SRCS)
 #ADD_MSVC_PRECOMPILED_HEADER("${root}/xbmc/win32/pch.h" "${root}/xbmc/win32/pch.cpp" ALL_SRCS)
 
 enable_language(ASM)
+set_property(SOURCE ./cores/VideoRenderers/yuv2rgb.neon.S PROPERTY LANGUAGE ASM)
 set_property(SOURCE ./utils/fastmemcpy-arm.S PROPERTY LANGUAGE ASM)
+list(APPEND SRCS ./cores/VideoRenderers/yuv2rgb.neon.S)
 list(APPEND SRCS ./utils/fastmemcpy-arm.S)
 
 add_library(xbmc STATIC ${SRCS})

From 583ed596ee35f3b82edd5f8e61ee709124a84b46 Mon Sep 17 00:00:00 2001
From: Sam Nazarko <samnazarko@stmteam.com>
Date: Wed, 23 Oct 2013 01:27:56 +0100
Subject: [PATCH 06/38] build frodo with libshairplay if available

---
 configure.in                    | 47 +++++++++++++++++++++++++++++++----------
 xbmc/DllPaths_generated.h.in    |  1 +
 xbmc/network/AirTunesServer.cpp | 31 +++++++++++++--------------
 xbmc/network/AirTunesServer.h   |  6 +++---
 xbmc/network/DllLibShairplay.h  |  4 ++--
 xbmc/system.h                   |  3 ++-
 6 files changed, 59 insertions(+), 33 deletions(-)

diff --git a/configure.in b/configure.in
index 002245a..44aedff 100644
--- a/configure.in
+++ b/configure.in
@@ -138,8 +138,8 @@ libnfs_not_found="== Could not find libnfs. NFS client support disabled. =="
 libnfs_disabled="== NFS support disabled. =="
 libafpclient_not_found="== Could not find libafpclient. AFP client support disabled. =="
 libafpclient_disabled="== AFP support disabled. =="
-libshairport_not_found="== Could not find libshairport. AirTunes support disabled. =="
-libshairport_disabled="== AirTunes support disabled. =="
+libshairport_not_found="== Could not find libshairport. =="
+libshairplay_not_found="== Could not find libshairplay. =="
 samba_disabled="== SAMBA support disabled. =="
 libplist_not_found="== Could not find libplist. AirPlay support disabled. =="
 libplist_disabled="== AirPlay support disabled. =="
@@ -1385,24 +1385,45 @@ if test "$use_airplay" != "no"; then
   fi
 fi
 
-# libshairport for AirTunes
+# libshairplay for AirTunes (prefered lib)
 USE_AIRTUNES=0
 if test "x$use_airtunes" != "xno"; then
-  AC_CHECK_HEADERS([shairport/shairport.h],,
+  AC_CHECK_HEADERS([shairplay/raop.h],,
    [if test "x$use_airtunes" = "xyes"; then
-      AC_MSG_ERROR($libshairport_not_found)
+      AC_MSG_ERROR($libshairplay_not_found)
     elif test "x$use_airtunes" != "xno"; then
-      AC_MSG_NOTICE($libshairport_not_found)
+      AC_MSG_NOTICE($libshairplay_not_found)
       use_airtunes="no"
     fi
    ])
 
   if test "x$use_airtunes" != "xno"; then
-    XB_FIND_SONAME([SHAIRPORT], [shairport], [use_airtunes])
+    XB_FIND_SONAME([SHAIRPLAY], [shairplay], [use_airtunes])
     USE_AIRTUNES=1
-    AC_CHECK_MEMBERS([struct AudioOutput.ao_set_metadata],,,
-                     [[#include <shairport/shairport.h>]])
-    AC_DEFINE([HAVE_LIBSHAIRPORT],[1],["Define to 1 if you have libshairport."])
+    USE_LIBSHAIRPORT=1
+    AC_CHECK_MEMBERS([struct raop_callbacks_s.cls],,,
+                     [[#include <shairplay/raop.h>]])
+    AC_DEFINE([HAVE_LIBSHAIRPLAY],[1],["Define to 1 if you have libshairplay."])
+  fi
+
+  #libshairport - as a fallback for AirTunes
+  if test "x$USE_AIRTUNES" == "x0"; then
+    AC_CHECK_HEADERS([shairport/shairport.h],,
+     [if test "x$use_airtunes" = "xyes"; then
+        AC_MSG_ERROR($libshairport_not_found)
+      elif test "x$use_airtunes" != "xno"; then
+        AC_MSG_NOTICE($libshairport_not_found)
+        use_airtunes="no"
+      fi
+     ])
+
+    if test "x$use_airtunes" != "xno"; then
+      XB_FIND_SONAME([SHAIRPORT], [shairport], [use_airtunes])
+      USE_AIRTUNES=1
+      AC_CHECK_MEMBERS([struct AudioOutput.ao_set_metadata],,,
+                       [[#include <shairport/shairport.h>]])
+      AC_DEFINE([HAVE_LIBSHAIRPORT],[1],["Define to 1 if you have libshairport."])
+    fi
   fi
 fi
 
@@ -2197,7 +2218,11 @@ else
 fi
 
 if test "x$use_airtunes" != "xno"; then
-  final_message="$final_message\n  AirTunes support:\tYes"  
+  if test "x$USE_LIBSHAIRPORT" == "x1"; then
+    final_message="$final_message\n  AirTunes support (libshairplay):\tYes"
+  else
+    final_message="$final_message\n  AirTunes support (libshairport):\tYes"
+  fi
 else
   final_message="$final_message\n  AirTunes support:\tNo"
 fi
diff --git a/xbmc/DllPaths_generated.h.in b/xbmc/DllPaths_generated.h.in
index 494b5ff..e6b2d42 100644
--- a/xbmc/DllPaths_generated.h.in
+++ b/xbmc/DllPaths_generated.h.in
@@ -37,6 +37,7 @@
 #define DLL_PATH_LIBAFP        "@AFPCLIENT_SONAME@"
 #define DLL_PATH_LIBPLIST      "@PLIST_SONAME@"
 #define DLL_PATH_LIBSHAIRPORT  "@SHAIRPORT_SONAME@"
+#define DLL_PATH_LIBSHAIRPLAY  "@SHAIRPLAY_SONAME@"
 #define DLL_PATH_LIBCEC        "@LIBCEC_SONAME@"
 
 #ifndef DLL_PATH_LIBCURL
diff --git a/xbmc/network/AirTunesServer.cpp b/xbmc/network/AirTunesServer.cpp
index 49121fe..9908326 100644
--- a/xbmc/network/AirTunesServer.cpp
+++ b/xbmc/network/AirTunesServer.cpp
@@ -52,7 +52,7 @@
 
 using namespace XFILE;
 
-#if defined(TARGET_WINDOWS)
+#if defined(HAVE_LIBSHAIRPLAY)
 DllLibShairplay *CAirTunesServer::m_pLibShairplay = NULL;
 #else
 DllLibShairport *CAirTunesServer::m_pLibShairport = NULL;
@@ -120,7 +120,7 @@ void CAirTunesServer::SetCoverArtFromBuffer(const char *buffer, unsigned int siz
   }
 }
 
-#if defined(TARGET_WINDOWS)
+#if defined(HAVE_LIBSHAIRPLAY)
 #define RSA_KEY " \
 -----BEGIN RSA PRIVATE KEY-----\
 MIIEpQIBAAKCAQEA59dE8qLieItsH1WgjrcFRKj6eUWqi+bGLOX1HL3U3GhC/j0Qg90u3sG/1CUt\
@@ -156,6 +156,8 @@ void CAirTunesServer::AudioOutputFunctions::audio_set_coverart(void *cls, void *
   CAirTunesServer::SetCoverArtFromBuffer((char *)buffer, buflen);
 }
 
+char *session="XBMC-AirTunes";
+
 void* CAirTunesServer::AudioOutputFunctions::audio_init(void *cls, int bits, int channels, int samplerate)
 {
   XFILE::CPipeFile *pipe=(XFILE::CPipeFile *)cls;
@@ -180,12 +182,9 @@ void* CAirTunesServer::AudioOutputFunctions::audio_init(void *cls, int bits, int
   item.SetPath(pipe->GetName());
   item.SetMimeType("audio/x-xbmc-pcm");
 
-  ThreadMessage tMsg2 = { TMSG_GUI_ACTIVATE_WINDOW, WINDOW_VISUALISATION, 0 };
-  CApplicationMessenger::Get().SendMessage(tMsg2, true);
-
   CApplicationMessenger::Get().PlayFile(item);
 
-  return "XBMC-AirTunes";//session
+  return session;//session
 }
 
 void  CAirTunesServer::AudioOutputFunctions::audio_set_volume(void *cls, void *session, float volume)
@@ -242,7 +241,7 @@ void  CAirTunesServer::AudioOutputFunctions::audio_destroy(void *cls, void *sess
   }
 }
 
-void shairplay_log(int level, const char *msg)
+void shairplay_log(void *cls, int level, const char *msg)
 {
   int xbmcLevel = LOGINFO;
 
@@ -497,7 +496,7 @@ bool CAirTunesServer::StartServer(int port, bool nonlocal, bool usePassword, con
   ServerInstance = new CAirTunesServer(port, nonlocal);
   if (ServerInstance->Initialize(password))
   {
-#ifndef TARGET_WINDOWS
+#if !defined(HAVE_LIBSHAIRPLAY)
     ServerInstance->Create();
 #endif
     success = true;
@@ -519,7 +518,7 @@ bool CAirTunesServer::StartServer(int port, bool nonlocal, bool usePassword, con
     txt.push_back(std::make_pair("sm",  "false"));
     txt.push_back(std::make_pair("ss",  "16"));
     txt.push_back(std::make_pair("sr",  "44100"));
-    txt.push_back(std::make_pair("pw",  "false"));
+    txt.push_back(std::make_pair("pw",  usePassword?"true":"false"));
     txt.push_back(std::make_pair("vn",  "3"));
     txt.push_back(std::make_pair("da",  "true"));
     txt.push_back(std::make_pair("vs",  "130.14"));
@@ -536,7 +535,7 @@ void CAirTunesServer::StopServer(bool bWait)
 {
   if (ServerInstance)
   {
-#if !defined(TARGET_WINDOWS)
+#if !defined(HAVE_LIBSHAIRPLAY)
     if (m_pLibShairport->IsLoaded())
     {
       m_pLibShairport->shairport_exit();
@@ -557,7 +556,7 @@ void CAirTunesServer::StopServer(bool bWait)
 CAirTunesServer::CAirTunesServer(int port, bool nonlocal) : CThread("AirTunesServer")
 {
   m_port = port;
-#if defined(TARGET_WINDOWS)
+#if defined(HAVE_LIBSHAIRPLAY)
   m_pLibShairplay = new DllLibShairplay();
   m_pPipe         = new XFILE::CPipeFile;  
 #else
@@ -567,7 +566,7 @@ CAirTunesServer::CAirTunesServer(int port, bool nonlocal) : CThread("AirTunesSer
 
 CAirTunesServer::~CAirTunesServer()
 {
-#if defined(TARGET_WINDOWS)
+#if defined(HAVE_LIBSHAIRPLAY)
   if (m_pLibShairplay->IsLoaded())
   {
     m_pLibShairplay->Unload();
@@ -587,7 +586,7 @@ void CAirTunesServer::Process()
 {
   m_bStop = false;
 
-#if !defined(TARGET_WINDOWS)
+#if !defined(HAVE_LIBSHAIRPLAY)
   while (!m_bStop && m_pLibShairport->shairport_is_running())
   {
     m_pLibShairport->shairport_loop();
@@ -601,7 +600,7 @@ bool CAirTunesServer::Initialize(const CStdString &password)
 
   Deinitialize();
 
-#if defined(TARGET_WINDOWS)
+#if defined(HAVE_LIBSHAIRPLAY)
   if (m_pLibShairplay->Load())
   {
 
@@ -629,7 +628,7 @@ bool CAirTunesServer::Initialize(const CStdString &password)
         m_pLibShairplay->raop_set_log_level(m_pRaop, RAOP_LOG_DEBUG);
       }
 
-      m_pLibShairplay->raop_set_log_callback(m_pRaop, shairplay_log);
+      m_pLibShairplay->raop_set_log_callback(m_pRaop, shairplay_log, NULL);
 
       CNetworkInterface *net = g_application.getNetwork().GetFirstConnectedInterface();
 
@@ -691,7 +690,7 @@ bool CAirTunesServer::Initialize(const CStdString &password)
 
 void CAirTunesServer::Deinitialize()
 {
-#if defined(TARGET_WINDOWS)
+#if defined(HAVE_LIBSHAIRPLAY)
   if (m_pLibShairplay && m_pLibShairplay->IsLoaded())
   {
     m_pLibShairplay->raop_stop(m_pRaop);
diff --git a/xbmc/network/AirTunesServer.h b/xbmc/network/AirTunesServer.h
index 2196500..020c900 100644
--- a/xbmc/network/AirTunesServer.h
+++ b/xbmc/network/AirTunesServer.h
@@ -25,7 +25,7 @@
 
 #ifdef HAS_AIRTUNES
 
-#if defined(TARGET_WINDOWS)
+#if defined(HAVE_LIBSHAIRPLAY)
 #include "DllLibShairplay.h"
 #else
 #include "DllLibShairport.h"
@@ -63,7 +63,7 @@ class CAirTunesServer : public CThread
   void Deinitialize();
 
   int m_port;
-#if defined(TARGET_WINDOWS)
+#if defined(HAVE_LIBSHAIRPLAY)
   static DllLibShairplay *m_pLibShairplay;//the lib
   raop_t *m_pRaop;
   XFILE::CPipeFile *m_pPipe;
@@ -76,7 +76,7 @@ class CAirTunesServer : public CThread
   class AudioOutputFunctions
   {
     public:
-#if defined(TARGET_WINDOWS)
+#if defined(HAVE_LIBSHAIRPLAY)
       static void* audio_init(void *cls, int bits, int channels, int samplerate);
       static void  audio_set_volume(void *cls, void *session, float volume);
 	    static void  audio_set_metadata(void *cls, void *session, const void *buffer, int buflen);
diff --git a/xbmc/network/DllLibShairplay.h b/xbmc/network/DllLibShairplay.h
index b5866b8..79e86a0 100644
--- a/xbmc/network/DllLibShairplay.h
+++ b/xbmc/network/DllLibShairplay.h
@@ -35,7 +35,7 @@ class DllLibShairplayInterface
   virtual raop_t *    raop_init(int max_clients, raop_callbacks_t *callbacks, const char *pemkey)=0;
   virtual raop_t *    raop_init_from_keyfile(int max_clients, raop_callbacks_t *callbacks, const char *keyfile)=0;
   virtual void        raop_set_log_level(raop_t *raop, int level)=0;
-  virtual void        raop_set_log_callback(raop_t *raop, raop_log_callback_t callback)=0;
+  virtual void        raop_set_log_callback(raop_t *raop, raop_log_callback_t callback, void *cls)=0;
   virtual int         raop_is_running(raop_t *raop)=0;
   virtual int         raop_start(raop_t *raop, unsigned short *port, const char *hwaddr, int hwaddrlen, const char *password)=0;
   virtual void        raop_stop(raop_t *raop)=0;
@@ -48,7 +48,7 @@ class DllLibShairplay : public DllDynamic, DllLibShairplayInterface
   DEFINE_METHOD3(raop_t *,  raop_init,              (int p1, raop_callbacks_t *p2, const char *p3))
   DEFINE_METHOD3(raop_t *,  raop_init_from_keyfile, (int p1, raop_callbacks_t *p2, const char *p3))
   DEFINE_METHOD2(void,      raop_set_log_level,     (raop_t *p1, int p2))
-  DEFINE_METHOD2(void,      raop_set_log_callback,  (raop_t *p1, raop_log_callback_t p2))
+  DEFINE_METHOD3(void,      raop_set_log_callback,  (raop_t *p1, raop_log_callback_t p2, void *p3))
   DEFINE_METHOD1(int,       raop_is_running,        (raop_t *p1))
   DEFINE_METHOD5(int,       raop_start,             (raop_t *p1, unsigned short *p2, const char *p3, int p4, const char *p5))
   DEFINE_METHOD1(void,      raop_stop,              (raop_t *p1))
diff --git a/xbmc/system.h b/xbmc/system.h
index 39402a7..e1a567e 100644
--- a/xbmc/system.h
+++ b/xbmc/system.h
@@ -78,7 +78,7 @@
   #define HAS_AIRPLAY
 #endif
 
-#ifdef HAVE_LIBSHAIRPORT
+#if defined(HAVE_LIBSHAIRPORT) || defined(HAVE_LIBSHAIRPLAY)
   #define HAS_AIRTUNES
 #endif
 
@@ -135,6 +135,7 @@
 #define HAS_ZEROCONF
 #define HAS_AIRPLAY
 #define HAS_AIRTUNES
+#define HAVE_LIBSHAIRPLAY
 #define HAVE_LIBCEC
 #define HAVE_LIBMP3LAME
 #define HAVE_LIBVORBISENC

From 28898ab41b019de2abcfb781480942950044ff54 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 10:15:26 +0100
Subject: [PATCH 07/38] Use libshairplay instead of libshareport

---
 plex/CMakeModules/CMakeConfig.cmake             |  2 +-
 plex/CMakeModules/CheckLibshairplayConfig.cmake | 15 +++++++++++++
 plex/CMakeModules/CheckLibshairportConfig.cmake | 15 -------------
 plex/CMakeModules/FindShairPlay.cmake           | 28 +++++++++++++++++++++++++
 plex/CMakeModules/FindShairPort.cmake           | 28 -------------------------
 plex/CMakeModules/PlatformConfigLINUX.cmake     |  2 +-
 plex/CMakeModules/PlatformConfigOSX.cmake       |  2 +-
 plex/CMakeModules/PlatformConfigRPI.cmake       |  2 +-
 plex/config.h.in                                |  6 +++---
 9 files changed, 50 insertions(+), 50 deletions(-)
 create mode 100644 plex/CMakeModules/CheckLibshairplayConfig.cmake
 delete mode 100644 plex/CMakeModules/CheckLibshairportConfig.cmake
 create mode 100644 plex/CMakeModules/FindShairPlay.cmake
 delete mode 100644 plex/CMakeModules/FindShairPort.cmake

diff --git a/plex/CMakeModules/CMakeConfig.cmake b/plex/CMakeModules/CMakeConfig.cmake
index 22938e2..0813187 100644
--- a/plex/CMakeModules/CMakeConfig.cmake
+++ b/plex/CMakeModules/CMakeConfig.cmake
@@ -97,7 +97,7 @@ include(CheckFFmpegIncludes)
 if(NOT TARGET_RPI)
   include(CheckCrystalHDInclude)
 endif()
-include(CheckLibshairportConfig)
+include(CheckLibshairplayConfig)
 
 if(DEFINED SDL_FOUND)
   set(HAVE_SDL 1)
diff --git a/plex/CMakeModules/CheckLibshairplayConfig.cmake b/plex/CMakeModules/CheckLibshairplayConfig.cmake
new file mode 100644
index 0000000..0604354
--- /dev/null
+++ b/plex/CMakeModules/CheckLibshairplayConfig.cmake
@@ -0,0 +1,15 @@
+plex_find_header(shairplay/raop.h ${dependdir}/include)
+
+if(DEFINED HAVE_SHAIRPLAY_RAOP_H)
+  CHECK_C_SOURCE_COMPILES("
+    #include <shairplay/raop.h>
+    int main(int argc, char *argv[])
+    {
+      static raop_callbacks_t test;
+      if(sizeof(test.audio_set_metadata))
+        return 0;
+      return 0;
+    }
+  "
+  HAVE_RAOP_CALLBACKS_AUDIO_SET_METADATA)
+endif()
diff --git a/plex/CMakeModules/CheckLibshairportConfig.cmake b/plex/CMakeModules/CheckLibshairportConfig.cmake
deleted file mode 100644
index 4fcce39..0000000
--- a/plex/CMakeModules/CheckLibshairportConfig.cmake
+++ /dev/null
@@ -1,15 +0,0 @@
-plex_find_header(shairport/shairport.h ${dependdir}/include)
-
-if(DEFINED HAVE_SHAIRPORT_SHAIRPORT_H)
-  CHECK_C_SOURCE_COMPILES("
-    #include <shairport/shairport.h>
-    int main(int argc, char *argv[])
-    { 
-      static struct AudioOutput test;
-      if(sizeof(test.ao_set_metadata))
-        return 0;
-      return 0;
-    }
-  "
-  HAVE_STRUCT_AUDIOOUTPUT_AO_SET_METADATA)
-endif()
diff --git a/plex/CMakeModules/FindShairPlay.cmake b/plex/CMakeModules/FindShairPlay.cmake
new file mode 100644
index 0000000..1bcec63
--- /dev/null
+++ b/plex/CMakeModules/FindShairPlay.cmake
@@ -0,0 +1,28 @@
+if(SHAIRPLAY_INCLUDE_DIR)
+  # Already in cache, be silent
+  set(SHAIRPLAY_FIND_QUIETLY TRUE)
+endif(SHAIRPLAY_INCLUDE_DIR)
+
+find_package(PkgConfig)
+if (PKG_CONFIG_FOUND)
+  pkg_check_modules(_SHAIRPLAY libshairplay)
+endif (PKG_CONFIG_FOUND)
+
+Find_Path(SHAIRPLAY_INCLUDE_DIR
+  NAMES shairplay/raop.h
+  PATHS /usr/include usr/local/include
+  HINTS ${_SHAIRPLAY_INCLUDEDIR}
+)
+
+Find_Library(SHAIRPLAY_LIBRARY
+  NAMES shairplay
+  PATHS /usr/lib usr/local/lib
+  HINTS ${_SHAIRPLAY_LIBDIR}
+)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(SHAIRPLAY DEFAULT_MSG SHAIRPLAY_LIBRARY SHAIRPLAY_INCLUDE_DIR)
+
+IF(SHAIRPLAY_LIBRARY AND SHAIRPLAY_INCLUDE_DIR)
+  plex_get_soname(SHAIRPLAY_SONAME ${SHAIRPLAY_LIBRARY})
+ENDIF()
diff --git a/plex/CMakeModules/FindShairPort.cmake b/plex/CMakeModules/FindShairPort.cmake
deleted file mode 100644
index 4d96d5e..0000000
--- a/plex/CMakeModules/FindShairPort.cmake
+++ /dev/null
@@ -1,28 +0,0 @@
-if(SHAIRPORT_INCLUDE_DIR)
-  # Already in cache, be silent
-  set(SHAIRPORT_FIND_QUIETLY TRUE)
-endif(SHAIRPORT_INCLUDE_DIR)
-
-find_package(PkgConfig)
-if (PKG_CONFIG_FOUND)
-  pkg_check_modules(_SHAIRPORT libshairport)
-endif (PKG_CONFIG_FOUND)
-
-Find_Path(SHAIRPORT_INCLUDE_DIR
-  NAMES shairport/shairport.h
-  PATHS /usr/include usr/local/include 
-  HINTS ${_SHAIRPORT_INCLUDEDIR}
-)
-
-Find_Library(SHAIRPORT_LIBRARY
-  NAMES shairport
-  PATHS /usr/lib usr/local/lib
-  HINTS ${_SHAIRPORT_LIBDIR}
-)
-
-include(FindPackageHandleStandardArgs)
-find_package_handle_standard_args(SHAIRPORT DEFAULT_MSG SHAIRPORT_LIBRARY SHAIRPORT_INCLUDE_DIR)
-
-IF(SHAIRPORT_LIBRARY AND SHAIRPORT_INCLUDE_DIR)
-  plex_get_soname(SHAIRPORT_SONAME ${SHAIRPORT_LIBRARY})
-ENDIF()
diff --git a/plex/CMakeModules/PlatformConfigLINUX.cmake b/plex/CMakeModules/PlatformConfigLINUX.cmake
index 7534d7a..3fb9740 100644
--- a/plex/CMakeModules/PlatformConfigLINUX.cmake
+++ b/plex/CMakeModules/PlatformConfigLINUX.cmake
@@ -71,7 +71,7 @@ set(INSTALL_LIB
   Ass
   RTMP
   PLIST
-  ShairPort
+  ShairPlay
   VAAPI
   VDPAU
 )
diff --git a/plex/CMakeModules/PlatformConfigOSX.cmake b/plex/CMakeModules/PlatformConfigOSX.cmake
index c82c2c4..f86b70e 100644
--- a/plex/CMakeModules/PlatformConfigOSX.cmake
+++ b/plex/CMakeModules/PlatformConfigOSX.cmake
@@ -115,7 +115,7 @@ endif()
 set(non_link_libs
   rtmp
   plist
-  shairport
+  shairplay
   curl
   FLAC
   modplug
diff --git a/plex/CMakeModules/PlatformConfigRPI.cmake b/plex/CMakeModules/PlatformConfigRPI.cmake
index 82aa751..f296922 100644
--- a/plex/CMakeModules/PlatformConfigRPI.cmake
+++ b/plex/CMakeModules/PlatformConfigRPI.cmake
@@ -72,7 +72,7 @@ set(INSTALL_LIB
   Ass
   RTMP
   PLIST
-  ShairPort
+  ShairPlay
   CEC
 )
 
diff --git a/plex/config.h.in b/plex/config.h.in
index cf65385..b21a724 100644
--- a/plex/config.h.in
+++ b/plex/config.h.in
@@ -156,7 +156,7 @@
 #cmakedefine HAVE_LIBSDL_MIXER @HAVE_LIBSDL_MIXER@
 #cmakedefine HAVE_LIBSDL_IMAGE @HAVE_LIBSDL_IMAGE@
 #cmakedefine HAVE_DBUS @HAVE_DBUS@
-#cmakedefine HAVE_LIBSHAIRPORT @HAVE_LIBSHAIRPORT@
+#cmakedefine HAVE_LIBSHAIRPLAY @HAVE_LIBSHAIRPLAY@
 #cmakedefine HAVE_LIBSSH @HAVE_LIBSSH@
 #cmakedefine HAVE_LIBSSL @HAVE_LIBSSL@
 #cmakedefine HAVE_LIBTIFF @HAVE_LIBTIFF@
@@ -175,8 +175,8 @@
 #cmakedefine HAVE_PTHREAD_SETNAME_NP @HAVE_PTHREAD_SETNAME_NP@
 #cmakedefine HAVE_PTHREAD_CONDATTR_SETCLOCK @HAVE_PTHREAD_CONDATTR_SETCLOCK@
 
-/* LIBSHAIRPORT */
-#cmakedefine HAVE_STRUCT_AUDIOOUTPUT_AO_SET_METADATA @HAVE_STRUCT_AUDIOOUTPUT_AO_SET_METADATA@
+/* LIBSHAIRPLAY */
+#cmakedefine HAVE_RAOP_CALLBACKS_AUDIO_SET_METADATA @HAVE_RAOP_CALLBACKS_AUDIO_SET_METADATA@
 
 /* OSX SPECIFIC CRAP */
 #cmakedefine HAVE_LIBVDADECODER @HAVE_LIBVDADECODER@

From 04c637fb61eda3b53153a8e8c3dc0942ad9abe18 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 10:18:17 +0100
Subject: [PATCH 08/38] Use dbus on r-pi

---
 plex/CMakeModules/PlatformConfigRPI.cmake | 2 ++
 plex/config.h.in                          | 2 +-
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/plex/CMakeModules/PlatformConfigRPI.cmake b/plex/CMakeModules/PlatformConfigRPI.cmake
index f296922..0d6199e 100644
--- a/plex/CMakeModules/PlatformConfigRPI.cmake
+++ b/plex/CMakeModules/PlatformConfigRPI.cmake
@@ -23,6 +23,7 @@ set(LINK_PKG
   Avahi
   LibDl
   LibRt
+  DBUS
 )
 
 if(NOT USE_INTERNAL_FFMPEG)
@@ -136,6 +137,7 @@ add_definitions(
 	-DTARGET_LINUX
     -DHAS_GLES=2
     -DHAVE_LIBGLESV2
+    -DHAVE_DBUS
     -DHAVE_OMXLIB
     -DOMX_SKIP64BIT
     -DHAS_BUILTIN_SYNC_ADD_AND_FETCH
diff --git a/plex/config.h.in b/plex/config.h.in
index b21a724..8937ee2 100644
--- a/plex/config.h.in
+++ b/plex/config.h.in
@@ -155,7 +155,7 @@
 #cmakedefine HAVE_LIBSDL @HAVE_LIBSDL@
 #cmakedefine HAVE_LIBSDL_MIXER @HAVE_LIBSDL_MIXER@
 #cmakedefine HAVE_LIBSDL_IMAGE @HAVE_LIBSDL_IMAGE@
-#cmakedefine HAVE_DBUS @HAVE_DBUS@
+#cmakedefine HAVE_DBUS @HAVE_LIBDBUS@
 #cmakedefine HAVE_LIBSHAIRPLAY @HAVE_LIBSHAIRPLAY@
 #cmakedefine HAVE_LIBSSH @HAVE_LIBSSH@
 #cmakedefine HAVE_LIBSSL @HAVE_LIBSSL@

From e3a8cef782c20e166b3442fdcf29bc1a2a1cc7ce Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 10:19:05 +0100
Subject: [PATCH 09/38] Enable pythonoptimize

---
 xbmc/interfaces/python/XBPython.cpp | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/xbmc/interfaces/python/XBPython.cpp b/xbmc/interfaces/python/XBPython.cpp
index ef272b3..6f7add4 100644
--- a/xbmc/interfaces/python/XBPython.cpp
+++ b/xbmc/interfaces/python/XBPython.cpp
@@ -483,10 +483,9 @@ void XBPython::Initialize()
       // at http://docs.python.org/using/cmdline.html#environment-variables
 
 #if !defined(_WIN32) && !defined(TARGET_ANDROID)
-      /* PYTHONOPTIMIZE is set off intentionally when using external Python.
-         Reason for this is because we cannot be sure what version of Python
-         was used to compile the various Python object files (i.e. .pyo,
-         .pyc, etc.). */
+      // Required for python to find optimized code (pyo) files
+      setenv("PYTHONOPTIMIZE", "1", 1);
+
         // check if we are running as real xbmc.app or just binary
       if (!CUtil::GetFrameworksPath(true).IsEmpty())
       {

From 25ab59b0a4d5b2ac7cd3dd57df0e38f46bdc2734 Mon Sep 17 00:00:00 2001
From: Lars Op den Kamp <lars@opdenkamp.eu>
Date: Tue, 28 Oct 2014 14:52:16 +0100
Subject: [PATCH 10/38] [CEC] renamed the iDoubleTapTimeoutMs in the new libCEC
 for clarity. does not change binary compatibility

---
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 056a77e..23c56c4 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -1378,8 +1378,13 @@ void CPeripheralCecAdapter::SetConfigurationFromSettings(void)
   m_configuration.bPowerOffOnStandby = iStandbyAction == 13011 ? 1 : 0;
   m_configuration.bShutdownOnStandby = iStandbyAction == 13005 ? 1 : 0;
 
-  // double tap prevention timeout in ms
+#if defined(CEC_DOUBLE_TAP_TIMEOUT_MS_OLD)
+  // double tap prevention timeout in ms. libCEC uses 50ms units for this in 2.2.0, so divide by 50
+  m_configuration.iDoubleTapTimeout50Ms = GetSettingInt("double_tap_timeout_ms") / 50;
+#else
+  // backwards compatibility. will be removed once the next major release of libCEC is out
   m_configuration.iDoubleTapTimeoutMs = GetSettingInt("double_tap_timeout_ms");
+#endif
 }
 
 void CPeripheralCecAdapter::ReadLogicalAddresses(const CStdString &strString, cec_logical_addresses &addresses)

From 764726a2a9ccdebe6977263bfaf769ea272ef69a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 22 Jul 2013 21:05:25 +0100
Subject: [PATCH 11/38] Fix the non-trivial dirty rectangle modes

EGL is typically double or triple buffered, and the previous buffer contents are not preserved.
This means the non-trivial dirty rectangle modes display a flickery mess.

EGL does provide a means for requesting the EGL buffer is preserved across calls.
It seems appropriate to request that when using dirty rectangle modes.

This PR makes algorithmdirtyregions 1 and 2 work on the Raspberry Pi.
It needs testing on other EGL platforms.
---
 xbmc/windowing/egl/EGLWrapper.cpp   |  7 +++++++
 xbmc/windowing/egl/EGLWrapper.h     |  1 +
 xbmc/windowing/egl/WinSystemEGL.cpp | 18 +++++++++++++++++-
 3 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/egl/EGLWrapper.cpp b/xbmc/windowing/egl/EGLWrapper.cpp
index a5442e1..f1dcbad 100644
--- a/xbmc/windowing/egl/EGLWrapper.cpp
+++ b/xbmc/windowing/egl/EGLWrapper.cpp
@@ -376,5 +376,12 @@ bool CEGLWrapper::GetConfigAttrib(EGLDisplay display, EGLConfig config, EGLint a
     return eglGetConfigAttrib(display, config, attribute, value);
   return false;
 }
+
+bool CEGLWrapper::SurfaceAttrib(EGLDisplay display, EGLSurface surface, EGLint attribute, EGLint value)
+{
+  if ((display == EGL_NO_DISPLAY) || (surface == EGL_NO_SURFACE))
+    return false;
+  return eglSurfaceAttrib(display, surface, attribute, value);
+}
 #endif
 
diff --git a/xbmc/windowing/egl/EGLWrapper.h b/xbmc/windowing/egl/EGLWrapper.h
index 3864982..91c8424 100644
--- a/xbmc/windowing/egl/EGLWrapper.h
+++ b/xbmc/windowing/egl/EGLWrapper.h
@@ -62,6 +62,7 @@ class CEGLWrapper
   bool SetVSync(EGLDisplay display, bool enable);
   bool IsExtSupported(const char* extension);
   bool GetConfigAttrib(EGLDisplay display, EGLConfig config, EGLint attribute, EGLint *value);
+  bool SurfaceAttrib(EGLDisplay display, EGLSurface surface, EGLint  attribute, EGLint  value);
 
 private:
     CEGLNativeType          *m_nativeTypes;
diff --git a/xbmc/windowing/egl/WinSystemEGL.cpp b/xbmc/windowing/egl/WinSystemEGL.cpp
index 4a0f2bb..481a2a5 100644
--- a/xbmc/windowing/egl/WinSystemEGL.cpp
+++ b/xbmc/windowing/egl/WinSystemEGL.cpp
@@ -23,6 +23,8 @@
 
 #include "WinSystemEGL.h"
 #include "filesystem/SpecialProtocol.h"
+#include "guilib/IDirtyRegionSolver.h"
+#include "settings/AdvancedSettings.h"
 #include "settings/Settings.h"
 #include "settings/GUISettings.h"
 #include "utils/log.h"
@@ -93,6 +95,12 @@ bool CWinSystemEGL::InitWindowSystem()
     return false;
   }
 
+  EGLint surface_type = EGL_WINDOW_BIT;
+  // for the non-trivial dirty region modes, we need the EGL buffer to be preserved across updates
+  if (g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION ||
+      g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION)
+    surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT;
+
   EGLint configAttrs [] = {
         EGL_RED_SIZE,        8,
         EGL_GREEN_SIZE,      8,
@@ -102,7 +110,7 @@ bool CWinSystemEGL::InitWindowSystem()
         EGL_STENCIL_SIZE,    0,
         EGL_SAMPLE_BUFFERS,  0,
         EGL_SAMPLES,         0,
-        EGL_SURFACE_TYPE,    EGL_WINDOW_BIT,
+        EGL_SURFACE_TYPE,    surface_type,
         EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
         EGL_NONE
   };
@@ -190,6 +198,14 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
     return false;
   }
 
+  // for the non-trivial dirty region modes, we need the EGL buffer to be preserved across updates
+  if (g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION ||
+      g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION)
+  {
+    if (!m_egl->SurfaceAttrib(m_display, m_surface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED))
+      CLog::Log(LOGDEBUG, "%s: Could not set EGL_SWAP_BEHAVIOR",__FUNCTION__);
+  }
+
   m_bWindowCreated = true;
 
   return true;

From 100551f3b1ce7f883576f7a67eece4d74918ead6 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Mar 2013 20:50:59 +0100
Subject: [PATCH 12/38] fix incorrect display of fps when dr kicks in

---
 xbmc/Application.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index a58d5e5..a911b6d 100755
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2613,10 +2613,11 @@ void CApplication::Render()
     if (frameTime < singleFrameTime)
       Sleep(singleFrameTime - frameTime);
   }
-  m_lastFrameTime = XbmcThreads::SystemClockMillis();
 
   if (flip)
     g_graphicsContext.Flip(dirtyRegions);
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
   CTimeUtils::UpdateFrameTime(flip);
 
   g_renderManager.UpdateResolution();

From 85e70e38fb30e05115e2797f5f66496fd4618262 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 10:22:34 +0100
Subject: [PATCH 13/38] Change wait time to 100ms

---
 plex/GUI/GUIPlexMediaWindow.cpp    | 2 +-
 plex/Utility/PlexBusyIndicator.cpp | 2 +-
 xbmc/cores/amlplayer/AMLPlayer.cpp | 2 +-
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 2 +-
 xbmc/filesystem/Directory.cpp      | 2 +-
 5 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/plex/GUI/GUIPlexMediaWindow.cpp b/plex/GUI/GUIPlexMediaWindow.cpp
index 1b8454f..44ba4ca 100755
--- a/plex/GUI/GUIPlexMediaWindow.cpp
+++ b/plex/GUI/GUIPlexMediaWindow.cpp
@@ -375,7 +375,7 @@ void CGUIPlexMediaWindow::OnFilterButton(int filterButtonId)
       if (busy)
       {
         busy->Show();
-        while(!m_filterValuesEvent.WaitMSec(10))
+        while(!m_filterValuesEvent.WaitMSec(100))
         {
           g_windowManager.ProcessRenderLoop(false);
           if (busy->IsCanceled())
diff --git a/plex/Utility/PlexBusyIndicator.cpp b/plex/Utility/PlexBusyIndicator.cpp
index e0477a7..0d573c1 100644
--- a/plex/Utility/PlexBusyIndicator.cpp
+++ b/plex/Utility/PlexBusyIndicator.cpp
@@ -40,7 +40,7 @@ bool CPlexBusyIndicator::blockWaitingForJob(CJob* job, IJobCallback* callback, C
   while (m_callbackMap.size() > 0)
   {
     lk.Leave();
-    while (!m_blockEvent.WaitMSec(20))
+    while (!m_blockEvent.WaitMSec(100))
     {
       lk.Enter();
       if (busy && busy->IsCanceled())
diff --git a/xbmc/cores/amlplayer/AMLPlayer.cpp b/xbmc/cores/amlplayer/AMLPlayer.cpp
index 6b9a73a..dd96a5d 100644
--- a/xbmc/cores/amlplayer/AMLPlayer.cpp
+++ b/xbmc/cores/amlplayer/AMLPlayer.cpp
@@ -584,7 +584,7 @@ bool CAMLPlayer::OpenFile(const CFileItem &file, const CPlayerOptions &options)
     {
       CGUIDialogBusy *dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
       dialog->Show();
-      while (!m_ready.WaitMSec(1))
+      while (!m_ready.WaitMSec(100))
         g_windowManager.ProcessRenderLoop(false);
       dialog->Close();
     }
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 4cece9d..7edfc27 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -502,7 +502,7 @@ bool CDVDPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
       if(dialog)
       {
         dialog->Show();
-        while(!m_ready.WaitMSec(1))
+        while(!m_ready.WaitMSec(100))
         {
           /* PLEX */
           if (dialog->IsCanceled())
diff --git a/xbmc/filesystem/Directory.cpp b/xbmc/filesystem/Directory.cpp
index aa8ae75..c703986 100644
--- a/xbmc/filesystem/Directory.cpp
+++ b/xbmc/filesystem/Directory.cpp
@@ -157,7 +157,7 @@ bool CDirectory::GetDirectory(const CStdString& strPath, CFileItemList &items, c
             CGUIDialogBusy* dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
             dialog->Show();
 
-            while(!get.Wait(10))
+            while(!get.Wait(100))
             {
               CSingleLock lock(g_graphicsContext);
 

From 7b095fa0e13949408e0458995fa84b26c5bdb4bc Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 10:42:18 +0100
Subject: [PATCH 14/38] Revert part of 23cb50e1 Core rendering changes for
 Raspberry Pi

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 16 ++--------------
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h   |  4 ----
 2 files changed, 2 insertions(+), 18 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 980e578..10b1ac7 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -90,15 +90,9 @@ void CEGLNativeTypeRaspberryPI::Initialize()
   m_dispman_element         = DISPMANX_NO_HANDLE;
   m_dispman_element2        = DISPMANX_NO_HANDLE;
   m_dispman_display         = DISPMANX_NO_HANDLE;
-/* PLEX */
-#if defined(__PLEX__)
-  m_width                   = 1920;
-  m_height                  = 1080;
-#else
+
   m_width                   = 1280;
   m_height                  = 720;
-#endif  
-/* END PLEX */
   m_initDesktopRes          = true;
 
   m_DllBcmHost = new DllBcmHost;
@@ -672,13 +666,7 @@ void CEGLNativeTypeRaspberryPI::CallbackTvServiceCallback(void *userdata, uint32
 
 bool CEGLNativeTypeRaspberryPI::ClampToGUIDisplayLimits(int &width, int &height)
 {
-/* PLEX */
-#if defined(__PLEX__)
-  const int max_width = 1920, max_height = 1080;
-#else
-  const int max_width = 1280, max_height = 720;  
-#endif
-/* END PLEX */  
+  const int max_width = 1280, max_height = 720;
   float ar = (float)width/(float)height;
   // bigger than maximum, so need to clamp
   if (width > max_width || height > max_height) {
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
index a48e470..9af2123 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
@@ -26,10 +26,6 @@
 #include <bcm_host.h>
 #endif
 
-/* PLEX */
-#include "interface/vmcs_host/vc_dispmanx.h" 
-/* END PLEX */
-
 class DllBcmHost;
 class CEGLNativeTypeRaspberryPI : public CEGLNativeType
 {

From f8c2ee0f84adaa8410f7dc5590f87af589d0e841 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 11:15:44 +0100
Subject: [PATCH 15/38] Revert plex render rgb code

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp   |  96 +----------------
 xbmc/cores/VideoRenderers/LinuxRendererGL.h     |   9 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp |  74 -------------
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h   |  11 +-
 xbmc/cores/VideoRenderers/RenderFlags.h         |   1 -
 xbmc/cores/VideoRenderers/RenderManager.h       |  11 --
 xbmc/cores/VideoRenderers/WinRenderer.cpp       | 137 ------------------------
 xbmc/cores/VideoRenderers/WinRenderer.h         |  18 ----
 8 files changed, 4 insertions(+), 353 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index e8baae8..fff9e9f 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -46,10 +46,6 @@
 #include "RenderCapture.h"
 #include "RenderFormats.h"
 
-/* PLEX */
-#include "StringUtils.h"
-/* END PLEX */
-
 #ifdef HAVE_LIBVDPAU
 #include "cores/dvdplayer/DVDCodecs/Video/VDPAU.h"
 #endif
@@ -181,10 +177,6 @@ CLinuxRendererGL::CLinuxRendererGL()
   m_rgbPbo = 0;
 
   m_dllSwScale = new DllSwScale;
-
-  /* PLEX */
-  m_bRGBImageSet = false;
-  /* END PLEX */
 }
 
 CLinuxRendererGL::~CLinuxRendererGL()
@@ -231,28 +223,16 @@ bool CLinuxRendererGL::ValidateRenderer()
     return false;
 
   // this needs to be checked after texture validation
-#ifndef __PLEX__
   if (!m_bImageReady)
-#else
-  if (!m_bRGBImageSet && !m_bImageReady)
-#endif
     return false;
 
   int index = m_iYV12RenderBuffer;
   YUVBUFFER& buf =  m_buffers[index];
 
-#ifndef __PLEX__
   if (!buf.fields[FIELD_FULL][0].id)
-#else
-  if (!m_bRGBImageSet && !buf.fields[FIELD_FULL][0].id)
-#endif
     return false;
 
-#ifndef __PLEX__
   if (buf.image.flags==0)
-#else
-  if (!m_bRGBImageSet && buf.image.flags==0)
-#endif
     return false;
 
   return true;
@@ -336,20 +316,14 @@ bool CLinuxRendererGL::Configure(unsigned int width, unsigned int height, unsign
 
   m_pboSupported = glewIsSupported("GL_ARB_pixel_buffer_object") && g_guiSettings.GetBool("videoplayer.usepbo");
 
-  /* PLEX */
-  m_rgbBufferSize = width*height*4;
-  m_rgbBuffer = new BYTE[m_rgbBufferSize];
-  memset(m_rgbBuffer, 0, m_rgbBufferSize);
-  /* END PLEX */
-
 #ifdef TARGET_DARWIN_OSX
   // on osx 10.9 mavericks we get a strange ripple
   // effect when rendering with pbo
   // when used on intel gpu - we have to quirk it here
   if (DarwinIsMavericks())
   {
-    std::string rendervendor = g_Windowing.GetRenderVendor();
-    StringUtils::ToLower(rendervendor);
+    CStdString rendervendor = g_Windowing.GetRenderVendor();
+    rendervendor.MakeLower();
     if (rendervendor.find("intel") != std::string::npos)
       m_pboSupported = false;
   }
@@ -495,14 +469,8 @@ void CLinuxRendererGL::LoadPlane( YUVPLANE& plane, int type, unsigned flipindex
                                 , unsigned width, unsigned height
                                 , int stride, int bpp, void* data, GLuint* pbo/*= NULL*/)
 {
-  /* PLEX */
-  if(!m_bRGBImageSet && plane.flipindex == flipindex)
-    return;
-  /* END PLEX */
-#ifndef __PLEX__
   if(plane.flipindex == flipindex)
     return;
-#endif
 
   //if no pbo given, use the plane pbo
   GLuint currPbo;
@@ -553,11 +521,7 @@ void CLinuxRendererGL::UploadYV12Texture(int source)
   YV12Image* im     = &buf.image;
   YUVFIELDS& fields =  buf.fields;
 
-#ifndef __PLEX__
   if (!(im->flags&IMAGE_FLAG_READY))
-#else
-  if (!m_bRGBImageSet && !(im->flags&IMAGE_FLAG_READY))
-#endif
   {
     m_eventTexturesDone[source]->Set();
     return;
@@ -681,11 +645,7 @@ void CLinuxRendererGL::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 
   g_graphicsContext.BeginPaint();
 
-#ifndef __PLEX__
   if( !m_eventTexturesDone[index]->WaitMSec(500))
-#else
-  if( !m_bRGBImageSet && !m_eventTexturesDone[index]->WaitMSec(500))
-#endif
   {
     CLog::Log(LOGWARNING, "%s - Timeout waiting for texture %d", __FUNCTION__, index);
 
@@ -830,10 +790,6 @@ void CLinuxRendererGL::FlipPage(int source)
 unsigned int CLinuxRendererGL::PreInit()
 {
   CSingleLock lock(g_graphicsContext);
-  /* PLEX */
-  m_bRGBImageSet = false;
-  /* END PLEX */
-
   m_bConfigured = false;
   m_bValidated = false;
   UnInit();
@@ -1010,16 +966,6 @@ void CLinuxRendererGL::UpdateVideoFilter()
 
 void CLinuxRendererGL::LoadShaders(int field)
 {
-  /* PLEX */
-  if (m_bRGBImageSet)
-  {
-    /* If we have a RGBImageSet we override the renderMethod */
-    CLog::Log(LOGNOTICE, "GL: Using Software render method because of RGBImageSet");
-    m_renderMethod = RENDER_SW;
-  }
-  else
-  /* END PLEX */
-
   if (m_format == RENDER_FMT_VDPAU)
   {
     CLog::Log(LOGNOTICE, "GL: Using VDPAU render method");
@@ -3120,11 +3066,7 @@ void CLinuxRendererGL::UploadRGBTexture(int source)
   YV12Image* im     = &buf.image;
   YUVFIELDS& fields =  buf.fields;
 
-#ifndef __PLEX__
   if (!(im->flags&IMAGE_FLAG_READY))
-#else
-  if (!m_bRGBImageSet && !(im->flags&IMAGE_FLAG_READY))
-#endif
   {
     m_eventTexturesDone[source]->Set();
     return;
@@ -3514,38 +3456,4 @@ void CLinuxRendererGL::AddProcessor(struct __CVBuffer *cvBufferRef)
 }
 #endif
 
-/* PLEX */
-void CLinuxRendererGL::SetRGB32Image(const char *image, int nHeight, int nWidth, int nPitch)
-{
-  CSingleLock lock(g_graphicsContext);
-  if (m_rgbBuffer == 0)
-  {
-    m_rgbBufferSize = nWidth*nHeight*4;
-    m_rgbBuffer = new BYTE[m_rgbBufferSize];
-    memset(m_rgbBuffer, 0, m_rgbBufferSize);
-  }
-
-  if (nHeight * nWidth * 4 > m_rgbBufferSize)
-  {
-    CLog::Log(LOGERROR,"%s, incorrect image size", __FUNCTION__);
-    return;
-  }
-
-  if (nPitch == nWidth * 4)
-    memcpy(m_rgbBuffer, image, nHeight * nPitch);
-  else
-    for (int i=0; i<nHeight; i++)
-      memcpy(m_rgbBuffer + (i * nWidth * 4), image + (i * nPitch),  nWidth * 4);
-
-  m_bRGBImageSet = true;
-  m_renderMethod = RENDER_SW;
-
-  if (m_pYUVShader)
-  {
-    delete m_pYUVShader;
-    m_pYUVShader = NULL;
-  }
-}
-/* END PLEX */
-
 #endif
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index b313ca1..acebfe0 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -159,11 +159,8 @@ class CLinuxRendererGL : public CBaseRenderer
   virtual bool Supports(ESCALINGMETHOD method);
 
   virtual EINTERLACEMETHOD AutoInterlaceMethod();
-  virtual std::vector<ERenderFormat> SupportedFormats() { return m_formats; }
 
-  /* PLEX */
-  virtual void SetRGB32Image(const char *image, int nHeight, int nWidth, int nPitch);
-  /* END PLEX */
+  virtual std::vector<ERenderFormat> SupportedFormats() { return m_formats; }
 
 protected:
   virtual void Render(DWORD flags, int renderBuffer);
@@ -327,10 +324,6 @@ class CLinuxRendererGL : public CBaseRenderer
   bool  m_nonLinStretch;
   bool  m_nonLinStretchGui;
   float m_pixelRatio;
-
-  /* PLEX */
-  bool         m_bRGBImageSet;
-  /* END PLEX */
 };
 
 
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index dd106b1..cb0939f 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -112,12 +112,6 @@ CLinuxRendererGLES::CLinuxRendererGLES()
 
   m_dllSwScale = new DllSwScale;
   m_sw_context = NULL;
-  /* PLEX */
-#if defined(TARGET_RASPBERRY_PI)
-  m_bRGBImageSet = false;
-#endif
-  /* END PLEX */
-
 }
 
 CLinuxRendererGLES::~CLinuxRendererGLES()
@@ -349,14 +343,8 @@ void CLinuxRendererGLES::LoadPlane( YUVPLANE& plane, int type, unsigned flipinde
                                 , unsigned width, unsigned height
                                 , int stride, void* data )
 {
-#if defined(__PLEX__)
-  if(!m_bRGBImageSet && plane.flipindex == flipindex)
-    return;
-#else
   if(plane.flipindex == flipindex)
     return;
-#endif
-
 
   const GLvoid *pixelData = data;
 
@@ -1326,7 +1314,6 @@ void CLinuxRendererGLES::RenderCoreVideoRef(int index, int field)
 #endif
 }
 
-
 bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
 {
   if (!m_bValidated)
@@ -2013,66 +2000,5 @@ void CLinuxRendererGLES::AddProcessor(struct __CVBuffer *cvBufferRef)
 }
 #endif
 
-/* PLEX */
-void CLinuxRendererGLES::SetRGB32Image(const char *image, int nHeight, int nWidth, int nPitch)
-{
-  CSingleLock lock(g_graphicsContext);
-  if (m_rgbBuffer == 0)
-  {
-    m_rgbBufferSize = nWidth*nHeight*4;
-    m_rgbBuffer = new BYTE[m_rgbBufferSize];
-    memset(m_rgbBuffer, 0, m_rgbBufferSize);
-  }
-
-  if (nHeight * nWidth * 4 > m_rgbBufferSize)
-  {
-    CLog::Log(LOGERROR,"%s, incorrect image size", __FUNCTION__);
-    return;
-  }
-
-  if (nPitch == nWidth * 4)
-    memcpy(m_rgbBuffer, image, nHeight * nPitch);
-  else
-    for (int i=0; i<nHeight; i++)
-      memcpy(m_rgbBuffer + (i * nWidth * 4), image + (i * nPitch),  nWidth * 4);
-
-  m_bRGBImageSet = true;
-  m_renderMethod = RENDER_SW;
-
-  if (m_pYUVShader)
-  {
-    delete m_pYUVShader;
-    m_pYUVShader = NULL;
-  }
-}
-/* END PLEX */
 #endif
 
-
-/* PLEX */
-bool CLinuxRendererGLES::ValidateRenderer()
-{
-  if (!m_bConfigured)
-    return false;
-
-  // if its first pass, just init textures and return
-  if (ValidateRenderTarget())
-    return false;
-
-  // this needs to be checked after texture validation
-  if (!m_bRGBImageSet && !m_bImageReady)
-    return false;
-
-  int index = m_iYV12RenderBuffer;
-  YUVBUFFER& buf =  m_buffers[index];
-
-  if (!m_bRGBImageSet && !buf.fields[FIELD_FULL][0].id)
-    return false;
-
-  if (!m_bRGBImageSet && buf.image.flags==0)
-    return false;
-
-  return true;
-}
-/* END PLEX */
-
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 683a86d..76b5437 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -159,16 +159,9 @@ class CLinuxRendererGLES : public CBaseRenderer
   virtual void         AddProcessor(struct __CVBuffer *cvBufferRef);
 #endif
 
-  /* PLEX */
-  virtual void SetRGB32Image(const char *image, int nHeight, int nWidth, int nPitch);
-  /* END PLEX */
-
 protected:
   virtual void Render(DWORD flags, int index);
 
-  /* PLEX */
-  bool ValidateRenderer();
-  /* END PLEX */
   virtual void ManageTextures();
   int  NextYV12Texture();
   virtual bool ValidateRenderTarget();
@@ -289,9 +282,7 @@ class CLinuxRendererGLES : public CBaseRenderer
   unsigned int m_rgbBufferSize;
 
   CEvent* m_eventTexturesDone[NUM_BUFFERS];
-  /* PLEX */
-  bool        m_bRGBImageSet;
-  /* END PLEX */
+
 };
 
 
diff --git a/xbmc/cores/VideoRenderers/RenderFlags.h b/xbmc/cores/VideoRenderers/RenderFlags.h
index 378bbda..ce397fc 100644
--- a/xbmc/cores/VideoRenderers/RenderFlags.h
+++ b/xbmc/cores/VideoRenderers/RenderFlags.h
@@ -48,7 +48,6 @@
 
 #define CONF_FLAGS_YUV_FULLRANGE 0x08
 #define CONF_FLAGS_FULLSCREEN    0x10
-#define CONF_FLAGS_RGB           0x20
 
 /* defines color primaries */
 #define CONF_FLAGS_COLPRI_MASK(a) ((a) & 0xe0)
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 918f1c1..0dd0031 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -144,17 +144,6 @@ class CXBMCRenderManager
 
   void RegisterRenderUpdateCallBack(const void *ctx, RenderUpdateCallBackFn fn);
 
-  /* PLEX */
-  inline void SetRGB32Image(const char *image, int nHeight, int nWidth, int nPitch)
-  {
-    if (!image)
-      return;
-
-    CSharedLock lock(m_sharedSection);
-    if (m_pRenderer)
-      m_pRenderer->SetRGB32Image(image, nHeight, nWidth, nPitch);
-  }
-  /* END PLEX */
 protected:
   void Render(bool clear, DWORD flags, DWORD alpha);
 
diff --git a/xbmc/cores/VideoRenderers/WinRenderer.cpp b/xbmc/cores/VideoRenderers/WinRenderer.cpp
index 36f3fcf..f1d0768 100644
--- a/xbmc/cores/VideoRenderers/WinRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/WinRenderer.cpp
@@ -124,13 +124,6 @@ void CWinRenderer::ManageTextures()
 
 void CWinRenderer::SelectRenderMethod()
 {
-  /* PLEX
-  if (m_iFlags & CONF_FLAGS_RGB)
-  {
-    m_renderMethod = RENDER_RGB;
-  }
-  else
-   END PLEX */
   // Set rendering to dxva before trying it, in order to open the correct processor immediately, when deinterlacing method is auto.
 
   // Force dxva renderer after dxva decoding: PS and SW renderers have performance issues after dxva decode.
@@ -652,10 +645,6 @@ void CWinRenderer::Render(DWORD flags)
     RenderSW();
   else if (m_renderMethod == RENDER_PS)
     RenderPS();
-  /* PLEX */
-  else if (m_renderMethod == RENDER_RGB)
-    RenderRGB();
-  /* END PLEX */
 
   pD3DDevice->SetDepthStencilSurface(pZBuffer);
   pZBuffer->Release();
@@ -1273,130 +1262,4 @@ void DXVABuffer::StartDecode()
 {
   Release();
 }
-
-/* PLEX */
-void CWinRenderer::RenderRGB()
-{
-  // TODO(schuyler) We should be able to combine this with the second half
-  // of RenderSW.
-
-  D3DLOCKED_RECT rect;
-  LPDIRECT3DSURFACE9 videoSurface;
-  D3DSURFACE_DESC desc;
-  LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
-  HRESULT hr;
-
-  if (!m_rgbTexture)
-  {
-    hr = pD3DDevice->CreateTexture(m_sourceWidth, m_sourceHeight, 1,
-        D3DUSAGE_DYNAMIC, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT, &m_rgbTexture, NULL);
-    if (hr != D3D_OK)
-    {
-      CLog::Log(LOGERROR, "Failed to create RGB texture: 0x%08x", hr);
-      return;
-    }
-  }
-
-  // Copy our RGB buffer onto our texture.
-  if (m_rgbBuffer)
-  {
-    BYTE* src = m_rgbBuffer;
-    m_rgbTexture->GetSurfaceLevel(0, &videoSurface);
-    videoSurface->GetDesc(&desc);
-    if (videoSurface->LockRect(&rect, NULL, 0) == D3D_OK)
-    {
-      for (unsigned int j = 0; j < std::min(m_sourceHeight, desc.Height); j++)
-        memcpy((BYTE*)rect.pBits + (j * rect.Pitch), src + (j * m_sourceWidth * 4), m_sourceWidth * 4);
-
-      videoSurface->UnlockRect();
-      videoSurface->Release();
-    }
-    else
-    {
-      CLog::Log(LOGERROR, "Failed to lock RGB texture rect");
-      videoSurface->Release();
-      return;
-    }
-  }
-
-  pD3DDevice->SetTexture(0, m_rgbTexture);
-  pD3DDevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
-  pD3DDevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
-  pD3DDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
-  pD3DDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
-
-  pD3DDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
-  pD3DDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
-  pD3DDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
-  pD3DDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
-  pD3DDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
-  pD3DDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
-
-  pD3DDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
-  pD3DDevice->SetFVF(D3DFVF_XYZRHW | D3DFVF_TEX1);
-
-  struct CUSTOMVERTEX {
-    FLOAT x, y, z;
-    FLOAT rhw;
-    FLOAT tu, tv;
-  };
-
-  // Create vertices for triangle fan rendering.
-  CUSTOMVERTEX verts[4] =
-  {
-    {
-      m_destRect.x1, m_destRect.y1, 0.0f,
-      1.0f,
-      m_sourceRect.x1 / m_sourceWidth, m_sourceRect.y1 / m_sourceHeight
-    },
-    {
-      m_destRect.x2, m_destRect.y1, 0.0f,
-      1.0f,
-      m_sourceRect.x2 / m_sourceWidth, m_sourceRect.y1 / m_sourceHeight
-    },
-    {
-      m_destRect.x2, m_destRect.y2, 0.0f,
-      1.0f,
-      m_sourceRect.x2 / m_sourceWidth, m_sourceRect.y2 / m_sourceHeight
-    },
-    {
-      m_destRect.x1, m_destRect.y2, 0.0f,
-      1.0f,
-      m_sourceRect.x1 / m_sourceWidth, m_sourceRect.y2 / m_sourceHeight
-    }
-  };
-
-  pD3DDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, verts, sizeof(CUSTOMVERTEX));
-  pD3DDevice->SetTexture(0, NULL);
-}
-
-void CWinRenderer::SetRGB32Image(const char *image, int nHeight, int nWidth, int nPitch)
-{
-  CSingleLock lock(g_graphicsContext);
-
-  if (!m_rgbBuffer || m_renderMethod != RENDER_RGB)
-  {
-    CLog::Log(LOGERROR, "%s called without first calling Configure", __FUNCTION__);
-    return;
-  }
-
-  if (nHeight * nWidth * 4 != m_rgbBufferSize)
-  {
-    CLog::Log(LOGERROR, "%s, incorrect image size", __FUNCTION__);
-    return;
-  }
-
-  if (nPitch == nWidth * 4)
-    memcpy(m_rgbBuffer, image, nHeight * nPitch);
-  else
-    for (int i = 0; i < nHeight; i++)
-      memcpy(m_rgbBuffer + (i * nWidth * 4), image + (i * nPitch), nWidth * 4);
-
-  m_bRGBImageSet = true;
-}
-
-/* END PLEX */
-
 #endif
-
-
diff --git a/xbmc/cores/VideoRenderers/WinRenderer.h b/xbmc/cores/VideoRenderers/WinRenderer.h
index cb3c95f..2ab5684 100644
--- a/xbmc/cores/VideoRenderers/WinRenderer.h
+++ b/xbmc/cores/VideoRenderers/WinRenderer.h
@@ -83,8 +83,6 @@ enum RenderMethod
   RENDER_PS      = 0x01,
   RENDER_SW      = 0x02,
   RENDER_DXVA    = 0x03,
-  /* PLEX */
-  RENDER_RGB     = 0x04,
 };
 
 #define PLANE_Y 0
@@ -178,11 +176,6 @@ class CWinRenderer : public CBaseRenderer
   void                 RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
 
   virtual unsigned int GetProcessorSize() { return m_processor.Size(); }
-  
-  /* PLEX */
-  virtual void SetRGB32Image(const char *image, int nHeight, int nWidth, int nPitch);
-  /* END PLEX */
-  
 
 protected:
   virtual void Render(DWORD flags);
@@ -197,10 +190,6 @@ class CWinRenderer : public CBaseRenderer
   bool         CreateYV12Texture(int index);
   void         CopyYV12Texture(int dest);
   int          NextYV12Texture();
-  
-  /* PLEX */
-  void         RenderRGB();
-  /* END PLEX */
 
   void SelectRenderMethod();
   bool UpdateRenderMethod();
@@ -256,13 +245,6 @@ class CWinRenderer : public CBaseRenderer
   // the separable HQ scalers need this info, but could the m_destRect be used instead?
   unsigned int         m_destWidth;
   unsigned int         m_destHeight;
-
-  /* PLEX - RGB rendering */
-  BYTE                *m_rgbBuffer;
-  int                  m_rgbBufferSize;
-  bool                 m_bRGBImageSet;
-  LPDIRECT3DTEXTURE9   m_rgbTexture;
-  /* END PLEX */
 };
 
 #else

From f3d1255074a89370b7bb63bed40081f64e8bdd10 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 11:16:14 +0100
Subject: [PATCH 16/38] Revert plex omx code

---
 xbmc/linux/DllBCM.h |  6 ------
 xbmc/linux/DllOMX.h | 11 ++---------
 2 files changed, 2 insertions(+), 15 deletions(-)

diff --git a/xbmc/linux/DllBCM.h b/xbmc/linux/DllBCM.h
index ea89038..ab58cf2 100644
--- a/xbmc/linux/DllBCM.h
+++ b/xbmc/linux/DllBCM.h
@@ -156,13 +156,7 @@ class DllBcmHost : public DllDynamic, DllBcmHostInterface
 #else
 class DllBcmHost : public DllDynamic, DllBcmHostInterface
 {
-/* PLEX */
-#if defined(TARGET_RASPBERRY_PI)
-  DECLARE_DLL_WRAPPER(DllBcmHost, "/usr/lib/libbcm_host.so")
-#else
   DECLARE_DLL_WRAPPER(DllBcmHost, "/opt/vc/lib/libbcm_host.so")
-#endif
-/* PLEX */
 
   DEFINE_METHOD0(void,    bcm_host_init)
   DEFINE_METHOD0(void,    bcm_host_deinit)
diff --git a/xbmc/linux/DllOMX.h b/xbmc/linux/DllOMX.h
index f1cb1cb..2ed4a4b 100644
--- a/xbmc/linux/DllOMX.h
+++ b/xbmc/linux/DllOMX.h
@@ -56,9 +56,8 @@ class DllOMXInterface
   virtual OMX_ERRORTYPE OMX_SetupTunnel(OMX_HANDLETYPE hOutput, OMX_U32 nPortOutput, OMX_HANDLETYPE hInput, OMX_U32 nPortInput) = 0;
 
 };
-/* PLEX */
-#ifndef TARGET_RASPBERRY_PI
-/* END PLEX */
+
+#if (defined USE_EXTERNAL_OMX)
 class DllOMX : public DllDynamic, DllOMXInterface
 {
 public:
@@ -90,13 +89,7 @@ class DllOMX : public DllDynamic, DllOMXInterface
 #else
 class DllOMX : public DllDynamic, DllOMXInterface
 {
-/* PLEX */
-#if defined (TARGET_RASPBERRY_PI)
-  DECLARE_DLL_WRAPPER(DllOMX, "/usr/lib/libopenmaxil.so")
-#else
   DECLARE_DLL_WRAPPER(DllOMX, "libopenmaxil.so")
-#endif
-/* END PLEX */
 
   DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Init)
   DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Deinit)

From f094e20bb5518cda8a92c3055ffa7750e72f230f Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 11:18:05 +0100
Subject: [PATCH 17/38] Sync with frodo_rbp_backports

---
 xbmc/Application.cpp                               |    4 +-
 xbmc/FileItem.cpp                                  |   69 +-
 xbmc/FileItem.h                                    |    3 +-
 xbmc/TextureCacheJob.cpp                           |   21 +-
 xbmc/TextureCacheJob.h                             |    2 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    |   12 +-
 xbmc/cores/VideoRenderers/OverlayRendererGL.cpp    |   10 +-
 xbmc/cores/VideoRenderers/RenderCapture.cpp        |   38 +-
 xbmc/cores/VideoRenderers/RenderCapture.h          |   28 +-
 xbmc/cores/VideoRenderers/RenderManager.h          |   12 -
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp |    3 +-
 xbmc/cores/dvdplayer/DVDPlayer.cpp                 |    4 +-
 xbmc/cores/omxplayer/OMXAudio.cpp                  | 1450 ++++++++++-------
 xbmc/cores/omxplayer/OMXAudio.h                    |   75 +-
 xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp          |  225 ++-
 xbmc/cores/omxplayer/OMXAudioCodecOMX.h            |   10 +-
 xbmc/cores/omxplayer/OMXImage.cpp                  | 1685 ++++++++++++++++----
 xbmc/cores/omxplayer/OMXImage.h                    |  178 ++-
 xbmc/cores/omxplayer/OMXPlayer.cpp                 |  779 +++++----
 xbmc/cores/omxplayer/OMXPlayer.h                   |  317 ++--
 xbmc/cores/omxplayer/OMXPlayerAudio.cpp            |  297 +---
 xbmc/cores/omxplayer/OMXPlayerAudio.h              |   30 +-
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp            |  313 ++--
 xbmc/cores/omxplayer/OMXPlayerVideo.h              |   18 +-
 xbmc/cores/omxplayer/OMXVideo.cpp                  |  739 ++++-----
 xbmc/cores/omxplayer/OMXVideo.h                    |   21 +-
 xbmc/cores/omxplayer/PCMRemap.cpp                  |  813 ++++++++++
 xbmc/cores/omxplayer/PCMRemap.h                    |  151 ++
 xbmc/guilib/DDSImage.cpp                           |    2 +
 xbmc/guilib/JpegIO.cpp                             |    3 +-
 xbmc/guilib/Texture.cpp                            |   84 +-
 xbmc/guilib/Texture.h                              |   10 +-
 xbmc/guilib/TextureGL.cpp                          |    2 +-
 xbmc/guilib/TextureGL.h                            |    2 +-
 xbmc/guilib/TextureManager.cpp                     |    4 -
 xbmc/guilib/TexturePi.cpp                          |  154 ++
 xbmc/guilib/TexturePi.h                            |   49 +
 xbmc/linux/OMXClock.cpp                            |  792 ++-------
 xbmc/linux/OMXClock.h                              |   93 +-
 xbmc/linux/OMXCore.cpp                             |  688 ++++----
 xbmc/linux/OMXCore.h                               |   30 +-
 xbmc/linux/RBP.cpp                                 |   82 +-
 xbmc/linux/RBP.h                                   |   10 +
 xbmc/music/tags/MusicInfoTag.cpp                   |   36 +-
 xbmc/music/tags/MusicInfoTag.h                     |    2 +-
 xbmc/network/AirPlayServer.cpp                     |    4 +-
 xbmc/network/AirPlayServer.h                       |    2 +-
 xbmc/network/AirTunesServer.cpp                    |    4 +-
 xbmc/pictures/Picture.cpp                          |   11 +-
 xbmc/pictures/PictureInfoTag.cpp                   |    4 +-
 xbmc/pictures/PictureInfoTag.h                     |    2 +-
 xbmc/pvr/channels/PVRChannel.cpp                   |    9 +-
 xbmc/pvr/channels/PVRChannel.h                     |    4 +-
 xbmc/rendering/gles/RenderSystemGLES.cpp           |   29 +-
 xbmc/settings/AdvancedSettings.cpp                 |    3 +-
 xbmc/settings/GUISettings.cpp                      |    4 +
 xbmc/utils/ISortable.h                             |    2 +-
 xbmc/utils/JobManager.cpp                          |    4 -
 xbmc/utils/Screenshot.cpp                          |   12 +-
 xbmc/utils/SortUtils.cpp                           |   77 +-
 xbmc/utils/SortUtils.h                             |   10 +-
 xbmc/video/VideoInfoTag.cpp                        |  107 +-
 xbmc/video/VideoInfoTag.h                          |    2 +-
 xbmc/video/windows/GUIWindowFullScreen.cpp         |   12 +-
 xbmc/windowing/egl/WinSystemEGL.h                  |    6 +-
 65 files changed, 5729 insertions(+), 3929 deletions(-)
 create mode 100644 xbmc/cores/omxplayer/PCMRemap.cpp
 create mode 100644 xbmc/cores/omxplayer/PCMRemap.h
 create mode 100644 xbmc/guilib/TexturePi.cpp
 create mode 100644 xbmc/guilib/TexturePi.h

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index a911b6d..f8535de 100755
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -1828,8 +1828,8 @@ bool CApplication::StartAirplayServer()
       {
         txt.push_back(std::make_pair("deviceid", "FF:FF:FF:FF:FF:F2"));
       }
-      txt.push_back(std::make_pair("features", "0x77"));
-      txt.push_back(std::make_pair("model", "Xbmc,1"));
+      txt.push_back(std::make_pair("features", "0x1000009FF"));
+      txt.push_back(std::make_pair("model", "AppleTV3,1"));
       txt.push_back(std::make_pair("srcvers", AIRPLAY_SERVER_VERSION_STR));
       CZeroconf::GetInstance()->PublishService("servers.airplay", "_airplay._tcp", g_infoManager.GetLabel(SYSTEM_FRIENDLY_NAME), listenPort, txt);
       ret = true;
diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index 18cf2b1..193eb59 100755
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -754,45 +754,58 @@ void CFileItem::Serialize(CVariant& value) const
     (*m_pictureInfoTag).Serialize(value["pictureInfoTag"]);
 }
 
-void CFileItem::ToSortable(SortItem &sortable)
-{
-  sortable[FieldPath] = m_strPath;
-  sortable[FieldDate] = (m_dateTime.IsValid()) ? m_dateTime.GetAsDBDateTime() : "";
-  sortable[FieldSize] = m_dwSize;
-  sortable[FieldDriveType] = m_iDriveType;
-  sortable[FieldStartOffset] = m_lStartOffset;
-  sortable[FieldEndOffset] = m_lEndOffset;
-  sortable[FieldProgramCount] = m_iprogramCount;
-  sortable[FieldBitrate] = m_dwSize;
-  sortable[FieldTitle] = m_strTitle;
-  sortable[FieldSortSpecial] = m_specialSort;
-  sortable[FieldFolder] = m_bIsFolder;
-
+void CFileItem::ToSortable(SortItem &sortable, Field field) const
+{
+  switch (field)
+  {
+  case FieldPath:         sortable[FieldPath] = m_strPath; break;
+  case FieldDate:         sortable[FieldDate] = (m_dateTime.IsValid()) ? m_dateTime.GetAsDBDateTime() : ""; break;
+  case FieldSize:         sortable[FieldSize] = m_dwSize; break;
+  case FieldDriveType:    sortable[FieldDriveType] = m_iDriveType; break;
+  case FieldStartOffset:  sortable[FieldStartOffset] = m_lStartOffset; break;
+  case FieldEndOffset:    sortable[FieldEndOffset] = m_lEndOffset; break;
+  case FieldProgramCount: sortable[FieldProgramCount] = m_iprogramCount; break;
+  case FieldBitrate:      sortable[FieldBitrate] = m_dwSize; break;
+  case FieldTitle:        sortable[FieldTitle] = m_strTitle; break;
   // If there's ever a need to convert more properties from CGUIListItem it might be
   // worth to make CGUIListItem  implement ISortable as well and call it from here
-  sortable[FieldLabel] = GetLabel();
+  default: break;
+  }
 
   if (HasMusicInfoTag())
-    GetMusicInfoTag()->ToSortable(sortable);
-    
+    GetMusicInfoTag()->ToSortable(sortable, field);
+
   if (HasVideoInfoTag())
   {
-    GetVideoInfoTag()->ToSortable(sortable);
+    GetVideoInfoTag()->ToSortable(sortable, field);
 
     if (GetVideoInfoTag()->m_type == "tvshow")
     {
-      if (HasProperty("totalepisodes"))
+      if (field == FieldNumberOfEpisodes && HasProperty("totalepisodes"))
         sortable[FieldNumberOfEpisodes] = GetProperty("totalepisodes");
-      if (HasProperty("unwatchedepisodes"))
+      if (field == FieldNumberOfWatchedEpisodes && HasProperty("unwatchedepisodes"))
         sortable[FieldNumberOfWatchedEpisodes] = GetProperty("unwatchedepisodes");
     }
   }
-    
+
   if (HasPictureInfoTag())
-    GetPictureInfoTag()->ToSortable(sortable);
+    GetPictureInfoTag()->ToSortable(sortable, field);
 
   if (HasPVRChannelInfoTag())
-    GetPVRChannelInfoTag()->ToSortable(sortable);
+    GetPVRChannelInfoTag()->ToSortable(sortable, field);
+}
+
+void CFileItem::ToSortable(SortItem &sortable, const Fields &fields) const
+{
+  Fields::const_iterator it;
+  for (it = fields.begin(); it != fields.end(); it++)
+    ToSortable(sortable, *it);
+
+  /* It seems SortUtils assumes we have this one even when we're not sorting by it */
+  sortable[FieldLabel] = GetLabel();
+  /* FieldSortSpecial and FieldFolder are required in conjunction with all other sorters as well */
+  sortable[FieldSortSpecial] = m_specialSort;
+  sortable[FieldFolder] = m_bIsFolder;
 }
 
 bool CFileItem::Exists(bool bUseCache /* = true */) const
@@ -2027,11 +2040,13 @@ void CFileItemList::Sort(SortDescription sortDescription)
   if (m_sortIgnoreFolders)
     sortDescription.sortAttributes = (SortAttribute)((int)sortDescription.sortAttributes | SortAttributeIgnoreFolders);
 
+  const Fields fields = SortUtils::GetFieldsForSorting(sortDescription.sortBy);
   SortItems sortItems((size_t)Size());
   for (int index = 0; index < Size(); index++)
   {
-    m_items[index]->ToSortable(sortItems[index]);
-    sortItems[index][FieldId] = index;
+    sortItems[index] = boost::shared_ptr<SortItem>(new SortItem);
+    m_items[index]->ToSortable(*sortItems[index], fields);
+    (*sortItems[index])[FieldId] = index;
   }
 
   // do the sorting
@@ -2042,9 +2057,9 @@ void CFileItemList::Sort(SortDescription sortDescription)
   sortedFileItems.reserve(Size());
   for (SortItems::const_iterator it = sortItems.begin(); it != sortItems.end(); it++)
   {
-    CFileItemPtr item = m_items[(int)it->at(FieldId).asInteger()];
+    CFileItemPtr item = m_items[(int)(*it)->at(FieldId).asInteger()];
     // Set the sort label in the CFileItem
-    item->SetSortLabel(CStdStringW(it->at(FieldSort).asWideString()));
+    item->SetSortLabel(CStdStringW((*it)->at(FieldSort).asWideString()));
 
     sortedFileItems.push_back(item);
   }
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index 8b75516..99a2226 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -112,7 +112,8 @@ class CFileItem :
   const CFileItem& operator=(const CFileItem& item);
   virtual void Archive(CArchive& ar);
   virtual void Serialize(CVariant& value) const;
-  virtual void ToSortable(SortItem &sortable);
+  virtual void ToSortable(SortItem &sortable, Field field) const;
+  void ToSortable(SortItem &sortable, const Fields &fields) const;
   virtual bool IsFileItem() const { return true; };
 
   bool Exists(bool bUseCache = true) const;
diff --git a/xbmc/TextureCacheJob.cpp b/xbmc/TextureCacheJob.cpp
index 1e631ce..f29ad223 100644
--- a/xbmc/TextureCacheJob.cpp
+++ b/xbmc/TextureCacheJob.cpp
@@ -34,6 +34,9 @@
 #include "FileItem.h"
 #include "music/MusicThumbLoader.h"
 #include "music/tags/MusicInfoTag.h"
+#if defined(HAS_OMXPLAYER)
+#include "cores/omxplayer/OMXImage.h"
+#endif
 
 CTextureCacheJob::CTextureCacheJob(const CStdString &url, const CStdString &oldHash)
 {
@@ -88,7 +91,19 @@ bool CTextureCacheJob::CacheTexture(CBaseTexture **out_texture)
   else if (m_details.hash == m_oldHash)
     return true;
 
-  CBaseTexture *texture = LoadImage(image, width, height, additional_info);
+#if defined(HAS_OMXPLAYER)
+  if (COMXImage::CreateThumb(image, width, height, additional_info, CTextureCache::GetCachedPath(m_cachePath + ".jpg")))
+  {
+    m_details.width = width;
+    m_details.height = height;
+    m_details.file = m_cachePath + ".jpg";
+    if (out_texture)
+      *out_texture = LoadImage(CTextureCache::GetCachedPath(m_details.file), width, height, additional_info);
+    CLog::Log(LOGDEBUG, "Fast %s image '%s' to '%s': %p", m_oldHash.IsEmpty() ? "Caching" : "Recaching", image.c_str(), m_details.file.c_str(), out_texture);
+    return true;
+  }
+#endif
+  CBaseTexture *texture = LoadImage(image, width, height, additional_info, true);
   if (texture)
   {
     if (texture->HasAlpha())
@@ -163,7 +178,7 @@ CStdString CTextureCacheJob::DecodeImageURL(const CStdString &url, unsigned int
   return image;
 }
 
-CBaseTexture *CTextureCacheJob::LoadImage(const CStdString &image, unsigned int width, unsigned int height, const std::string &additional_info)
+CBaseTexture *CTextureCacheJob::LoadImage(const CStdString &image, unsigned int width, unsigned int height, const std::string &additional_info, bool requirePixels)
 {
   if (additional_info == "music")
   { // special case for embedded music images
@@ -178,7 +193,7 @@ CBaseTexture *CTextureCacheJob::LoadImage(const CStdString &image, unsigned int
       && !file.GetMimeType().Left(6).Equals("image/") && !file.GetMimeType().Equals("application/octet-stream")) // ignore non-pictures
     return NULL;
 
-  CBaseTexture *texture = CBaseTexture::LoadFromFile(image, width, height, g_guiSettings.GetBool("pictures.useexifrotation"));
+  CBaseTexture *texture = CBaseTexture::LoadFromFile(image, width, height, g_guiSettings.GetBool("pictures.useexifrotation"), requirePixels);
   if (!texture)
     return NULL;
 
diff --git a/xbmc/TextureCacheJob.h b/xbmc/TextureCacheJob.h
index c78bda1..c726385 100644
--- a/xbmc/TextureCacheJob.h
+++ b/xbmc/TextureCacheJob.h
@@ -121,7 +121,7 @@ class CTextureCacheJob : public CJob
    \param additional_info extra info for loading, such as whether to flip horizontally.
    \return a pointer to a CBaseTexture object, NULL if failed.
    */
-  static CBaseTexture *LoadImage(const CStdString &image, unsigned int width, unsigned int height, const std::string &additional_info);
+  static CBaseTexture *LoadImage(const CStdString &image, unsigned int width, unsigned int height, const std::string &additional_info, bool requirePixels = false);
 
   CStdString    m_cachePath;
 };
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index cb0939f..f2532d1 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -1003,8 +1003,8 @@ void CLinuxRendererGLES::RenderMultiPass(int index, int field)
   g_matrices.LoadIdentity();
   VerifyGLState();
   g_matrices.Ortho2D(0, m_sourceWidth, 0, m_sourceHeight);
-  glViewport(0, 0, m_sourceWidth, m_sourceHeight);
-  glScissor(0, 0, m_sourceWidth, m_sourceHeight);
+  CRect viewport(0, 0, m_sourceWidth, m_sourceHeight);
+  g_Windowing.SetViewPort(viewport);
   g_matrices.MatrixMode(MM_MODELVIEW);
   VerifyGLState();
 
@@ -1319,6 +1319,14 @@ bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
   if (!m_bValidated)
     return false;
 
+  // If rendered directly by the hardware
+  if (m_renderMethod & RENDER_BYPASS)
+  {
+    capture->BeginRender();
+    capture->EndRender();
+    return true;
+  }
+
   // save current video rect
   CRect saveSize = m_destRect;
   saveRotatedCoords();//backup current m_rotatedDestCoords
diff --git a/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp b/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp
index ecd547d..01551d1 100644
--- a/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp
@@ -56,13 +56,19 @@ static void LoadTexture(GLenum target
                       , GLfloat* u, GLfloat* v
                       , GLenum internalFormat, GLenum externalFormat, const GLvoid* pixels)
 {
-  int width2  = NP2(width);
-  int height2 = NP2(height);
+  int width2  = width;
+  int height2 = height;
   char *pixelVector = NULL;
   const GLvoid *pixelData = pixels;
 
   int bytesPerPixel = glFormatElementByteCount(externalFormat);
 
+  if (!g_Windowing.SupportsNPOT(0))
+  {
+    width2  = NP2(width);
+    height2 = NP2(height);
+  }
+
 #ifdef HAS_GLES
   /** OpenGL ES does not support strided texture input. Make a copy without stride **/
   if (stride != width)
diff --git a/xbmc/cores/VideoRenderers/RenderCapture.cpp b/xbmc/cores/VideoRenderers/RenderCapture.cpp
index 096e953..40356d1 100644
--- a/xbmc/cores/VideoRenderers/RenderCapture.cpp
+++ b/xbmc/cores/VideoRenderers/RenderCapture.cpp
@@ -54,7 +54,43 @@ bool CRenderCaptureBase::UseOcclusionQuery()
     return true;
 }
 
-#if defined(HAS_GL) || defined(HAS_GLES)
+#if defined(TARGET_RASPBERRY_PI)
+
+CRenderCaptureDispmanX::CRenderCaptureDispmanX()
+{
+}
+
+CRenderCaptureDispmanX::~CRenderCaptureDispmanX()
+{
+	delete[] m_pixels;
+}
+
+int CRenderCaptureDispmanX::GetCaptureFormat()
+{
+	return CAPTUREFORMAT_BGRA;
+}
+
+void CRenderCaptureDispmanX::BeginRender()
+{
+}
+
+void CRenderCaptureDispmanX::EndRender()
+{
+	m_pixels = g_RBP.CaptureDisplay(m_width, m_height, NULL, true);
+
+	SetState(CAPTURESTATE_DONE);
+}
+
+void* CRenderCaptureDispmanX::GetRenderBuffer()
+{
+    return m_pixels;
+}
+
+void CRenderCaptureDispmanX::ReadOut()
+{
+}
+
+#elif defined(HAS_GL) || defined(HAS_GLES)
 
 CRenderCaptureGL::CRenderCaptureGL()
 {
diff --git a/xbmc/cores/VideoRenderers/RenderCapture.h b/xbmc/cores/VideoRenderers/RenderCapture.h
index 2a6a6b1..4ac0db0 100644
--- a/xbmc/cores/VideoRenderers/RenderCapture.h
+++ b/xbmc/cores/VideoRenderers/RenderCapture.h
@@ -172,7 +172,33 @@ class CRenderCaptureBase
     bool             m_asyncChecked;
 };
 
-#if defined(HAS_GL) || defined(HAS_GLES)
+#if defined(TARGET_RASPBERRY_PI)
+#include "xbmc/linux/RBP.h"
+
+class CRenderCaptureDispmanX : public CRenderCaptureBase
+{
+  public:
+    CRenderCaptureDispmanX();
+    ~CRenderCaptureDispmanX();
+
+    int   GetCaptureFormat();
+
+    void  BeginRender();
+    void  EndRender();
+    void  ReadOut();
+
+    void* GetRenderBuffer();
+};
+
+//used instead of typedef CRenderCaptureGL CRenderCapture
+//since C++ doesn't allow you to forward declare a typedef
+class CRenderCapture : public CRenderCaptureDispmanX
+{
+  public:
+    CRenderCapture() {};
+};
+
+#elif defined(HAS_GL) || defined(HAS_GLES)
 #include "system_gl.h"
 
 class CRenderCaptureGL : public CRenderCaptureBase
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 0dd0031..7fe6bb2 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -30,18 +30,6 @@
 #include "settings/VideoSettings.h"
 #include "OverlayRenderer.h"
 
-/* PLEX */
-#ifdef TARGET_WINDOWS
-#include "cores/VideoRenderers/WinRenderer.h"
-#else
-#ifdef TARGET_RASPBERRY_PI
-#include "cores/VideoRenderers/LinuxRendererGLES.h"
-#else
-#include "cores/VideoRenderers/LinuxRendererGL.h"
-#endif //raspberry pi
-#endif
-/* END PLEX */
-
 class CRenderCapture;
 
 namespace DXVA { class CProcessor; }
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 322dc79..c3cda88 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -690,7 +690,8 @@ double CDVDDemuxFFmpeg::ConvertTimestamp(int64_t pts, int den, int num)
 
   if(timestamp > starttime)
     timestamp -= starttime;
-  else if( timestamp + 0.1f > starttime )
+  // allow for largest possible difference in pts and dts for a single packet
+  else if( timestamp + 0.5f > starttime )
     timestamp = 0;
 
   return timestamp*DVD_TIME_BASE;
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 7edfc27..443d04d 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -2255,9 +2255,9 @@ void CDVDPlayer::HandleMessages()
         if(!msg.GetTrickPlay())
         {
           g_infoManager.SetDisplayAfterSeek(100000);
-          if(msg.GetFlush())
-            SetCaching(CACHESTATE_FLUSH);
         }
+        if(msg.GetFlush())
+          SetCaching(CACHESTATE_FLUSH);
 
         double start = DVD_NOPTS_VALUE;
 
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 0c9693d..677a9f1 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -39,53 +39,14 @@
 
 using namespace std;
 
-#define OMX_MAX_CHANNELS 10
-
-static enum AEChannel OMXChannelMap[OMX_MAX_CHANNELS] = 
-{
-  AE_CH_FL      , AE_CH_FR, 
-  AE_CH_FC      , AE_CH_LFE, 
-  AE_CH_BL      , AE_CH_BR,
-  AE_CH_SL      , AE_CH_SR,
-  AE_CH_BC      , AE_CH_RAW
-};
-
-static enum OMX_AUDIO_CHANNELTYPE OMXChannels[OMX_MAX_CHANNELS] =
-{
-  OMX_AUDIO_ChannelLF, OMX_AUDIO_ChannelRF,
-  OMX_AUDIO_ChannelCF, OMX_AUDIO_ChannelLFE,
-  OMX_AUDIO_ChannelLR, OMX_AUDIO_ChannelRR,
-  OMX_AUDIO_ChannelLS, OMX_AUDIO_ChannelRS,
-  OMX_AUDIO_ChannelCS, OMX_AUDIO_ChannelNone
-};
-
-static unsigned int WAVEChannels[OMX_MAX_CHANNELS] =
-{
-  SPEAKER_FRONT_LEFT,       SPEAKER_FRONT_RIGHT,
-  SPEAKER_TOP_FRONT_CENTER, SPEAKER_LOW_FREQUENCY,
-  SPEAKER_BACK_LEFT,        SPEAKER_BACK_RIGHT,
-  SPEAKER_SIDE_LEFT,        SPEAKER_SIDE_RIGHT,
-  SPEAKER_BACK_CENTER,      SPEAKER_SIDE_RIGHT
-};
+// the size of the audio_render output port buffers
+#define AUDIO_DECODE_OUTPUT_BUFFER (32*1024)
 
 static const uint16_t AC3Bitrates[] = {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448, 512, 576, 640};
 static const uint16_t AC3FSCod   [] = {48000, 44100, 32000, 0};
 
 static const uint16_t DTSFSCod   [] = {0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0, 12000, 24000, 48000, 0, 0};
 
-// 7.1 downmixing coefficients
-const float downmixing_coefficients_8[OMX_AUDIO_MAXCHANNELS] = {
-  //        L       R
-  /* L */   1,      0,
-  /* R */   0,      1,
-  /* C */   0.7071, 0.7071,
-  /* LFE */ 0.7071, 0.7071,
-  /* Ls */  0.7071, 0,
-  /* Rs */  0,      0.7071,
-  /* Lr */  0.7071, 0,
-  /* Rr */  0,      0.7071
-};
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -93,26 +54,33 @@ const float downmixing_coefficients_8[OMX_AUDIO_MAXCHANNELS] = {
 COMXAudio::COMXAudio() :
   m_pCallback       (NULL   ),
   m_Initialized     (false  ),
-  m_Pause           (false  ),
-  m_CanPause        (false  ),
   m_CurrentVolume   (0      ),
+  m_Mute            (false  ),
+  m_drc             (0      ),
   m_Passthrough     (false  ),
   m_HWDecode        (false  ),
   m_BytesPerSec     (0      ),
   m_BufferLen       (0      ),
   m_ChunkLen        (0      ),
+  m_InputChannels   (0      ),
   m_OutputChannels  (0      ),
   m_BitsPerSample   (0      ),
+  m_maxLevel        (0.0f   ),
+  m_amplification   (1.0f   ),
+  m_attenuation     (1.0f   ),
+  m_submitted       (0.0f   ),
   m_omx_clock       (NULL   ),
   m_av_clock        (NULL   ),
-  m_first_frame     (true   ),
+  m_settings_changed(false  ),
+  m_setStartTime    (false  ),
   m_LostSync        (true   ),
   m_SampleRate      (0      ),
   m_eEncoding       (OMX_AUDIO_CodingPCM),
   m_extradata       (NULL   ),
   m_extrasize       (0      ),
   m_last_pts        (DVD_NOPTS_VALUE),
-  m_omx_render      (NULL   )
+  m_submitted_eos   (false  ),
+  m_failed_eos      (false  )
 {
   m_vizBufferSize   = m_vizRemapBufferSize = VIS_PACKET_SIZE * sizeof(float);
   m_vizRemapBuffer  = (uint8_t *)_aligned_malloc(m_vizRemapBufferSize,16);
@@ -127,42 +95,323 @@ COMXAudio::~COMXAudio()
   _aligned_free(m_vizBuffer);
 }
 
-
-CAEChannelInfo COMXAudio::GetChannelLayout(AEAudioFormat format)
+bool COMXAudio::PortSettingsChanged()
 {
-  unsigned int count = 0;
-
-  if(format.m_dataFormat == AE_FMT_AC3 ||
-    format.m_dataFormat == AE_FMT_DTS ||
-    format.m_dataFormat == AE_FMT_EAC3)
-    count = 2;
-  else if (format.m_dataFormat == AE_FMT_TRUEHD ||
-    format.m_dataFormat == AE_FMT_DTSHD)
-    count = 8;
-  else
+  CSingleLock lock (m_critSection);
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  if (m_settings_changed)
+  {
+    m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
+    m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
+    return true;
+  }
+
+  if(!m_Passthrough)
+  {
+    if(!m_omx_mixer.Initialize("OMX.broadcom.audio_mixer", OMX_IndexParamAudioInit))
+      return false;
+  }
+  if(g_guiSettings.GetBool("audiooutput.dualaudio"))
+  {
+    if(!m_omx_splitter.Initialize("OMX.broadcom.audio_splitter", OMX_IndexParamAudioInit))
+      return false;
+  }
+  if (g_guiSettings.GetBool("audiooutput.dualaudio") || g_guiSettings.GetInt("audiooutput.mode") == AUDIO_ANALOG)
+  {
+    if(!m_omx_render_analog.Initialize("OMX.broadcom.audio_render", OMX_IndexParamAudioInit))
+      return false;
+  }
+  if (g_guiSettings.GetBool("audiooutput.dualaudio") || g_guiSettings.GetInt("audiooutput.mode") == AUDIO_HDMI)
   {
-    for (unsigned int c = 0; c < 8; ++c)
+    if(!m_omx_render_hdmi.Initialize("OMX.broadcom.audio_render", OMX_IndexParamAudioInit))
+      return false;
+  }
+
+  SetDynamicRangeCompression((long)(g_settings.m_currentVideoSettings.m_VolumeAmplification * 100));
+  UpdateAttenuation();
+
+  if( m_omx_mixer.IsInitialized() )
+  {
+    /* setup mixer output */
+    OMX_INIT_STRUCTURE(m_pcm_output);
+    m_pcm_output.nPortIndex = m_omx_decoder.GetOutputPort();
+    omx_err = m_omx_decoder.GetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder GetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    memcpy(m_pcm_output.eChannelMapping, m_output_channels, sizeof(m_output_channels));
+    // round up to power of 2
+    m_pcm_output.nChannels = m_OutputChannels > 4 ? 8 : m_OutputChannels > 2 ? 4 : m_OutputChannels;
+    /* limit samplerate (through resampling) if requested */
+    m_pcm_output.nSamplingRate = std::min(std::max((int)m_pcm_output.nSamplingRate, 8000), 192000);
+
+    m_pcm_output.nPortIndex = m_omx_mixer.GetOutputPort();
+    omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error m_omx_mixer SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    CLog::Log(LOGDEBUG, "%s::%s - Output bps %d samplerate %d channels %d buffer size %d bytes per second %d",
+        CLASSNAME, __func__, (int)m_pcm_output.nBitPerSample, (int)m_pcm_output.nSamplingRate, (int)m_pcm_output.nChannels, m_BufferLen, m_BytesPerSec);
+    PrintPCM(&m_pcm_output, std::string("output"));
+
+    if( m_omx_splitter.IsInitialized() )
+    {
+      m_pcm_output.nPortIndex = m_omx_splitter.GetInputPort();
+      omx_err = m_omx_splitter.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_splitter SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+
+      m_pcm_output.nPortIndex = m_omx_splitter.GetOutputPort();
+      omx_err = m_omx_splitter.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_splitter SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      m_pcm_output.nPortIndex = m_omx_splitter.GetOutputPort() + 1;
+      omx_err = m_omx_splitter.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_splitter SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
+
+    if( m_omx_render_analog.IsInitialized() )
     {
-      for (unsigned int i = 0; i < format.m_channelLayout.Count(); ++i)
+      m_pcm_output.nPortIndex = m_omx_render_analog.GetInputPort();
+      omx_err = m_omx_render_analog.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
       {
-        if (format.m_channelLayout[i] == OMXChannelMap[c])
-        {
-          count = c + 1;
-          break;
-        }
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_render_analog SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
+
+    if( m_omx_render_hdmi.IsInitialized() )
+    {
+      m_pcm_output.nPortIndex = m_omx_render_hdmi.GetInputPort();
+      omx_err = m_omx_render_hdmi.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_render_hdmi SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
       }
     }
   }
+  if( m_omx_render_analog.IsInitialized() )
+  {
+    m_omx_tunnel_clock_analog.Initialize(m_omx_clock, m_omx_clock->GetInputPort(),
+      &m_omx_render_analog, m_omx_render_analog.GetInputPort()+1);
+
+    omx_err = m_omx_tunnel_clock_analog.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_clock_analog.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    m_omx_render_analog.ResetEos();
+  }
+  if( m_omx_render_hdmi.IsInitialized() )
+  {
+    m_omx_tunnel_clock_hdmi.Initialize(m_omx_clock, m_omx_clock->GetInputPort() + (m_omx_render_analog.IsInitialized() ? 2 : 0),
+      &m_omx_render_hdmi, m_omx_render_hdmi.GetInputPort()+1);
+
+    omx_err = m_omx_tunnel_clock_hdmi.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_clock_hdmi.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    m_omx_render_hdmi.ResetEos();
+  }
+
+  if( m_omx_render_analog.IsInitialized() )
+  {
+    // By default audio_render is the clock master, and if output samples don't fit the timestamps, it will speed up/slow down the clock.
+    // This tends to be better for maintaining audio sync and avoiding audio glitches, but can affect video/display sync
+    if(g_guiSettings.GetBool("videoplayer.usedisplayasclock"))
+    {
+      OMX_CONFIG_BOOLEANTYPE configBool;
+      OMX_INIT_STRUCTURE(configBool);
+      configBool.bEnabled = OMX_FALSE;
+
+      omx_err = m_omx_render_analog.SetConfig(OMX_IndexConfigBrcmClockReferenceSource, &configBool);
+      if (omx_err != OMX_ErrorNone)
+         return false;
+    }
+
+    OMX_CONFIG_BRCMAUDIODESTINATIONTYPE audioDest;
+    OMX_INIT_STRUCTURE(audioDest);
+    strncpy((char *)audioDest.sName, "local", strlen("local"));
+    omx_err = m_omx_render_analog.SetConfig(OMX_IndexConfigBrcmAudioDestination, &audioDest);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_render_analog.SetConfig omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if( m_omx_render_hdmi.IsInitialized() )
+  {
+    // By default audio_render is the clock master, and if output samples don't fit the timestamps, it will speed up/slow down the clock.
+    // This tends to be better for maintaining audio sync and avoiding audio glitches, but can affect video/display sync
+    if(g_guiSettings.GetBool("videoplayer.usedisplayasclock"))
+    {
+      OMX_CONFIG_BOOLEANTYPE configBool;
+      OMX_INIT_STRUCTURE(configBool);
+      configBool.bEnabled = OMX_FALSE;
+
+      omx_err = m_omx_render_hdmi.SetConfig(OMX_IndexConfigBrcmClockReferenceSource, &configBool);
+      if (omx_err != OMX_ErrorNone)
+         return false;
+    }
 
-  CAEChannelInfo info;
-  for (unsigned int i = 0; i < count; ++i)
-    info += OMXChannelMap[i];
+    OMX_CONFIG_BRCMAUDIODESTINATIONTYPE audioDest;
+    OMX_INIT_STRUCTURE(audioDest);
+    strncpy((char *)audioDest.sName, "hdmi", strlen("hdmi"));
+    omx_err = m_omx_render_hdmi.SetConfig(OMX_IndexConfigBrcmAudioDestination, &audioDest);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_render_hdmi.SetConfig omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
 
-  return info;
+  if( m_omx_splitter.IsInitialized() )
+  {
+    m_omx_tunnel_splitter_analog.Initialize(&m_omx_splitter, m_omx_splitter.GetOutputPort(), &m_omx_render_analog, m_omx_render_analog.GetInputPort());
+    omx_err = m_omx_tunnel_splitter_analog.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_splitter_analog.Establish 0x%08x", omx_err);
+      return false;
+    }
+
+    m_omx_tunnel_splitter_hdmi.Initialize(&m_omx_splitter, m_omx_splitter.GetOutputPort() + 1, &m_omx_render_hdmi, m_omx_render_hdmi.GetInputPort());
+    omx_err = m_omx_tunnel_splitter_hdmi.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_splitter_hdmi.Establish 0x%08x", omx_err);
+      return false;
+    }
+  }
+  if( m_omx_mixer.IsInitialized() )
+  {
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_mixer, m_omx_mixer.GetInputPort());
+    if( m_omx_splitter.IsInitialized() )
+    {
+      m_omx_tunnel_mixer.Initialize(&m_omx_mixer, m_omx_mixer.GetOutputPort(), &m_omx_splitter, m_omx_splitter.GetInputPort());
+    }
+    else
+    {
+      if( m_omx_render_analog.IsInitialized() )
+      {
+        m_omx_tunnel_mixer.Initialize(&m_omx_mixer, m_omx_mixer.GetOutputPort(), &m_omx_render_analog, m_omx_render_analog.GetInputPort());
+      }
+      if( m_omx_render_hdmi.IsInitialized() )
+      {
+        m_omx_tunnel_mixer.Initialize(&m_omx_mixer, m_omx_mixer.GetOutputPort(), &m_omx_render_hdmi, m_omx_render_hdmi.GetInputPort());
+      }
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - bits:%d mode:%d channels:%d srate:%d nopassthrough", CLASSNAME, __func__,
+            (int)m_pcm_input.nBitPerSample, m_pcm_input.ePCMMode, (int)m_pcm_input.nChannels, (int)m_pcm_input.nSamplingRate);
+  }
+  else
+  {
+    if( m_omx_render_analog.IsInitialized() )
+    {
+      m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_render_analog, m_omx_render_analog.GetInputPort());
+    }
+    else if( m_omx_render_hdmi.IsInitialized() )
+    {
+      m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_render_hdmi, m_omx_render_hdmi.GetInputPort());
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - bits:%d mode:%d channels:%d srate:%d passthrough", CLASSNAME, __func__,
+            0, 0, 0, 0);
+  }
+
+  omx_err = m_omx_tunnel_decoder.Establish();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_decoder.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if( m_omx_mixer.IsInitialized() )
+  {
+    omx_err = m_omx_mixer.SetStateForComponent(OMX_StateExecuting);
+    if(omx_err != OMX_ErrorNone) {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_mixer OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if( m_omx_mixer.IsInitialized() )
+  {
+    omx_err = m_omx_tunnel_mixer.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_decoder.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if( m_omx_splitter.IsInitialized() )
+  {
+    omx_err = m_omx_splitter.SetStateForComponent(OMX_StateExecuting);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_splitter OMX_StateExecuting 0x%08x", CLASSNAME, __func__, omx_err);
+     return false;
+    }
+  }
+  if( m_omx_render_analog.IsInitialized() )
+  {
+    omx_err = m_omx_render_analog.SetStateForComponent(OMX_StateExecuting);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_render_analog OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+  if( m_omx_render_hdmi.IsInitialized() )
+  {
+    omx_err = m_omx_render_hdmi.SetStateForComponent(OMX_StateExecuting);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_render_hdmi OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  m_settings_changed = true;
+  return true;
+}
+
+static unsigned count_bits(int64_t value)
+{
+  unsigned bits = 0;
+  for(;value;++bits)
+    value &= value - 1;
+  return bits;
 }
 
-bool COMXAudio::Initialize(AEAudioFormat format, std::string& device, OMXClock *clock, CDVDStreamInfo &hints, bool bUsePassthrough, bool bUseHWDecode)
+bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo &hints, uint64_t channelMap, bool bUsePassthrough, bool bUseHWDecode)
 {
+  CSingleLock lock (m_critSection);
+  OMX_ERRORTYPE omx_err;
+
   Deinitialize();
 
   if(!m_dllAvUtil.Load())
@@ -171,9 +420,10 @@ bool COMXAudio::Initialize(AEAudioFormat format, std::string& device, OMXClock *
   m_HWDecode    = bUseHWDecode;
   m_Passthrough = bUsePassthrough;
 
+  m_InputChannels = count_bits(channelMap);
   m_format = format;
 
-  if(m_format.m_channelLayout.Count() == 0)
+  if(m_InputChannels == 0)
     return false;
 
   if(hints.samplerate == 0)
@@ -211,155 +461,69 @@ bool COMXAudio::Initialize(AEAudioFormat format, std::string& device, OMXClock *
   memset(m_output_channels, 0x0, sizeof(m_output_channels));
   memset(&m_wave_header, 0x0, sizeof(m_wave_header));
 
-  for(int i = 0; i < OMX_AUDIO_MAXCHANNELS; i++)
-    m_pcm_input.eChannelMapping[i] = OMX_AUDIO_ChannelNone;
-
-  m_output_channels[0] = OMX_AUDIO_ChannelLF;
-  m_output_channels[1] = OMX_AUDIO_ChannelRF;
-  m_output_channels[2] = OMX_AUDIO_ChannelMax;
-
-  m_input_channels[0] = OMX_AUDIO_ChannelLF;
-  m_input_channels[1] = OMX_AUDIO_ChannelRF;
-  m_input_channels[2] = OMX_AUDIO_ChannelMax;
-
-  m_OutputChannels                = 2;
-  m_wave_header.Format.nChannels  = m_OutputChannels;
+  m_wave_header.Format.nChannels  = 2;
   m_wave_header.dwChannelMask     = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
 
   if (!m_Passthrough)
   {
-    /* setup output channel map */
-    /*
-    int ch = 0, map;
-    int chan = 0;
-    m_OutputChannels = 0;
-
-    for (unsigned int ch = 0; ch < m_format.m_channelLayout.Count(); ++ch)
-    {
-      for(map = 0; map < OMX_MAX_CHANNELS; ++map)
-      {
-        if (m_output_channels[ch] == OMXChannelMap[map])
-        {
-          printf("output %d\n", chan);
-          m_output_channels[chan] = OMXChannels[map]; 
-          chan++;
-          break;
-        }
-      }
-    }
-
-    m_OutputChannels = chan;
-    */
-
-    /* setup input channel map */
-    int map = 0;
-    int chan = 0;
-
-    for (unsigned int ch = 0; ch < m_format.m_channelLayout.Count(); ++ch)
-    {
-      for(map = 0; map < OMX_MAX_CHANNELS; ++map)
-      {
-        if (m_format.m_channelLayout[ch] == OMXChannelMap[map])
-        {
-          m_input_channels[chan] = OMXChannels[map]; 
-          m_wave_header.dwChannelMask |= WAVEChannels[map];
-          chan++;
-          break;
-        }
-      }
-    }
-
-    m_vizRemap.Initialize(m_format.m_channelLayout, CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true);
+    enum PCMChannels inLayout[OMX_AUDIO_MAXCHANNELS];
+    enum PCMChannels outLayout[OMX_AUDIO_MAXCHANNELS];
+    enum PCMLayout layout = (enum PCMLayout)std::max(0, g_guiSettings.GetInt("audiooutput.channels")-1);
+
+    // ignore layout setting for analogue
+    if (g_guiSettings.GetBool("audiooutput.dualaudio") || g_guiSettings.GetInt("audiooutput.mode") == AUDIO_ANALOG)
+      layout = PCM_LAYOUT_2_0;
+
+    // force out layout to stereo if input is not multichannel - it gives the receiver a chance to upmix
+    if (channelMap == (AV_CH_FRONT_LEFT | AV_CH_FRONT_RIGHT) || channelMap == AV_CH_FRONT_CENTER)
+      layout = PCM_LAYOUT_2_0;
+    BuildChannelMap(inLayout, channelMap);
+    m_OutputChannels = BuildChannelMapCEA(outLayout, GetChannelLayout(layout));
+    CPCMRemap m_remap;
+    m_remap.Reset();
+    /*outLayout = */m_remap.SetInputFormat (m_InputChannels, inLayout, CAEUtil::DataFormatToBits(m_format.m_dataFormat) / 8, m_format.m_sampleRate, layout);
+    m_remap.SetOutputFormat(m_OutputChannels, outLayout);
+    m_remap.GetDownmixMatrix(m_downmix_matrix);
+    m_wave_header.dwChannelMask = channelMap;
+    BuildChannelMapOMX(m_input_channels, channelMap);
+    BuildChannelMapOMX(m_output_channels, GetChannelLayout(layout));
+
+    m_vizRemap.Initialize(GetAEChannelLayout(channelMap), CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true);
   }
 
-  OMX_INIT_STRUCTURE(m_pcm_output);
-  OMX_INIT_STRUCTURE(m_pcm_input);
-
-  memcpy(m_pcm_output.eChannelMapping, m_output_channels, sizeof(m_output_channels));
-  memcpy(m_pcm_input.eChannelMapping, m_input_channels, sizeof(m_input_channels));
-
-  // set the m_pcm_output parameters
-  m_pcm_output.eNumData            = OMX_NumericalDataSigned;
-  m_pcm_output.eEndian             = OMX_EndianLittle;
-  m_pcm_output.bInterleaved        = OMX_TRUE;
-  m_pcm_output.nBitPerSample       = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
-  m_pcm_output.ePCMMode            = OMX_AUDIO_PCMModeLinear;
-  m_pcm_output.nChannels           = m_OutputChannels;
-  m_pcm_output.nSamplingRate       = m_format.m_sampleRate;
-
   m_SampleRate    = m_format.m_sampleRate;
   m_BitsPerSample = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
-  m_BufferLen     = m_BytesPerSec = m_format.m_sampleRate * 
-    (CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3) * 
-    m_format.m_channelLayout.Count();
+  m_BufferLen     = m_BytesPerSec = m_format.m_sampleRate * (16 >> 3) * m_InputChannels;
   m_BufferLen     *= AUDIO_BUFFER_SECONDS;
-  m_ChunkLen      = 6144;
+  // the audio_decode output buffer size is 32K, and typically we convert from
+  // 6 channel 32bpp float to 8 channel 16bpp in, so a full 48K input buffer will fit the outbut buffer
+  m_ChunkLen      = AUDIO_DECODE_OUTPUT_BUFFER * 2 * 6 / 8;
 
   m_wave_header.Samples.wSamplesPerBlock    = 0;
-  m_wave_header.Format.nChannels            = m_format.m_channelLayout.Count();
-  m_wave_header.Format.nBlockAlign          = m_format.m_channelLayout.Count() * 
-    (CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3);
-  m_wave_header.Format.wFormatTag           = WAVE_FORMAT_PCM;
+  m_wave_header.Format.nChannels            = m_InputChannels;
+  m_wave_header.Format.nBlockAlign          = m_InputChannels * (m_BitsPerSample >> 3);
+  // 0x8000 is custom format interpreted by GPU as WAVE_FORMAT_IEEE_FLOAT_PLANAR
+  m_wave_header.Format.wFormatTag           = m_BitsPerSample == 32 ? 0x8000 : WAVE_FORMAT_PCM;
   m_wave_header.Format.nSamplesPerSec       = m_format.m_sampleRate;
   m_wave_header.Format.nAvgBytesPerSec      = m_BytesPerSec;
-  m_wave_header.Format.wBitsPerSample       = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
-  m_wave_header.Samples.wValidBitsPerSample = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
+  m_wave_header.Format.wBitsPerSample       = m_BitsPerSample;
+  m_wave_header.Samples.wValidBitsPerSample = m_BitsPerSample;
   m_wave_header.Format.cbSize               = 0;
   m_wave_header.SubFormat                   = KSDATAFORMAT_SUBTYPE_PCM;
 
+  OMX_INIT_STRUCTURE(m_pcm_input);
+  memcpy(m_pcm_input.eChannelMapping, m_input_channels, sizeof(m_input_channels));
   m_pcm_input.eNumData              = OMX_NumericalDataSigned;
   m_pcm_input.eEndian               = OMX_EndianLittle;
   m_pcm_input.bInterleaved          = OMX_TRUE;
-  m_pcm_input.nBitPerSample         = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
+  m_pcm_input.nBitPerSample         = m_BitsPerSample;
   m_pcm_input.ePCMMode              = OMX_AUDIO_PCMModeLinear;
-  m_pcm_input.nChannels             = m_format.m_channelLayout.Count();
+  m_pcm_input.nChannels             = m_InputChannels;
   m_pcm_input.nSamplingRate         = m_format.m_sampleRate;
 
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  std::string componentName = "";
-
-  componentName = "OMX.broadcom.audio_render";
-
-  if(!m_omx_render)
-    m_omx_render = new COMXCoreComponent();
-  if(!m_omx_render)
-  {
-    CLog::Log(LOGERROR, "COMXAudio::Initialize error allocate OMX.broadcom.audio_render\n");
-    return false;
-  }
-
-  if(!m_omx_render->Initialize((const std::string)componentName, OMX_IndexParamAudioInit))
+  if(!m_omx_decoder.Initialize("OMX.broadcom.audio_decode", OMX_IndexParamAudioInit))
     return false;
 
-  m_omx_render->ResetEos();
-
-  OMX_CONFIG_BRCMAUDIODESTINATIONTYPE audioDest;
-  OMX_INIT_STRUCTURE(audioDest);
-  strncpy((char *)audioDest.sName, device.c_str(), strlen(device.c_str()));
-
-  omx_err = m_omx_render->SetConfig(OMX_IndexConfigBrcmAudioDestination, &audioDest);
-  if (omx_err != OMX_ErrorNone)
-    return false;
-
-  OMX_CONFIG_BOOLEANTYPE configBool;
-  OMX_INIT_STRUCTURE(configBool);
-  configBool.bEnabled = OMX_FALSE;
-
-  omx_err = m_omx_render->SetConfig(OMX_IndexConfigBrcmClockReferenceSource, &configBool);
-  if (omx_err != OMX_ErrorNone)
-    return false;
-
-  componentName = "OMX.broadcom.audio_decode";
-  if(!m_omx_decoder.Initialize((const std::string)componentName, OMX_IndexParamAudioInit))
-    return false;
-
-  if(!m_Passthrough)
-  {
-    componentName = "OMX.broadcom.audio_mixer";
-    if(!m_omx_mixer.Initialize((const std::string)componentName, OMX_IndexParamAudioInit))
-      return false;
-  }
-
   OMX_CONFIG_BOOLEANTYPE boolType;
   OMX_INIT_STRUCTURE(boolType);
   if(m_Passthrough)
@@ -373,7 +537,7 @@ bool COMXAudio::Initialize(AEAudioFormat format, std::string& device, OMXClock *
     return false;
   }
 
-  // set up the number/size of buffers
+  // set up the number/size of buffers for decoder input
   OMX_PARAM_PORTDEFINITIONTYPE port_param;
   OMX_INIT_STRUCTURE(port_param);
   port_param.nPortIndex = m_omx_decoder.GetInputPort();
@@ -381,23 +545,42 @@ bool COMXAudio::Initialize(AEAudioFormat format, std::string& device, OMXClock *
   omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_param);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "COMXAudio::Initialize error get OMX_IndexParamPortDefinition omx_err(0x%08x)\n", omx_err);
+    CLog::Log(LOGERROR, "COMXAudio::Initialize error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)\n", omx_err);
     return false;
   }
 
   port_param.format.audio.eEncoding = m_eEncoding;
 
   port_param.nBufferSize = m_ChunkLen;
-  port_param.nBufferCountActual = m_BufferLen / m_ChunkLen;
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, 16U);
 
   omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_param);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "COMXAudio::Initialize error set OMX_IndexParamPortDefinition omx_err(0x%08x)\n", omx_err);
+    CLog::Log(LOGERROR, "COMXAudio::Initialize error set OMX_IndexParamPortDefinition (intput) omx_err(0x%08x)\n", omx_err);
+    return false;
+  }
+
+  // set up the number/size of buffers for decoder output
+  OMX_INIT_STRUCTURE(port_param);
+  port_param.nPortIndex = m_omx_decoder.GetOutputPort();
+
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXAudio::Initialize error get OMX_IndexParamPortDefinition (output) omx_err(0x%08x)\n", omx_err);
+    return false;
+  }
+
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, m_BufferLen / port_param.nBufferSize);
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXAudio::Initialize error set OMX_IndexParamPortDefinition (output) omx_err(0x%08x)\n", omx_err);
     return false;
   }
 
-  //if(m_HWDecode)
   {
     OMX_AUDIO_PARAM_PORTFORMATTYPE formatType;
     OMX_INIT_STRUCTURE(formatType);
@@ -413,15 +596,6 @@ bool COMXAudio::Initialize(AEAudioFormat format, std::string& device, OMXClock *
     }
   }
 
-  m_omx_tunnel_clock.Initialize(m_omx_clock, m_omx_clock->GetInputPort(), m_omx_render, m_omx_render->GetInputPort()+1);
-
-  omx_err = m_omx_tunnel_clock.Establish(false);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXAudio::Initialize m_omx_tunnel_clock.Establish\n");
-    return false;
-  }
-
   omx_err = m_omx_decoder.AllocInputBuffers();
   if(omx_err != OMX_ErrorNone) 
   {
@@ -429,61 +603,12 @@ bool COMXAudio::Initialize(AEAudioFormat format, std::string& device, OMXClock *
     return false;
   }
 
-  if(!m_Passthrough)
-  {
-    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_mixer, m_omx_mixer.GetInputPort());
-    omx_err = m_omx_tunnel_decoder.Establish(false);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_decoder.Establish 0x%08x", omx_err);
-      return false;
-    }
-  
-    omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
-    if(omx_err != OMX_ErrorNone) {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error setting OMX_StateExecuting 0x%08x", omx_err);
-      return false;
-    }
-
-    m_omx_tunnel_mixer.Initialize(&m_omx_mixer, m_omx_mixer.GetOutputPort(), m_omx_render, m_omx_render->GetInputPort());
-    omx_err = m_omx_tunnel_mixer.Establish(false);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_decoder.Establish 0x%08x", omx_err);
-      return false;
-    }
-  
-    omx_err = m_omx_mixer.SetStateForComponent(OMX_StateExecuting);
-    if(omx_err != OMX_ErrorNone) {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error setting OMX_StateExecuting 0x%08x", omx_err);
-      return false;
-    }
-  }
-  else
-  {
-    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), m_omx_render, m_omx_render->GetInputPort());
-    omx_err = m_omx_tunnel_decoder.Establish(false);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_decoder.Establish 0x%08x", omx_err);
-      return false;
-    }
-  
-    omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
-    if(omx_err != OMX_ErrorNone) {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error setting OMX_StateExecuting 0x%08x", omx_err);
-      return false;
-    }
-  }
-
-  omx_err = m_omx_render->SetStateForComponent(OMX_StateExecuting);
-  if(omx_err != OMX_ErrorNone) 
-  {
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
+  if(omx_err != OMX_ErrorNone) {
     CLog::Log(LOGERROR, "COMXAudio::Initialize - Error setting OMX_StateExecuting 0x%08x", omx_err);
     return false;
   }
 
-  m_omx_decoder.EnablePort(m_omx_decoder.GetInputPort(), true);
 
   if(m_eEncoding == OMX_AUDIO_CodingPCM)
   {
@@ -551,15 +676,19 @@ bool COMXAudio::Initialize(AEAudioFormat format, std::string& device, OMXClock *
     return false;
 
   m_Initialized   = true;
-  m_first_frame   = true;
+  m_settings_changed = false;
+  m_setStartTime = true;
+  m_submitted_eos = false;
+  m_failed_eos = false;
   m_last_pts      = DVD_NOPTS_VALUE;
+  m_submitted     = 0.0f;
+  m_maxLevel      = 0.0f;
 
-  CLog::Log(LOGDEBUG, "COMXAudio::Initialize Ouput bps %d samplerate %d channels %d buffer size %d bytes per second %d", 
-      (int)m_pcm_output.nBitPerSample, (int)m_pcm_output.nSamplingRate, (int)m_pcm_output.nChannels, m_BufferLen, m_BytesPerSec);
-  CLog::Log(LOGDEBUG, "COMXAudio::Initialize Input bps %d samplerate %d channels %d buffer size %d bytes per second %d", 
+  CLog::Log(LOGDEBUG, "COMXAudio::Initialize Input bps %d samplerate %d channels %d buffer size %d bytes per second %d",
       (int)m_pcm_input.nBitPerSample, (int)m_pcm_input.nSamplingRate, (int)m_pcm_input.nChannels, m_BufferLen, m_BytesPerSec);
-  CLog::Log(LOGDEBUG, "COMXAudio::Initialize device %s passthrough %d hwdecode %d", 
-      device.c_str(), m_Passthrough, m_HWDecode);
+  PrintPCM(&m_pcm_input, std::string("input"));
+  CLog::Log(LOGDEBUG, "COMXAudio::Initialize device passthrough %d hwdecode %d",
+     m_Passthrough, m_HWDecode);
 
   return true;
 }
@@ -569,31 +698,41 @@ bool COMXAudio::Deinitialize()
 {
   CSingleLock lock (m_critSection);
 
-  m_omx_tunnel_decoder.Flush();
-  if(!m_Passthrough)
-    m_omx_tunnel_mixer.Flush();
-  m_omx_tunnel_clock.Flush();
+  if ( m_omx_tunnel_clock_analog.IsInitialized() )
+    m_omx_tunnel_clock_analog.Deestablish();
+  if ( m_omx_tunnel_clock_hdmi.IsInitialized() )
+    m_omx_tunnel_clock_hdmi.Deestablish();
 
-  m_omx_tunnel_clock.Deestablish();
-  if(!m_Passthrough)
+  // ignore expected errors on teardown
+  if ( m_omx_mixer.IsInitialized() )
+    m_omx_mixer.IgnoreNextError(OMX_ErrorPortUnpopulated);
+  else
   {
-    // workaround for the strange BCM mixer component
-    if(m_omx_mixer.GetState() == OMX_StateExecuting)
-      m_omx_mixer.SetStateForComponent(OMX_StatePause);
-    if(m_omx_mixer.GetState() != OMX_StateIdle)
-      m_omx_mixer.SetStateForComponent(OMX_StateIdle);
-    m_omx_mixer.DisableAllPorts();
-    m_omx_tunnel_mixer.Deestablish(true);
+    if ( m_omx_render_hdmi.IsInitialized() )
+      m_omx_render_hdmi.IgnoreNextError(OMX_ErrorPortUnpopulated);
+    if ( m_omx_render_analog.IsInitialized() )
+      m_omx_render_analog.IgnoreNextError(OMX_ErrorPortUnpopulated);
   }
+
   m_omx_tunnel_decoder.Deestablish();
+  if ( m_omx_tunnel_mixer.IsInitialized() )
+    m_omx_tunnel_mixer.Deestablish();
+  if ( m_omx_tunnel_splitter_hdmi.IsInitialized() )
+    m_omx_tunnel_splitter_hdmi.Deestablish();
+  if ( m_omx_tunnel_splitter_analog.IsInitialized() )
+    m_omx_tunnel_splitter_analog.Deestablish();
 
   m_omx_decoder.FlushInput();
 
-  if(m_omx_render)
-    m_omx_render->Deinitialize(true);
-  if(!m_Passthrough)
-    m_omx_mixer.Deinitialize(true);
-  m_omx_decoder.Deinitialize(true);
+  m_omx_decoder.Deinitialize();
+  if ( m_omx_mixer.IsInitialized() )
+    m_omx_mixer.Deinitialize();
+  if ( m_omx_splitter.IsInitialized() )
+    m_omx_splitter.Deinitialize();
+  if ( m_omx_render_hdmi.IsInitialized() )
+    m_omx_render_hdmi.Deinitialize();
+  if ( m_omx_render_analog.IsInitialized() )
+    m_omx_render_analog.Deinitialize();
 
   m_BytesPerSec = 0;
   m_BufferLen   = 0;
@@ -610,168 +749,178 @@ bool COMXAudio::Deinitialize()
   m_extradata = NULL;
   m_extrasize = 0;
 
+  while(!m_vizqueue.empty())
+    m_vizqueue.pop();
+
   m_dllAvUtil.Unload();
 
-  m_first_frame   = true;
-  m_last_pts      = DVD_NOPTS_VALUE;
+  while(!m_ampqueue.empty())
+    m_ampqueue.pop_front();
 
-  delete m_omx_render;
-  m_omx_render = NULL;
+  m_last_pts      = DVD_NOPTS_VALUE;
+  m_submitted     = 0.0f;
+  m_maxLevel      = 0.0f;
 
   return true;
 }
 
 void COMXAudio::Flush()
 {
+  CSingleLock lock (m_critSection);
   if(!m_Initialized)
     return;
 
-  m_omx_decoder.FlushInput();
-  m_omx_tunnel_decoder.Flush();
-  if(!m_Passthrough)
-    m_omx_tunnel_mixer.Flush();
-  
-  m_last_pts      = DVD_NOPTS_VALUE;
-  m_LostSync      = true;
-  //m_first_frame   = true;
-}
+  m_omx_decoder.FlushAll();
 
-//***********************************************************************************************
-bool COMXAudio::Pause()
-{
-  if (!m_Initialized)
-     return -1;
-
-  if(m_Pause) return true;
-  m_Pause = true;
+  if ( m_omx_mixer.IsInitialized() )
+    m_omx_mixer.FlushAll();
 
-  m_omx_decoder.SetStateForComponent(OMX_StatePause);
+  if ( m_omx_splitter.IsInitialized() )
+    m_omx_splitter.FlushAll();
 
-  return true;
-}
-
-//***********************************************************************************************
-bool COMXAudio::Resume()
-{
-  if (!m_Initialized)
-     return -1;
+  if ( m_omx_render_analog.IsInitialized() )
+    m_omx_render_analog.FlushAll();
+  if ( m_omx_render_hdmi.IsInitialized() )
+    m_omx_render_hdmi.FlushAll();
 
-  if(!m_Pause) return true;
-  m_Pause = false;
-
-  m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
-
-  return true;
+  m_last_pts      = DVD_NOPTS_VALUE;
+  m_submitted     = 0.0f;
+  m_maxLevel      = 0.0f;
+  m_LostSync      = true;
+  m_setStartTime  = true;
 }
 
 //***********************************************************************************************
-bool COMXAudio::Stop()
+void COMXAudio::SetDynamicRangeCompression(long drc)
 {
-  if (!m_Initialized)
-     return -1;
-
-  Flush();
-
-  m_Pause = false;
-
-  return true;
+  CSingleLock lock (m_critSection);
+  m_amplification = powf(10.0f, (float)drc / 2000.0f);
+  if (m_settings_changed)
+    UpdateAttenuation();
 }
 
 //***********************************************************************************************
-long COMXAudio::GetCurrentVolume() const
+void COMXAudio::SetMute(bool bMute)
 {
-  return m_CurrentVolume;
+  CSingleLock lock (m_critSection);
+  m_Mute = bMute;
+  if (m_settings_changed)
+    UpdateAttenuation();
 }
 
 //***********************************************************************************************
-void COMXAudio::Mute(bool bMute)
+void COMXAudio::SetVolume(float fVolume)
 {
-  if(!m_Initialized)
-    return;
-
-  if (bMute)
-    SetCurrentVolume(VOLUME_MINIMUM);
-  else
-    SetCurrentVolume(m_CurrentVolume);
+  CSingleLock lock (m_critSection);
+  m_CurrentVolume = fVolume;
+  if (m_settings_changed)
+    UpdateAttenuation();
 }
 
 //***********************************************************************************************
-bool COMXAudio::SetCurrentVolume(float fVolume)
+bool COMXAudio::ApplyVolume(void)
 {
   CSingleLock lock (m_critSection);
 
-  if(!m_Initialized || m_Passthrough)
+  if (!m_Initialized || m_Passthrough)
     return false;
-  double gain = pow(10, (g_advancedSettings.m_ac3Gain - 12.0f) / 20.0);
-  m_CurrentVolume = fVolume;
 
-  if (m_format.m_channelLayout.Count() > 2)
-  {
-    double r = fVolume;
-    const float* coeff = downmixing_coefficients_8;
-    int input_channels = 0;
-
-    // normally we normalalise the levels, can be skipped (boosted) at risk of distortion
-    if(!g_guiSettings.GetBool("audiooutput.normalizelevels"))
-    {
-      double sum_L = 0;
-      double sum_R = 0;
+  float fVolume = m_Mute ? VOLUME_MINIMUM : m_CurrentVolume;
 
-      for(size_t i = 0; i < OMX_AUDIO_MAXCHANNELS; ++i)
-      {
-        if (m_input_channels[i] == OMX_AUDIO_ChannelMax)
-          break;
-        if(i & 1)
-          sum_R += coeff[i];
-        else
-          sum_L += coeff[i];
-      }
-
-      r /= max(sum_L, sum_R);
-    }
-
-    // the analogue volume is too quiet for some. Allow use of an advancedsetting to boost this (at risk of distortion)
-    r *= gain;
+  // the analogue volume is too quiet for some. Allow use of an advancedsetting to boost this (at risk of distortion) (deprecated)
+  double gain = pow(10, (g_advancedSettings.m_ac3Gain - 12.0f) / 20.0);
 
-    OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS mix;
-    OMX_INIT_STRUCTURE(mix);
-    mix.nPortIndex = m_omx_mixer.GetInputPort();
+  const float* coeff = m_downmix_matrix;
 
-    assert(sizeof(mix.coeff)/sizeof(mix.coeff[0]) == 16);
+  OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8 mix;
+  OMX_INIT_STRUCTURE(mix);
+  OMX_ERRORTYPE omx_err;
 
-    for(size_t i = 0; i < 16; ++i)
-      mix.coeff[i] = static_cast<unsigned int>(0x10000 * (coeff[i] * r));
+  assert(sizeof(mix.coeff)/sizeof(mix.coeff[0]) == 64);
 
-    OMX_ERRORTYPE omx_err =
-      m_omx_mixer.SetConfig(OMX_IndexConfigBrcmAudioDownmixCoefficients, &mix);
+  if (m_amplification != 1.0)
+  {
+    // reduce scaling so overflow can be seen
+    for(size_t i = 0; i < 8*8; ++i)
+      mix.coeff[i] = static_cast<unsigned int>(0x10000 * (coeff[i] * gain * 0.01f));
 
+    mix.nPortIndex = m_omx_decoder.GetInputPort();
+    omx_err = m_omx_decoder.SetConfig(OMX_IndexConfigBrcmAudioDownmixCoefficients8x8, &mix);
     if(omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "%s::%s - error setting OMX_IndexConfigBrcmAudioDownmixCoefficients, error 0x%08x\n",
+      CLog::Log(LOGERROR, "%s::%s - error setting decoder OMX_IndexConfigBrcmAudioDownmixCoefficients, error 0x%08x\n",
                 CLASSNAME, __func__, omx_err);
       return false;
     }
   }
-  else
+  for(size_t i = 0; i < 8*8; ++i)
+    mix.coeff[i] = static_cast<unsigned int>(0x10000 * (coeff[i] * gain * fVolume * m_amplification * m_attenuation));
+
+  mix.nPortIndex = m_omx_mixer.GetInputPort();
+  omx_err = m_omx_mixer.SetConfig(OMX_IndexConfigBrcmAudioDownmixCoefficients8x8, &mix);
+  if(omx_err != OMX_ErrorNone)
   {
-    OMX_AUDIO_CONFIG_VOLUMETYPE volume;
-    OMX_INIT_STRUCTURE(volume);
-    volume.nPortIndex = m_omx_render->GetInputPort();
+    CLog::Log(LOGERROR, "%s::%s - error setting mixer OMX_IndexConfigBrcmAudioDownmixCoefficients, error 0x%08x\n",
+              CLASSNAME, __func__, omx_err);
+    return false;
+  }
+  CLog::Log(LOGINFO, "%s::%s - Volume=%.2f (* %.2f * %.2f)\n", CLASSNAME, __func__, fVolume, m_amplification, m_attenuation);
+  return true;
+}
 
-    volume.bLinear    = OMX_TRUE;
-    float hardwareVolume = fVolume * gain * 100.0f;
-    volume.sVolume.nValue = (int)(hardwareVolume + 0.5f);
+void COMXAudio::VizPacket(const void* data, unsigned int len, double pts)
+{
+    /* input samples */
+    unsigned int vizBufferSamples = len / (CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3);
 
-    OMX_ERRORTYPE omx_err =
-      m_omx_render->SetConfig(OMX_IndexConfigAudioVolume, &volume);
-    if(omx_err != OMX_ErrorNone)
+    /* input frames */
+    unsigned int frames = vizBufferSamples / m_InputChannels;
+    float *floatBuffer = (float *)data;
+
+    if (m_format.m_dataFormat != AE_FMT_FLOAT)
     {
-      CLog::Log(LOGERROR, "%s::%s - error setting OMX_IndexConfigAudioVolume, error 0x%08x\n",
-                CLASSNAME, __func__, omx_err);
-      return false;
+      CAEConvert::AEConvertToFn m_convertFn = CAEConvert::ToFloat(m_format.m_dataFormat);
+
+      /* check convert buffer */
+      CheckOutputBufferSize((void **)&m_vizBuffer, &m_vizBufferSize, vizBufferSamples * (CAEUtil::DataFormatToBits(AE_FMT_FLOAT) >> 3));
+
+      /* convert to float */
+      m_convertFn((uint8_t *)data, vizBufferSamples, (float *)m_vizBuffer);
+      floatBuffer = (float *)m_vizBuffer;
     }
-  }  
-  return true;
+
+    // Viz channel count is 2
+    CheckOutputBufferSize((void **)&m_vizRemapBuffer, &m_vizRemapBufferSize, frames * 2 * sizeof(float));
+
+    /* remap */
+    m_vizRemap.Remap(floatBuffer, (float*)m_vizRemapBuffer, frames);
+
+    /* output samples */
+    vizBufferSamples = vizBufferSamples / m_InputChannels * 2;
+
+    /* viz size is limited */
+    if(vizBufferSamples > VIS_PACKET_SIZE)
+      vizBufferSamples = VIS_PACKET_SIZE;
+
+    vizblock_t v;
+    v.pts = pts;
+    v.num_samples = vizBufferSamples;
+    memcpy(v.samples, m_vizRemapBuffer, vizBufferSamples * sizeof(float));
+    m_vizqueue.push(v);
+
+    double stamp = m_av_clock->OMXMediaTime();
+    while(!m_vizqueue.empty())
+    {
+      vizblock_t &v = m_vizqueue.front();
+      /* if packet has almost reached media time (allow time for rendering delay) then display it */
+      /* we'll also consume if queue gets unexpectedly long to avoid filling memory */
+      if (v.pts == DVD_NOPTS_VALUE || v.pts - stamp < DVD_SEC_TO_TIME(1.0/30.0) || v.pts - stamp > DVD_SEC_TO_TIME(15.0))
+      {
+         m_pCallback->OnAudioData(v.samples, v.num_samples);
+         m_vizqueue.pop();
+      }
+      else break;
+   }
 }
 
 
@@ -786,44 +935,14 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
 {
   CSingleLock lock (m_critSection);
 
-  if(!m_Initialized) 
+  if(!m_Initialized)
   {
     CLog::Log(LOGERROR,"COMXAudio::AddPackets - sanity failed. no valid play handle!");
     return len;
   }
 
-  m_vizBufferSamples = 0;
-
-  if (m_pCallback && len)
-  {
-    /* input samples */
-    m_vizBufferSamples = len / (CAEUtil::DataFormatToBits(AE_FMT_S16LE) >> 3);
-    CAEConvert::AEConvertToFn m_convertFn = CAEConvert::ToFloat(AE_FMT_S16LE);
-    /* input frames */
-    unsigned int frames = m_vizBufferSamples / m_format.m_channelLayout.Count();
-
-    /* check convert buffer */
-    CheckOutputBufferSize((void **)&m_vizBuffer, &m_vizBufferSize, m_vizBufferSamples * (CAEUtil::DataFormatToBits(AE_FMT_FLOAT) >> 3));
-
-    /* convert to float */
-    m_convertFn((uint8_t *)data, m_vizBufferSamples, (float *)m_vizBuffer);
-
-    /* check remap buffer */
-    CheckOutputBufferSize((void **)&m_vizRemapBuffer, &m_vizRemapBufferSize, frames * 2 * (CAEUtil::DataFormatToBits(AE_FMT_FLOAT) >> 3));
-
-    /* remap */
-    m_vizRemap.Remap((float *)m_vizBuffer, (float*)m_vizRemapBuffer, frames);
-
-    /* output samples */
-    m_vizBufferSamples = m_vizBufferSamples / m_format.m_channelLayout.Count() * 2;
-
-    /* viz size is limited */
-    if(m_vizBufferSamples > VIS_PACKET_SIZE)
-      m_vizBufferSamples = VIS_PACKET_SIZE;
-
-    if(m_pCallback)
-      m_pCallback->OnAudioData((float *)m_vizRemapBuffer, m_vizBufferSamples);
-  }
+  if (m_pCallback && len && !(m_Passthrough || m_HWDecode))
+    VizPacket(data, len, pts);
 
   if(m_eEncoding == OMX_AUDIO_CodingDTS && m_LostSync && (m_Passthrough || m_HWDecode))
   {
@@ -839,14 +958,16 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
       return len;
   }
 
-  unsigned int demuxer_bytes = (unsigned int)len;
+  unsigned pitch = (m_Passthrough || m_HWDecode) ? 1:(m_BitsPerSample >> 3) * m_InputChannels;
+  unsigned int demuxer_samples = len / pitch;
+  unsigned int demuxer_samples_sent = 0;
   uint8_t *demuxer_content = (uint8_t *)data;
 
   OMX_ERRORTYPE omx_err;
 
   OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
 
-  while(demuxer_bytes)
+  while(demuxer_samples_sent < demuxer_samples)
   {
     // 200ms timeout
     omx_buffer = m_omx_decoder.GetInputBuffer(200);
@@ -860,12 +981,40 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
     omx_buffer->nOffset = 0;
     omx_buffer->nFlags  = 0;
 
-    omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
-    memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
+    // we want audio_decode output buffer size to be no more than AUDIO_DECODE_OUTPUT_BUFFER.
+    // it will be 16-bit and rounded up to next power of 2 in channels
+    static const char rounded_up_channels_shift[] = {0,0,1,2,2,3,3,3,3};
+    unsigned int max_buffer = AUDIO_DECODE_OUTPUT_BUFFER * (m_InputChannels * m_BitsPerSample) >> (rounded_up_channels_shift[m_InputChannels] + 4);
+
+    unsigned int remaining = demuxer_samples-demuxer_samples_sent;
+    unsigned int samples_space = std::min(max_buffer, omx_buffer->nAllocLen)/pitch;
+    unsigned int samples = std::min(remaining, samples_space);
+
+    omx_buffer->nFilledLen = samples * pitch;
+
+    if (samples < demuxer_samples && m_BitsPerSample==32 && !(m_Passthrough || m_HWDecode))
+    {
+       uint8_t *dst = omx_buffer->pBuffer;
+       uint8_t *src = demuxer_content + demuxer_samples_sent * (m_BitsPerSample >> 3);
+       // we need to extract samples from planar audio, so the copying needs to be done per plane
+       for (int i=0; i<(int)m_InputChannels; i++)
+       {
+         memcpy(dst, src, omx_buffer->nFilledLen / m_InputChannels);
+         dst += omx_buffer->nFilledLen / m_InputChannels;
+         src += demuxer_samples * (m_BitsPerSample >> 3);
+       }
+       assert(dst <= omx_buffer->pBuffer + m_ChunkLen);
+    }
+    else
+    {
+       uint8_t *dst = omx_buffer->pBuffer;
+       uint8_t *src = demuxer_content + demuxer_samples_sent * pitch;
+       memcpy(dst, src, omx_buffer->nFilledLen);
+    }
 
     uint64_t val  = (uint64_t)(pts == DVD_NOPTS_VALUE) ? 0 : pts;
 
-    if(m_av_clock->AudioStart())
+    if(m_setStartTime)
     {
       omx_buffer->nFlags = OMX_BUFFERFLAG_STARTTIME;
       if(pts == DVD_NOPTS_VALUE)
@@ -874,7 +1023,7 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
       m_last_pts = pts;
 
       CLog::Log(LOGDEBUG, "COMXAudio::Decode ADec : setStartTime %f\n", (float)val / DVD_TIME_BASE);
-      m_av_clock->AudioStart(false);
+      m_setStartTime = false;
     }
     else
     {
@@ -898,10 +1047,9 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
 
     omx_buffer->nTimeStamp = ToOMXTime(val);
 
-    demuxer_bytes -= omx_buffer->nFilledLen;
-    demuxer_content += omx_buffer->nFilledLen;
+    demuxer_samples_sent += samples;
 
-    if(demuxer_bytes == 0)
+    if(demuxer_samples_sent == demuxer_samples)
       omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
 
     int nRetry = 0;
@@ -925,159 +1073,90 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
       }
     }
 
-    if(m_first_frame)
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, 0);
+    if (omx_err == OMX_ErrorNone)
     {
-      m_first_frame = false;
-      //m_omx_render.WaitForEvent(OMX_EventPortSettingsChanged);
-
-      m_omx_render->DisablePort(m_omx_render->GetInputPort(), false);
-      if(!m_Passthrough)
+      if(!PortSettingsChanged())
       {
-        m_omx_mixer.DisablePort(m_omx_mixer.GetOutputPort(), false);
-        m_omx_mixer.DisablePort(m_omx_mixer.GetInputPort(), false);
+        CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
       }
-      m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), false);
+    }
+  }
+  m_submitted += (float)demuxer_samples / m_SampleRate;
+  UpdateAttenuation();
+  return len;
+}
 
-      if(!m_Passthrough)
-      {
-        if(m_HWDecode)
-        {
-          OMX_INIT_STRUCTURE(m_pcm_input);
-          m_pcm_input.nPortIndex      = m_omx_decoder.GetOutputPort();
-          omx_err = m_omx_decoder.GetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
-          if(omx_err != OMX_ErrorNone)
-          {
-            CLog::Log(LOGERROR, "COMXAudio::AddPackets error GetParameter 1 omx_err(0x%08x)\n", omx_err);
-          }
-        }
-
-        memcpy(m_pcm_input.eChannelMapping, m_input_channels, sizeof(m_input_channels));
-        m_pcm_input.nSamplingRate = m_format.m_sampleRate;
-
-        /* setup mixer input */
-        m_pcm_input.nPortIndex      = m_omx_mixer.GetInputPort();
-        omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error SetParameter 1 input omx_err(0x%08x)\n", omx_err);
-        }
-        omx_err = m_omx_mixer.GetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error GetParameter 2 input omx_err(0x%08x)\n", omx_err);
-        }
-
-        m_pcm_output.nSamplingRate = m_format.m_sampleRate;
-
-        /* setup mixer output */
-        m_pcm_output.nPortIndex      = m_omx_mixer.GetOutputPort();
-        omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error SetParameter 1 output omx_err(0x%08x)\n", omx_err);
-        }
-        omx_err = m_omx_mixer.GetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error GetParameter 2 output omx_err(0x%08x)\n", omx_err);
-        }
-
-        m_pcm_output.nSamplingRate = m_format.m_sampleRate;
-
-        m_pcm_output.nPortIndex      = m_omx_render->GetInputPort();
-        omx_err = m_omx_render->SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error SetParameter 1 render omx_err(0x%08x)\n", omx_err);
-        }
-        omx_err = m_omx_render->GetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error GetParameter 2 render omx_err(0x%08x)\n", omx_err);
-        }
-
-        PrintPCM(&m_pcm_input, std::string("input"));
-        PrintPCM(&m_pcm_output, std::string("output"));
-      }
-      else
-      {
-        OMX_AUDIO_PARAM_PORTFORMATTYPE formatType;
-        OMX_INIT_STRUCTURE(formatType);
-        formatType.nPortIndex = m_omx_render->GetInputPort();
-
-        omx_err = m_omx_render->GetParameter(OMX_IndexParamAudioPortFormat, &formatType);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error OMX_IndexParamAudioPortFormat omx_err(0x%08x)\n", omx_err);
-          assert(0);
-        }
-
-        formatType.eEncoding = m_eEncoding;
-
-        omx_err = m_omx_render->SetParameter(OMX_IndexParamAudioPortFormat, &formatType);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error OMX_IndexParamAudioPortFormat omx_err(0x%08x)\n", omx_err);
-          assert(0);
-        }
-
-        if(m_eEncoding == OMX_AUDIO_CodingDDP)
-        {
-          OMX_AUDIO_PARAM_DDPTYPE m_ddParam;
-          OMX_INIT_STRUCTURE(m_ddParam);
-
-          m_ddParam.nPortIndex      = m_omx_render->GetInputPort();
-
-          m_ddParam.nChannels       = m_format.m_channelLayout.Count(); //(m_InputChannels == 6) ? 8 : m_InputChannels;
-          m_ddParam.nSampleRate     = m_SampleRate;
-          m_ddParam.eBitStreamId    = OMX_AUDIO_DDPBitStreamIdAC3;
-          m_ddParam.nBitRate        = 0;
-
-          for(unsigned int i = 0; i < OMX_MAX_CHANNELS; i++)
-          {
-            if(i >= m_ddParam.nChannels)
-              break;
-
-            m_ddParam.eChannelMapping[i] = OMXChannels[i];
-          }
-  
-          m_omx_render->SetParameter(OMX_IndexParamAudioDdp, &m_ddParam);
-          m_omx_render->GetParameter(OMX_IndexParamAudioDdp, &m_ddParam);
-          PrintDDP(&m_ddParam);
-        }
-        else if(m_eEncoding == OMX_AUDIO_CodingDTS)
-        {
-          m_dtsParam.nPortIndex      = m_omx_render->GetInputPort();
-
-          m_dtsParam.nChannels       = m_format.m_channelLayout.Count(); //(m_InputChannels == 6) ? 8 : m_InputChannels;
-          m_dtsParam.nBitRate        = 0;
-
-          for(unsigned int i = 0; i < OMX_MAX_CHANNELS; i++)
-          {
-            if(i >= m_dtsParam.nChannels)
-              break;
-
-            m_dtsParam.eChannelMapping[i] = OMXChannels[i];
-          }
-  
-          m_omx_render->SetParameter(OMX_IndexParamAudioDts, &m_dtsParam);
-          m_omx_render->GetParameter(OMX_IndexParamAudioDts, &m_dtsParam);
-          PrintDTS(&m_dtsParam);
-        }
-      }
+void COMXAudio::UpdateAttenuation()
+{
+  // always called with m_critSection lock held
+  if (!m_Initialized || m_Passthrough)
+    return;
 
-      m_omx_render->EnablePort(m_omx_render->GetInputPort(), false);
-      if(!m_Passthrough)
-      {
-        m_omx_mixer.EnablePort(m_omx_mixer.GetOutputPort(), false);
-        m_omx_mixer.EnablePort(m_omx_mixer.GetInputPort(), false);
-      }
-      m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), false);
-    }
- 
+  if (m_amplification == 1.0)
+  {
+    ApplyVolume();
+    return;
   }
 
-  return len;
+  double level_pts = 0.0;
+  float level = GetMaxLevel(level_pts);
+  if (level_pts != 0.0)
+  {
+    amplitudes_t v;
+    v.level = level;
+    v.pts = level_pts;
+    m_ampqueue.push_back(v);
+  }
+  double stamp = m_av_clock->OMXMediaTime();
+  // discard too old data
+  while(!m_ampqueue.empty())
+  {
+    amplitudes_t &v = m_ampqueue.front();
+    /* we'll also consume if queue gets unexpectedly long to avoid filling memory */
+    if (v.pts == DVD_NOPTS_VALUE || v.pts < stamp || v.pts - stamp > DVD_SEC_TO_TIME(15.0))
+      m_ampqueue.pop_front();
+    else break;
+  }
+  float maxlevel = 0.0f, imminent_maxlevel = 0.0f;
+  for (int i=0; i < (int)m_ampqueue.size(); i++)
+  {
+    amplitudes_t &v = m_ampqueue[i];
+    maxlevel = std::max(maxlevel, v.level);
+    // check for maximum volume in next 200ms
+    if (v.pts != DVD_NOPTS_VALUE && v.pts < stamp + DVD_SEC_TO_TIME(0.2))
+      imminent_maxlevel = std::max(imminent_maxlevel, v.level);
+  }
+
+  if (maxlevel != 0.0)
+  {
+    float alpha_h = -1.0f/(0.025f*log10f(0.999f));
+    float alpha_r = -1.0f/(0.100f*log10f(0.900f));
+    float decay  = powf(10.0f, -1.0f / (alpha_h * g_advancedSettings.m_limiterHold));
+    float attack = powf(10.0f, -1.0f / (alpha_r * g_advancedSettings.m_limiterRelease));
+    // if we are going to clip imminently then deal with it now
+    if (imminent_maxlevel > m_maxLevel)
+      m_maxLevel = imminent_maxlevel;
+    // clip but not imminently can ramp up more slowly
+    else if (maxlevel > m_maxLevel)
+      m_maxLevel = attack * m_maxLevel + (1.0f-attack) * maxlevel;
+    // not clipping, decay more slowly
+    else
+      m_maxLevel = decay  * m_maxLevel + (1.0f-decay ) * maxlevel;
+
+    // want m_maxLevel * amp -> 1.0
+    float amp = m_amplification * m_attenuation;
+
+    // We fade in the attenuation over first couple of seconds
+    float start = std::min(std::max((m_submitted-1.0f), 0.0f), 1.0f);
+    float attenuation = std::min(1.0f, std::max(m_attenuation / (amp * m_maxLevel), 1.0f/m_amplification));
+    m_attenuation = (1.0f - start) * 1.0f/m_amplification + start * attenuation;
+  }
+  else
+  {
+    m_attenuation = 1.0f/m_amplification;
+  }
+  ApplyVolume();
 }
 
 //***********************************************************************************************
@@ -1090,7 +1169,7 @@ unsigned int COMXAudio::GetSpace()
 float COMXAudio::GetDelay()
 {
   unsigned int free = m_omx_decoder.GetInputBufferSize() - m_omx_decoder.GetInputBufferSpace();
-  return (float)free / (float)m_BytesPerSec;
+  return m_BytesPerSec ? (float)free / (float)m_BytesPerSec : 0.0f;
 }
 
 float COMXAudio::GetCacheTime()
@@ -1098,13 +1177,13 @@ float COMXAudio::GetCacheTime()
   float fBufferLenFull = (float)m_BufferLen - (float)GetSpace();
   if(fBufferLenFull < 0)
     fBufferLenFull = 0;
-  float ret = fBufferLenFull / (float)m_BytesPerSec;
+  float ret = m_BytesPerSec ? fBufferLenFull / (float)m_BytesPerSec : 0.0f;
   return ret;
 }
 
 float COMXAudio::GetCacheTotal()
 {
-  return (float)m_BufferLen / (float)m_BytesPerSec;
+  return m_BytesPerSec ? (float)m_BufferLen / (float)m_BytesPerSec : 0.0f;
 }
 
 //***********************************************************************************************
@@ -1120,7 +1199,7 @@ int COMXAudio::SetPlaySpeed(int iSpeed)
 
 void COMXAudio::RegisterAudioCallback(IAudioCallback *pCallback)
 {
-  m_vizBufferSamples = 0;
+  CSingleLock lock (m_critSection);
   if(!m_Passthrough && !m_HWDecode)
   {
     m_pCallback = pCallback;
@@ -1133,8 +1212,8 @@ void COMXAudio::RegisterAudioCallback(IAudioCallback *pCallback)
 
 void COMXAudio::UnRegisterAudioCallback()
 {
+  CSingleLock lock (m_critSection);
   m_pCallback = NULL;
-  m_vizBufferSamples = 0;
 }
 
 unsigned int COMXAudio::GetAudioRenderingLatency()
@@ -1146,34 +1225,81 @@ unsigned int COMXAudio::GetAudioRenderingLatency()
 
   OMX_PARAM_U32TYPE param;
   OMX_INIT_STRUCTURE(param);
-  param.nPortIndex = m_omx_render->GetInputPort();
 
-  OMX_ERRORTYPE omx_err =
-    m_omx_render->GetConfig(OMX_IndexConfigAudioRenderingLatency, &param);
+  if(m_omx_render_analog.IsInitialized())
+  {
+    param.nPortIndex = m_omx_render_analog.GetInputPort();
+
+    OMX_ERRORTYPE omx_err = m_omx_render_analog.GetConfig(OMX_IndexConfigAudioRenderingLatency, &param);
 
-  if(omx_err != OMX_ErrorNone)
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error getting OMX_IndexConfigAudioRenderingLatency error 0x%08x\n",
+        CLASSNAME, __func__, omx_err);
+      return 0;
+    }
+  }
+  else if(m_omx_render_hdmi.IsInitialized())
   {
-    CLog::Log(LOGERROR, "%s::%s - error getting OMX_IndexConfigAudioRenderingLatency error 0x%08x\n",
-      CLASSNAME, __func__, omx_err);
-    return 0;
+    param.nPortIndex = m_omx_render_hdmi.GetInputPort();
+
+    OMX_ERRORTYPE omx_err = m_omx_render_hdmi.GetConfig(OMX_IndexConfigAudioRenderingLatency, &param);
+
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error getting OMX_IndexConfigAudioRenderingLatency error 0x%08x\n",
+        CLASSNAME, __func__, omx_err);
+      return 0;
+    }
   }
 
   return param.nU32;
 }
 
+float COMXAudio::GetMaxLevel(double &pts)
+{
+  CSingleLock lock (m_critSection);
+
+  if(!m_Initialized)
+    return 0;
+
+  OMX_CONFIG_BRCMAUDIOMAXSAMPLE param;
+  OMX_INIT_STRUCTURE(param);
+
+  if(m_omx_decoder.IsInitialized())
+  {
+    param.nPortIndex = m_omx_decoder.GetInputPort();
+
+    OMX_ERRORTYPE omx_err = m_omx_decoder.GetConfig(OMX_IndexConfigBrcmAudioMaxSample, &param);
+
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error getting OMX_IndexConfigBrcmAudioMaxSample error 0x%08x\n",
+        CLASSNAME, __func__, omx_err);
+      return 0;
+    }
+  }
+  pts = FromOMXTime(param.nTimeStamp);
+  return (float)param.nMaxSample * (100.0f / (1<<15));
+}
+
 void COMXAudio::SubmitEOS()
 {
   CSingleLock lock (m_critSection);
 
-  if(!m_Initialized || m_Pause)
+  if(!m_Initialized)
     return;
 
+  m_submitted_eos = true;
+  m_failed_eos = false;
+
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer();
+  OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(1000);
 
   if(omx_buffer == NULL)
   {
     CLog::Log(LOGERROR, "%s::%s - buffer error 0x%08x", CLASSNAME, __func__, omx_err);
+    m_failed_eos = true;
     return;
   }
 
@@ -1189,15 +1315,25 @@ void COMXAudio::SubmitEOS()
     CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)\n", CLASSNAME, __func__, omx_err);
     return;
   }
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
 }
 
 bool COMXAudio::IsEOS()
 {
-  if(!m_Initialized || m_Pause)
+  if(!m_Initialized)
     return true;
   unsigned int latency = GetAudioRenderingLatency();
   CSingleLock lock (m_critSection);
-  return m_omx_decoder.IsEOS() && latency <= 0;
+
+  if (!m_failed_eos && !(m_omx_decoder.IsEOS() && latency == 0))
+    return false;
+
+  if (m_submitted_eos)
+  {
+    CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+    m_submitted_eos = false;
+  }
+  return true;
 }
 
 void COMXAudio::SwitchChannels(int iAudioStream, bool bAudioOnAllSpeakers)
@@ -1435,7 +1571,6 @@ unsigned int COMXAudio::SyncDTS(BYTE* pData, unsigned int iSize)
 unsigned int COMXAudio::SyncAC3(BYTE* pData, unsigned int iSize)
 {
   unsigned int skip = 0;
-  //unsigned int fSize = 0;
 
   for(skip = 0; iSize - skip > 6; ++skip, ++pData)
   {
@@ -1464,7 +1599,6 @@ unsigned int COMXAudio::SyncAC3(BYTE* pData, unsigned int iSize)
       case 2: framesize = bitrate * 4; break;
     }
 
-    //fSize = framesize * 2;
     m_SampleRate = AC3FSCod[fscod];
 
     /* dont do extensive testing if we have not lost sync */
@@ -1503,3 +1637,121 @@ void COMXAudio::CheckOutputBufferSize(void **buffer, int *oldSize, int newSize)
   memset(*buffer, 0x0, *oldSize);
 }
 
+void COMXAudio::BuildChannelMap(enum PCMChannels *channelMap, uint64_t layout)
+{
+  int index = 0;
+  if (layout & AV_CH_FRONT_LEFT           ) channelMap[index++] = PCM_FRONT_LEFT           ;
+  if (layout & AV_CH_FRONT_RIGHT          ) channelMap[index++] = PCM_FRONT_RIGHT          ;
+  if (layout & AV_CH_FRONT_CENTER         ) channelMap[index++] = PCM_FRONT_CENTER         ;
+  if (layout & AV_CH_LOW_FREQUENCY        ) channelMap[index++] = PCM_LOW_FREQUENCY        ;
+  if (layout & AV_CH_BACK_LEFT            ) channelMap[index++] = PCM_BACK_LEFT            ;
+  if (layout & AV_CH_BACK_RIGHT           ) channelMap[index++] = PCM_BACK_RIGHT           ;
+  if (layout & AV_CH_FRONT_LEFT_OF_CENTER ) channelMap[index++] = PCM_FRONT_LEFT_OF_CENTER ;
+  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER) channelMap[index++] = PCM_FRONT_RIGHT_OF_CENTER;
+  if (layout & AV_CH_BACK_CENTER          ) channelMap[index++] = PCM_BACK_CENTER          ;
+  if (layout & AV_CH_SIDE_LEFT            ) channelMap[index++] = PCM_SIDE_LEFT            ;
+  if (layout & AV_CH_SIDE_RIGHT           ) channelMap[index++] = PCM_SIDE_RIGHT           ;
+  if (layout & AV_CH_TOP_CENTER           ) channelMap[index++] = PCM_TOP_CENTER           ;
+  if (layout & AV_CH_TOP_FRONT_LEFT       ) channelMap[index++] = PCM_TOP_FRONT_LEFT       ;
+  if (layout & AV_CH_TOP_FRONT_CENTER     ) channelMap[index++] = PCM_TOP_FRONT_CENTER     ;
+  if (layout & AV_CH_TOP_FRONT_RIGHT      ) channelMap[index++] = PCM_TOP_FRONT_RIGHT      ;
+  if (layout & AV_CH_TOP_BACK_LEFT        ) channelMap[index++] = PCM_TOP_BACK_LEFT        ;
+  if (layout & AV_CH_TOP_BACK_CENTER      ) channelMap[index++] = PCM_TOP_BACK_CENTER      ;
+  if (layout & AV_CH_TOP_BACK_RIGHT       ) channelMap[index++] = PCM_TOP_BACK_RIGHT       ;
+  while (index<OMX_AUDIO_MAXCHANNELS)
+    channelMap[index++] = PCM_INVALID;
+}
+
+// See CEA spec: Table 20, Audio InfoFrame data byte 4 for the ordering here
+int COMXAudio::BuildChannelMapCEA(enum PCMChannels *channelMap, uint64_t layout)
+{
+  int index = 0;
+  if (layout & AV_CH_FRONT_LEFT           ) channelMap[index++] = PCM_FRONT_LEFT;
+  if (layout & AV_CH_FRONT_RIGHT          ) channelMap[index++] = PCM_FRONT_RIGHT;
+  if (layout & AV_CH_LOW_FREQUENCY        ) channelMap[index++] = PCM_LOW_FREQUENCY;
+  if (layout & AV_CH_FRONT_CENTER         ) channelMap[index++] = PCM_FRONT_CENTER;
+  if (layout & AV_CH_BACK_LEFT            ) channelMap[index++] = PCM_BACK_LEFT;
+  if (layout & AV_CH_BACK_RIGHT           ) channelMap[index++] = PCM_BACK_RIGHT;
+  if (layout & AV_CH_SIDE_LEFT            ) channelMap[index++] = PCM_SIDE_LEFT;
+  if (layout & AV_CH_SIDE_RIGHT           ) channelMap[index++] = PCM_SIDE_RIGHT;
+
+  while (index<OMX_AUDIO_MAXCHANNELS)
+    channelMap[index++] = PCM_INVALID;
+
+  int num_channels = 0;
+  for (index=0; index<OMX_AUDIO_MAXCHANNELS; index++)
+    if (channelMap[index] != PCM_INVALID)
+       num_channels = index+1;
+  return num_channels;
+}
+
+void COMXAudio::BuildChannelMapOMX(enum OMX_AUDIO_CHANNELTYPE *	channelMap, uint64_t layout)
+{
+  int index = 0;
+
+  if (layout & AV_CH_FRONT_LEFT           ) channelMap[index++] = OMX_AUDIO_ChannelLF;
+  if (layout & AV_CH_FRONT_RIGHT          ) channelMap[index++] = OMX_AUDIO_ChannelRF;
+  if (layout & AV_CH_FRONT_CENTER         ) channelMap[index++] = OMX_AUDIO_ChannelCF;
+  if (layout & AV_CH_LOW_FREQUENCY        ) channelMap[index++] = OMX_AUDIO_ChannelLFE;
+  if (layout & AV_CH_BACK_LEFT            ) channelMap[index++] = OMX_AUDIO_ChannelLR;
+  if (layout & AV_CH_BACK_RIGHT           ) channelMap[index++] = OMX_AUDIO_ChannelRR;
+  if (layout & AV_CH_SIDE_LEFT            ) channelMap[index++] = OMX_AUDIO_ChannelLS;
+  if (layout & AV_CH_SIDE_RIGHT           ) channelMap[index++] = OMX_AUDIO_ChannelRS;
+  if (layout & AV_CH_BACK_CENTER          ) channelMap[index++] = OMX_AUDIO_ChannelCS;
+  // following are not in openmax spec, but gpu does accept them
+  if (layout & AV_CH_FRONT_LEFT_OF_CENTER ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)10;
+  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)11;
+  if (layout & AV_CH_TOP_CENTER           ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)12;
+  if (layout & AV_CH_TOP_FRONT_LEFT       ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)13;
+  if (layout & AV_CH_TOP_FRONT_CENTER     ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)14;
+  if (layout & AV_CH_TOP_FRONT_RIGHT      ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)15;
+  if (layout & AV_CH_TOP_BACK_LEFT        ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)16;
+  if (layout & AV_CH_TOP_BACK_CENTER      ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)17;
+  if (layout & AV_CH_TOP_BACK_RIGHT       ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)18;
+
+  while (index<OMX_AUDIO_MAXCHANNELS)
+    channelMap[index++] = OMX_AUDIO_ChannelNone;
+}
+
+uint64_t COMXAudio::GetChannelLayout(enum PCMLayout layout)
+{
+  uint64_t layouts[] = {
+    /* 2.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT,
+    /* 2.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_LOW_FREQUENCY,
+    /* 3.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER,
+    /* 3.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_LOW_FREQUENCY,
+    /* 4.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT,
+    /* 4.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT | 1<<PCM_LOW_FREQUENCY,
+    /* 5.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT,
+    /* 5.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT | 1<<PCM_LOW_FREQUENCY,
+    /* 7.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_SIDE_LEFT | 1<<PCM_SIDE_RIGHT | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT,
+    /* 7.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_SIDE_LEFT | 1<<PCM_SIDE_RIGHT | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT | 1<<PCM_LOW_FREQUENCY
+  };
+  return (int)layout < 10 ? layouts[(int)layout] : 0;
+}
+
+CAEChannelInfo COMXAudio::GetAEChannelLayout(uint64_t layout)
+{
+  CAEChannelInfo m_channelLayout;
+  m_channelLayout.Reset();
+
+  if (layout & AV_CH_FRONT_LEFT           ) m_channelLayout += AE_CH_FL  ;
+  if (layout & AV_CH_FRONT_RIGHT          ) m_channelLayout += AE_CH_FR  ;
+  if (layout & AV_CH_FRONT_CENTER         ) m_channelLayout += AE_CH_FC  ;
+  if (layout & AV_CH_LOW_FREQUENCY        ) m_channelLayout += AE_CH_LFE ;
+  if (layout & AV_CH_BACK_LEFT            ) m_channelLayout += AE_CH_BL  ;
+  if (layout & AV_CH_BACK_RIGHT           ) m_channelLayout += AE_CH_BR  ;
+  if (layout & AV_CH_FRONT_LEFT_OF_CENTER ) m_channelLayout += AE_CH_FLOC;
+  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER) m_channelLayout += AE_CH_FROC;
+  if (layout & AV_CH_BACK_CENTER          ) m_channelLayout += AE_CH_BC  ;
+  if (layout & AV_CH_SIDE_LEFT            ) m_channelLayout += AE_CH_SL  ;
+  if (layout & AV_CH_SIDE_RIGHT           ) m_channelLayout += AE_CH_SR  ;
+  if (layout & AV_CH_TOP_CENTER           ) m_channelLayout += AE_CH_TC  ;
+  if (layout & AV_CH_TOP_FRONT_LEFT       ) m_channelLayout += AE_CH_TFL ;
+  if (layout & AV_CH_TOP_FRONT_CENTER     ) m_channelLayout += AE_CH_TFC ;
+  if (layout & AV_CH_TOP_FRONT_RIGHT      ) m_channelLayout += AE_CH_TFR ;
+  if (layout & AV_CH_TOP_BACK_LEFT        ) m_channelLayout += AE_CH_BL  ;
+  if (layout & AV_CH_TOP_BACK_CENTER      ) m_channelLayout += AE_CH_BC  ;
+  if (layout & AV_CH_TOP_BACK_RIGHT       ) m_channelLayout += AE_CH_BR  ;
+  return m_channelLayout;
+}
diff --git a/xbmc/cores/omxplayer/OMXAudio.h b/xbmc/cores/omxplayer/OMXAudio.h
index 9537d9e..e6df02d 100644
--- a/xbmc/cores/omxplayer/OMXAudio.h
+++ b/xbmc/cores/omxplayer/OMXAudio.h
@@ -38,10 +38,11 @@
 #include "OMXCore.h"
 #include "DllAvCodec.h"
 #include "DllAvUtil.h"
+#include "PCMRemap.h"
 
 #include "threads/CriticalSection.h"
 
-#define AUDIO_BUFFER_SECONDS 2
+#define AUDIO_BUFFER_SECONDS 3
 #define VIS_PACKET_SIZE 512
 
 #define OMX_IS_RAW(x)       \
@@ -60,21 +61,20 @@ class COMXAudio
   float GetCacheTime();
   float GetCacheTotal();
   COMXAudio();
-  bool Initialize(AEAudioFormat format, std::string& device, OMXClock *clock, CDVDStreamInfo &hints, bool bUsePassthrough, bool bUseHWDecode);
+  bool Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo &hints, uint64_t channelMap, bool bUsePassthrough, bool bUseHWDecode);
+  bool PortSettingsChanged();
   ~COMXAudio();
 
   unsigned int AddPackets(const void* data, unsigned int len);
   unsigned int AddPackets(const void* data, unsigned int len, double dts, double pts);
   unsigned int GetSpace();
   bool Deinitialize();
-  bool Pause();
-  bool Stop();
-  bool Resume();
-
-  long GetCurrentVolume() const;
-  void Mute(bool bMute);
-  bool SetCurrentVolume(float fVolume);
-  void SetDynamicRangeCompression(long drc) { m_drc = drc; }
+
+  void SetVolume(float nVolume);
+  void SetMute(bool bOnOff);
+  void SetDynamicRangeCompression(long drc);
+  float GetDynamicRangeAmplification() { return 20.0f * log10f(m_amplification * m_attenuation); }
+  bool ApplyVolume();
   int SetPlaySpeed(int iSpeed);
   void SubmitEOS();
   bool IsEOS();
@@ -93,62 +93,91 @@ class COMXAudio
   void PrintDTS(OMX_AUDIO_PARAM_DTSTYPE *dtsparam);
   unsigned int SyncDTS(BYTE* pData, unsigned int iSize);
   unsigned int SyncAC3(BYTE* pData, unsigned int iSize);
+  void UpdateAttenuation();
 
   bool BadState() { return !m_Initialized; };
   unsigned int GetAudioRenderingLatency();
+  float GetMaxLevel(double &pts);
+  void VizPacket(const void* data, unsigned int len, double pts);
+
+  void BuildChannelMap(enum PCMChannels *channelMap, uint64_t layout);
+  int BuildChannelMapCEA(enum PCMChannels *channelMap, uint64_t layout);
+  void BuildChannelMapOMX(enum OMX_AUDIO_CHANNELTYPE *channelMap, uint64_t layout);
+  uint64_t GetChannelLayout(enum PCMLayout layout);
+  CAEChannelInfo GetAEChannelLayout(uint64_t layout);
 
 private:
   IAudioCallback* m_pCallback;
   bool          m_Initialized;
-  bool          m_Pause;
-  bool          m_CanPause;
   float         m_CurrentVolume;
+  bool          m_Mute;
   long          m_drc;
   bool          m_Passthrough;
   bool          m_HWDecode;
   unsigned int  m_BytesPerSec;
   unsigned int  m_BufferLen;
   unsigned int  m_ChunkLen;
+  unsigned int  m_InputChannels;
   unsigned int  m_OutputChannels;
   unsigned int  m_BitsPerSample;
+  float         m_maxLevel;
+  float         m_amplification;
+  float         m_attenuation;
+  float         m_submitted;
   COMXCoreComponent *m_omx_clock;
   OMXClock       *m_av_clock;
-  bool          m_first_frame;
+  bool          m_settings_changed;
+  bool          m_setStartTime;
   bool          m_LostSync;
   int           m_SampleRate;
   OMX_AUDIO_CODINGTYPE m_eEncoding;
   uint8_t       *m_extradata;
   int           m_extrasize;
   // stuff for visualisation
-  unsigned int  m_vizBufferSamples;
   double        m_last_pts;
   int           m_vizBufferSize;
   uint8_t       *m_vizBuffer;
   int           m_vizRemapBufferSize;
   uint8_t       *m_vizRemapBuffer;
   CAERemap      m_vizRemap;
+  bool          m_submitted_eos;
+  bool          m_failed_eos;
+  typedef struct {
+    int num_samples;
+    float samples[VIS_PACKET_SIZE];
+    double pts;
+  } vizblock_t;
+  std::queue<vizblock_t> m_vizqueue;
+
+  typedef struct {
+    double pts;
+    float level;
+  } amplitudes_t;
+  std::deque<amplitudes_t> m_ampqueue;
+
+  float m_downmix_matrix[OMX_AUDIO_MAXCHANNELS*OMX_AUDIO_MAXCHANNELS];
 
+  OMX_AUDIO_CHANNELTYPE m_input_channels[OMX_AUDIO_MAXCHANNELS];
+  OMX_AUDIO_CHANNELTYPE m_output_channels[OMX_AUDIO_MAXCHANNELS];
   OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_output;
   OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_input;
   OMX_AUDIO_PARAM_DTSTYPE     m_dtsParam;
   WAVEFORMATEXTENSIBLE        m_wave_header;
   AEAudioFormat m_format;
 protected:
-  COMXCoreComponent *m_omx_render;
+  COMXCoreComponent m_omx_render_analog;
+  COMXCoreComponent m_omx_render_hdmi;
+  COMXCoreComponent m_omx_splitter;
   COMXCoreComponent m_omx_mixer;
   COMXCoreComponent m_omx_decoder;
-  COMXCoreTunel     m_omx_tunnel_clock;
+  COMXCoreTunel     m_omx_tunnel_clock_analog;
+  COMXCoreTunel     m_omx_tunnel_clock_hdmi;
   COMXCoreTunel     m_omx_tunnel_mixer;
   COMXCoreTunel     m_omx_tunnel_decoder;
+  COMXCoreTunel     m_omx_tunnel_splitter_analog;
+  COMXCoreTunel     m_omx_tunnel_splitter_hdmi;
   DllAvUtil         m_dllAvUtil;
 
-  OMX_AUDIO_CHANNELTYPE m_input_channels[OMX_AUDIO_MAXCHANNELS];
-  OMX_AUDIO_CHANNELTYPE m_output_channels[OMX_AUDIO_MAXCHANNELS];
-
-  CAEChannelInfo    m_channelLayout;
-
-  CAEChannelInfo    GetChannelLayout(AEAudioFormat format);
-
   void CheckOutputBufferSize(void **buffer, int *oldSize, int newSize);
   CCriticalSection m_critSection;
 };
diff --git a/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp b/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
index 89b485d..c77ab68 100644
--- a/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
+++ b/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
@@ -28,43 +28,6 @@
 
 #define MAX_AUDIO_FRAME_SIZE (AVCODEC_MAX_AUDIO_FRAME_SIZE*2)
 
-template <class AudioDataType>
-static inline void _Upmix(AudioDataType *input,
-  unsigned int channelsInput, AudioDataType *output,
-  unsigned int channelsOutput, unsigned int frames)
-{
-  unsigned int unused = channelsOutput - channelsInput;
-  AudioDataType *_input  = input;
-  AudioDataType *_output = output;
-
-  for (unsigned int i = 0; i < frames; i++)
-  {
-    // get input channels
-    for(unsigned int j = 0; j < channelsInput; j++)
-      *_output++ = *_input++;
-    // set unused channels
-    for(unsigned int j = 0; j < unused; j++)
-      *_output++ = 0;
-  }
-}
-
-void COMXAudioCodecOMX::Upmix(void *input,
-  unsigned int channelsInput,  void *output,
-  unsigned int channelsOutput, unsigned int frames, AEDataFormat dataFormat)
-{
-  // input channels must be less than output channels
-  if (channelsInput >= channelsOutput)
-    return;
-
-  switch (CAEUtil::DataFormatToBits(dataFormat))
-  {
-    case 8:  _Upmix ( (unsigned char *) input, channelsInput, (unsigned char *) output, channelsOutput, frames ); break;
-    case 16: _Upmix ( (short         *) input, channelsInput, (short         *) output, channelsOutput, frames ); break;
-    case 32: _Upmix ( (float         *) input, channelsInput, (float         *) output, channelsOutput, frames ); break;
-    default: _Upmix ( (int           *) input, channelsInput, (int           *) output, channelsOutput, frames ); break;
-  }
-}
-
 COMXAudioCodecOMX::COMXAudioCodecOMX()
 {
   m_iBufferSize2 = 0;
@@ -81,9 +44,10 @@ COMXAudioCodecOMX::COMXAudioCodecOMX()
   m_bOpenedCodec = false;
 
   m_channels = 0;
-  m_layout = 0;
   m_pFrame1 = NULL;
   m_iSampleFormat = AV_SAMPLE_FMT_NONE;
+  m_desiredSampleFormat = AV_SAMPLE_FMT_NONE;
+  m_iBufferSize1 = 0;
 }
 
 COMXAudioCodecOMX::~COMXAudioCodecOMX()
@@ -110,6 +74,7 @@ bool COMXAudioCodecOMX::Open(CDVDStreamInfo &hints)
     return false;
   }
 
+  m_bFirstFrame = true;
   m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
@@ -145,6 +110,7 @@ bool COMXAudioCodecOMX::Open(CDVDStreamInfo &hints)
   m_pFrame1 = m_dllAvCodec.avcodec_alloc_frame();
   m_bOpenedCodec = true;
   m_iSampleFormat = AV_SAMPLE_FMT_NONE;
+  m_desiredSampleFormat = m_pCodecContext->sample_fmt == AV_SAMPLE_FMT_S16 ? AV_SAMPLE_FMT_S16 : AV_SAMPLE_FMT_FLTP;
   return true;
 }
 
@@ -158,6 +124,8 @@ void COMXAudioCodecOMX::Dispose()
 
   if (m_pCodecContext)
   {
+    if (m_pCodecContext->extradata) m_dllAvUtil.av_free(m_pCodecContext->extradata);
+    m_pCodecContext->extradata = NULL;
     if (m_bOpenedCodec) m_dllAvCodec.avcodec_close(m_pCodecContext);
     m_bOpenedCodec = false;
     m_dllAvUtil.av_free(m_pCodecContext);
@@ -178,9 +146,6 @@ int COMXAudioCodecOMX::Decode(BYTE* pData, int iSize)
   int iBytesUsed, got_frame;
   if (!m_pCodecContext) return -1;
 
-  m_iBufferSize1 = AVCODEC_MAX_AUDIO_FRAME_SIZE;
-  m_iBufferSize2 = 0;
-
   AVPacket avpkt;
   m_dllAvCodec.av_init_packet(&avpkt);
   avpkt.data = pData;
@@ -195,7 +160,9 @@ int COMXAudioCodecOMX::Decode(BYTE* pData, int iSize)
     m_iBufferSize2 = 0;
     return iBytesUsed;
   }
-  m_iBufferSize1 = m_dllAvUtil.av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, m_pCodecContext->sample_fmt, 1);
+  int linesize1, linesize2;
+  m_iBufferSize1 = m_dllAvUtil.av_samples_get_buffer_size(&linesize1, m_pCodecContext->channels, m_pFrame1->nb_samples, m_pCodecContext->sample_fmt, 1);
+  m_iBufferSize2 = m_dllAvUtil.av_samples_get_buffer_size(&linesize2, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1);
 
   /* some codecs will attempt to consume more data than what we gave */
   if (iBytesUsed > iSize)
@@ -209,41 +176,59 @@ int COMXAudioCodecOMX::Decode(BYTE* pData, int iSize)
   else
     m_iBuffered = 0;
 
-  if(m_pCodecContext->sample_fmt != AV_SAMPLE_FMT_S16 && m_iBufferSize1 > 0)
+  if (m_bFirstFrame)
+  {
+    CLog::Log(LOGDEBUG, "COMXAudioCodecOMX::Decode(%p,%d) format=%d(%d) chan=%d samples=%d size=%d/%d,%d/%d,%d data=%p,%p,%p,%p,%p,%p,%p,%p",
+             pData, iSize, m_pCodecContext->sample_fmt, m_desiredSampleFormat, m_pCodecContext->channels, m_pFrame1->nb_samples,
+             m_iBufferSize1, m_iBufferSize2, linesize1, linesize2, m_pFrame1->linesize[0],
+             m_pFrame1->data[0], m_pFrame1->data[1], m_pFrame1->data[2], m_pFrame1->data[3], m_pFrame1->data[4], m_pFrame1->data[5], m_pFrame1->data[6], m_pFrame1->data[7]
+             );
+  }
+
+  if(m_pCodecContext->sample_fmt != m_desiredSampleFormat && m_iBufferSize1 > 0)
   {
-    if(m_pConvert && m_pCodecContext->sample_fmt != m_iSampleFormat)
+    if(m_pConvert && (m_pCodecContext->sample_fmt != m_iSampleFormat || m_channels != m_pCodecContext->channels))
+    {
       m_dllSwResample.swr_free(&m_pConvert);
+      m_channels = m_pCodecContext->channels;
+    }
 
     if(!m_pConvert)
     {
       m_iSampleFormat = m_pCodecContext->sample_fmt;
       m_pConvert = m_dllSwResample.swr_alloc_set_opts(NULL,
                       m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), 
-                      AV_SAMPLE_FMT_S16, m_pCodecContext->sample_rate,
+                      m_desiredSampleFormat, m_pCodecContext->sample_rate,
                       m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), 
                       m_pCodecContext->sample_fmt, m_pCodecContext->sample_rate,
                       0, NULL);
-    }
 
-    if(!m_pConvert || m_dllSwResample.swr_init(m_pConvert) < 0)
-    {
-      CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to convert %d to AV_SAMPLE_FMT_S16", m_pCodecContext->sample_fmt);
-      m_iBufferSize1 = 0;
-      m_iBufferSize2 = 0;
-      return iBytesUsed;
+      if(!m_pConvert || m_dllSwResample.swr_init(m_pConvert) < 0)
+      {
+        CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to initialise convert format %d to %d", m_pCodecContext->sample_fmt, m_desiredSampleFormat);
+        m_iBufferSize1 = 0;
+        m_iBufferSize2 = 0;
+        return iBytesUsed;
+      }
     }
+    m_iBufferSize1 = 0;
+
+    BYTE *out_planes[] = {
+            m_pBuffer2 + 0 * linesize2, m_pBuffer2 + 1 * linesize2, m_pBuffer2 + 2 * linesize2, m_pBuffer2 + 3 * linesize2,
+            m_pBuffer2 + 4 * linesize2, m_pBuffer2 + 5 * linesize2, m_pBuffer2 + 6 * linesize2, m_pBuffer2 + 7 * linesize2,
+    };
 
-    int len = m_iBufferSize1 / m_dllAvUtil.av_get_bytes_per_sample(m_pCodecContext->sample_fmt);
-    if(m_dllSwResample.swr_convert(m_pConvert, &m_pBuffer2, len, (const uint8_t**)m_pFrame1->data, m_pFrame1->nb_samples) < 0)
+    if(m_dllSwResample.swr_convert(m_pConvert, out_planes, m_pFrame1->nb_samples, (const uint8_t **)m_pFrame1->data, m_pFrame1->nb_samples) < 0)
     {
-      CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to convert %d to AV_SAMPLE_FMT_S16", (int)m_pCodecContext->sample_fmt);
+      CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to convert format %d to %d", (int)m_pCodecContext->sample_fmt, m_desiredSampleFormat);
       m_iBufferSize1 = 0;
       m_iBufferSize2 = 0;
       return iBytesUsed;
     }
-
-    m_iBufferSize1 = 0;
-    m_iBufferSize2 = len * m_dllAvUtil.av_get_bytes_per_sample(AV_SAMPLE_FMT_S16);
+  }
+  else
+  {
+    m_iBufferSize2 = 0;
   }
 
   return iBytesUsed;
@@ -251,37 +236,57 @@ int COMXAudioCodecOMX::Decode(BYTE* pData, int iSize)
 
 int COMXAudioCodecOMX::GetData(BYTE** dst)
 {
-  unsigned int size = 0;
-  BYTE *src = NULL;
+  int size = 0;
+  bool contiguous = true;
 
   if(m_iBufferSize1)
   {
-    *dst = m_pFrame1->data[0];
-    src = m_pFrame1->data[0];
-    size = m_iBufferSize1;
+    int i;
+    int linesize;
+    BYTE *next = m_pFrame1->data[0];
+    m_dllAvUtil.av_samples_get_buffer_size(&linesize, m_pCodecContext->channels, m_pFrame1->nb_samples, m_pCodecContext->sample_fmt, 1);
+    for (i=0; i<m_pCodecContext->channels; i++)
+    {
+      if (!m_pFrame1->data[i])
+        break;
+      if (next != m_pFrame1->data[i])
+        contiguous = false;
+      next += linesize;
+      size += linesize;
+    }
+    if (size != m_iBufferSize1)
+      contiguous = false;
+
+    if (contiguous)
+    {
+      *dst = m_pFrame1->data[0];
+      size = m_iBufferSize1;
+    }
+    else
+    {
+      m_iBufferUpmixSize = 0;
+      for (i=0; i<m_pCodecContext->channels; i++)
+      {
+        if (m_iBufferUpmixSize + linesize <= MAX_AUDIO_FRAME_SIZE && m_pFrame1->data[i])
+        {
+          memcpy(m_pBufferUpmix + m_iBufferUpmixSize, m_pFrame1->data[i], linesize);
+          m_iBufferUpmixSize += linesize;
+        } else assert(0);
+      }
+      *dst = m_pBufferUpmix;
+      size = m_iBufferUpmixSize;
+    }
   }
   if(m_iBufferSize2)
   {
     *dst = m_pBuffer2;
-    src = m_pBuffer2;
     size = m_iBufferSize2;
   }
-
-  if(m_pCodecContext->channels > 4 && size)
+  if (m_bFirstFrame)
   {
-    unsigned int m_frameSize = (CAEUtil::DataFormatToBits(AE_FMT_S16LE) >> 3) * m_pCodecContext->channels;
-    unsigned int frames = size / m_frameSize;
-
-    memset(m_pBufferUpmix, 0, MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
-
-    Upmix(src, m_pCodecContext->channels, m_pBufferUpmix, 8, frames, AE_FMT_S16LE);
-
-    m_iBufferUpmixSize = frames * 8 * (CAEUtil::DataFormatToBits(AE_FMT_S16LE) >> 3);
-
-    *dst = m_pBufferUpmix;
-    size = m_iBufferUpmixSize;
+    CLog::Log(LOGDEBUG, "COMXAudioCodecOMX::GetData size=%d/%d/%d cont=%d buf=%p", m_iBufferSize1, m_iBufferSize2, size, contiguous, *dst);
+     m_bFirstFrame = false;
   }
-
   return size;
 }
 
@@ -295,24 +300,30 @@ void COMXAudioCodecOMX::Reset()
 
 int COMXAudioCodecOMX::GetChannels()
 {
-  return (m_pCodecContext->channels > 4) ? 8 : m_pCodecContext->channels;
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->channels;
 }
 
 int COMXAudioCodecOMX::GetSampleRate()
 {
-  if (m_pCodecContext) return m_pCodecContext->sample_rate;
-  return 0;
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->sample_rate;
 }
 
 int COMXAudioCodecOMX::GetBitsPerSample()
 {
-  return 16;
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->sample_fmt == AV_SAMPLE_FMT_S16 ? 16 : 32;
 }
 
 int COMXAudioCodecOMX::GetBitRate()
 {
-  if (m_pCodecContext) return m_pCodecContext->bit_rate;
-  return 0;
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->bit_rate;
 }
 
 static unsigned count_bits(int64_t value)
@@ -323,16 +334,9 @@ static unsigned count_bits(int64_t value)
   return bits;
 }
 
-void COMXAudioCodecOMX::BuildChannelMap()
+uint64_t COMXAudioCodecOMX::GetChannelMap()
 {
-  if (m_channels == m_pCodecContext->channels && m_layout == m_pCodecContext->channel_layout)
-    return; //nothing to do here
-
-  m_channels = m_pCodecContext->channels;
-  m_layout   = m_pCodecContext->channel_layout;
-
-  int64_t layout;
-
+  uint64_t layout;
   int bits = count_bits(m_pCodecContext->channel_layout);
   if (bits == m_pCodecContext->channels)
     layout = m_pCodecContext->channel_layout;
@@ -341,38 +345,5 @@ void COMXAudioCodecOMX::BuildChannelMap()
     CLog::Log(LOGINFO, "COMXAudioCodecOMX::GetChannelMap - FFmpeg reported %d channels, but the layout contains %d ignoring", m_pCodecContext->channels, bits);
     layout = m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels);
   }
-
-  m_channelLayout.Reset();
-
-  if (layout & AV_CH_FRONT_LEFT           ) m_channelLayout += AE_CH_FL  ;
-  if (layout & AV_CH_FRONT_RIGHT          ) m_channelLayout += AE_CH_FR  ;
-  if (layout & AV_CH_FRONT_CENTER         ) m_channelLayout += AE_CH_FC  ;
-  if (layout & AV_CH_LOW_FREQUENCY        ) m_channelLayout += AE_CH_LFE ;
-  if (layout & AV_CH_BACK_LEFT            ) m_channelLayout += AE_CH_BL  ;
-  if (layout & AV_CH_BACK_RIGHT           ) m_channelLayout += AE_CH_BR  ;
-  if (layout & AV_CH_FRONT_LEFT_OF_CENTER ) m_channelLayout += AE_CH_FLOC;
-  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER) m_channelLayout += AE_CH_FROC;
-  if (layout & AV_CH_BACK_CENTER          ) m_channelLayout += AE_CH_BC  ;
-  if (layout & AV_CH_SIDE_LEFT            ) m_channelLayout += AE_CH_SL  ;
-  if (layout & AV_CH_SIDE_RIGHT           ) m_channelLayout += AE_CH_SR  ;
-  if (layout & AV_CH_TOP_CENTER           ) m_channelLayout += AE_CH_TC  ;
-  if (layout & AV_CH_TOP_FRONT_LEFT       ) m_channelLayout += AE_CH_TFL ;
-  if (layout & AV_CH_TOP_FRONT_CENTER     ) m_channelLayout += AE_CH_TFC ;
-  if (layout & AV_CH_TOP_FRONT_RIGHT      ) m_channelLayout += AE_CH_TFR ;
-  if (layout & AV_CH_TOP_BACK_LEFT        ) m_channelLayout += AE_CH_BL  ;
-  if (layout & AV_CH_TOP_BACK_CENTER      ) m_channelLayout += AE_CH_BC  ;
-  if (layout & AV_CH_TOP_BACK_RIGHT       ) m_channelLayout += AE_CH_BR  ;
-
-  //terminate the channel map
-  if(m_pCodecContext->channels > 4)
-  {
-    for(int i = m_pCodecContext->channels; i < 8; i++)
-      m_channelLayout += AE_CH_RAW;
-  }
-}
-
-CAEChannelInfo COMXAudioCodecOMX::GetChannelMap()
-{
-  BuildChannelMap();
-  return m_channelLayout;
+  return layout;
 }
diff --git a/xbmc/cores/omxplayer/OMXAudioCodecOMX.h b/xbmc/cores/omxplayer/OMXAudioCodecOMX.h
index 42a4a5f..5066300 100644
--- a/xbmc/cores/omxplayer/OMXAudioCodecOMX.h
+++ b/xbmc/cores/omxplayer/OMXAudioCodecOMX.h
@@ -32,8 +32,6 @@
 class COMXAudioCodecOMX
 {
 public:
-  void Upmix(void *input, unsigned int channelsInput,  void *output,
-    unsigned int channelsOutput, unsigned int frames, AEDataFormat dataFormat);
   COMXAudioCodecOMX();
   virtual ~COMXAudioCodecOMX();
   bool Open(CDVDStreamInfo &hints);
@@ -42,7 +40,7 @@ class COMXAudioCodecOMX
   int GetData(BYTE** dst);
   void Reset();
   int GetChannels();
-  virtual CAEChannelInfo GetChannelMap();
+  uint64_t GetChannelMap();
   int GetSampleRate();
   int GetBitsPerSample();
   const char* GetName() { return "FFmpeg"; }
@@ -53,7 +51,7 @@ class COMXAudioCodecOMX
   AVCodecContext* m_pCodecContext;
   SwrContext*     m_pConvert;
   enum AVSampleFormat m_iSampleFormat;
-  CAEChannelInfo      m_channelLayout;
+  enum AVSampleFormat m_desiredSampleFormat;
 
   AVFrame* m_pFrame1;
   int   m_iBufferSize1;
@@ -68,11 +66,9 @@ class COMXAudioCodecOMX
   int m_iBuffered;
 
   int     m_channels;
-  uint64_t m_layout;
 
+  bool m_bFirstFrame;
   DllAvCodec m_dllAvCodec;
   DllAvUtil m_dllAvUtil;
   DllSwResample m_dllSwResample;
-
-  void BuildChannelMap();
 };
diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index ae84373..44d08af 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -29,96 +29,427 @@
 #include "utils/log.h"
 #include "linux/XMemUtils.h"
 
-#include "utils/BitstreamConverter.h"
-
 #include <sys/time.h>
 #include <inttypes.h>
+#include "guilib/GraphicContext.h"
+#include "settings/AdvancedSettings.h"
 #include "settings/GUISettings.h"
 #include "settings/Settings.h"
-#include "settings/AdvancedSettings.h"
+#include "linux/RBP.h"
+#include "utils/URIUtils.h"
+#include "windowing/WindowingFactory.h"
+#include "Application.h"
+
+#ifdef _DEBUG
+#define CheckError() m_result = eglGetError(); if (m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
+#else
+#define CheckError()
+#endif
+
+#define EXIF_TAG_ORIENTATION    0x0112
+
 
 #ifdef CLASSNAME
 #undef CLASSNAME
 #endif
 #define CLASSNAME "COMXImage"
 
-#define CONTENTURI_MAXLEN 256
+COMXImage::COMXImage()
+: CThread("CRBPWorker")
+{
+}
 
-#define EXIF_TAG_ORIENTATION    0x0112
+COMXImage::~COMXImage()
+{
+  Deinitialize();
+}
 
-static CCriticalSection g_OMXSection;
+void COMXImage::Initialize()
+{
+  Create();
+}
 
-COMXImage::COMXImage()
+void COMXImage::Deinitialize()
 {
-  m_is_open       = false;
-  m_image_size    = 0;
-  m_image_buffer  = NULL;
-  m_progressive   = false;
-  m_alpha         = false;
-  m_orientation   = 0;
-  m_width         = 0;
-  m_height        = 0;
+  // wake up thread so it can quit
+  {
+    CSingleLock lock(m_texqueue_lock);
+    m_bStop = true;
+    m_texqueue_cond.notifyAll();
+  }
+  if (IsRunning())
+    StopThread();
+}
 
-  m_is_open       = false;
-  m_decoded_buffer = NULL;
-  m_encoded_buffer = NULL;
+bool COMXImage::CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
+      unsigned int format, unsigned int pitch, const CStdString& destFile)
+{
+  COMXImageEnc omxImageEnc;
+  bool ret = omxImageEnc.CreateThumbnailFromSurface(buffer, width, height, format, pitch, destFile);
+  if (!ret)
+    CLog::Log(LOGNOTICE, "%s: unable to create thumbnail %s %dx%d", __func__, destFile.c_str(), width, height);
+  return ret;
+}
 
-  m_decoder_open  = false;
-  m_encoder_open  = false;
+COMXImageFile *COMXImage::LoadJpeg(const CStdString& texturePath)
+{
+  COMXImageFile *file = new COMXImageFile();
+  if (!file->ReadFile(texturePath))
+  {
+    CLog::Log(LOGNOTICE, "%s: unable to load %s", __func__, texturePath.c_str());
+    delete file;
+    file = NULL;
+  }
+  return file;
+}
 
-  OMX_INIT_STRUCTURE(m_decoded_format);
-  OMX_INIT_STRUCTURE(m_encoded_format);
-  memset(&m_omx_image, 0x0, sizeof(OMX_IMAGE_PORTDEFINITIONTYPE));
+void COMXImage::CloseJpeg(COMXImageFile *file)
+{
+  delete file;
 }
 
-COMXImage::~COMXImage()
+bool COMXImage::DecodeJpeg(COMXImageFile *file, unsigned int width, unsigned int height, unsigned int stride, void *pixels)
 {
-  Close();
+  bool ret = false;
+  COMXImageDec omx_image;
+  if (omx_image.Decode(file->GetImageBuffer(), file->GetImageSize(), width, height, stride, pixels))
+  {
+    assert(width  == omx_image.GetDecodedWidth());
+    assert(height == omx_image.GetDecodedHeight());
+    assert(stride == omx_image.GetDecodedStride());
+    ret = true;
+  }
+  else
+    CLog::Log(LOGNOTICE, "%s: unable to decode %s %dx%d", __func__, file->GetFilename(), width, height);
+  omx_image.Close();
+  return ret;
 }
 
-void COMXImage::Close()
+bool COMXImage::ClampLimits(unsigned int &width, unsigned int &height, unsigned int m_width, unsigned int m_height, bool transposed)
 {
-  CSingleLock lock(g_OMXSection);
+  RESOLUTION_INFO& res_info =  g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()];
+  unsigned int max_width = width;
+  unsigned int max_height = height;
+  const unsigned int gui_width = transposed ? res_info.iHeight:res_info.iWidth;
+  const unsigned int gui_height = transposed ? res_info.iWidth:res_info.iHeight;
+  const float aspect = (float)m_width / m_height;
+  bool clamped = false;
 
-  OMX_INIT_STRUCTURE(m_decoded_format);
-  OMX_INIT_STRUCTURE(m_encoded_format);
-  memset(&m_omx_image, 0x0, sizeof(OMX_IMAGE_PORTDEFINITIONTYPE));
+  if (max_width == 0 || max_height == 0)
+  {
+    max_height = g_advancedSettings.m_imageRes;
 
-  if(m_image_buffer)
-    free(m_image_buffer);
+    if (g_advancedSettings.m_fanartRes > g_advancedSettings.m_imageRes)
+    { // 16x9 images larger than the fanart res use that rather than the image res
+      if (fabsf(aspect / (16.0f/9.0f) - 1.0f) <= 0.01f && m_height >= g_advancedSettings.m_fanartRes)
+      {
+        max_height = g_advancedSettings.m_fanartRes;
+      }
+    }
+    max_width = max_height * 16/9;
+  }
 
-  m_image_buffer  = NULL;
-  m_image_size    = 0;
-  m_width         = 0;
-  m_height        = 0;
-  m_is_open       = false;
-  m_progressive   = false;
-  m_orientation   = 0;
-  m_decoded_buffer = NULL;
-  m_encoded_buffer = NULL;
+  if (gui_width)
+    max_width = min(max_width, gui_width);
+  if (gui_height)
+    max_height = min(max_height, gui_height);
+
+  max_width  = min(max_width, 2048U);
+  max_height = min(max_height, 2048U);
 
-  if(m_decoder_open)
+  width = m_width;
+  height = m_height;
+  if (width > max_width || height > max_height)
   {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-    m_omx_resize.FlushOutput();
-    m_omx_resize.FreeOutputBuffers();
+    if ((unsigned int)(max_width / aspect + 0.5f) > max_height)
+      max_width = (unsigned int)(max_height * aspect + 0.5f);
+    else
+      max_height = (unsigned int)(max_width / aspect + 0.5f);
+    width = max_width;
+    height = max_height;
+    clamped = true;
+  }
 
-    m_omx_tunnel_decode.Flush();
-    m_omx_tunnel_decode.Flush();
-    m_omx_tunnel_decode.Deestablish();
-    m_omx_decoder.Deinitialize();
-    m_omx_resize.Deinitialize();
-    m_decoder_open = false;
+  return clamped;
+}
+
+bool COMXImage::CreateThumb(const CStdString& srcFile, unsigned int maxHeight, unsigned int maxWidth, std::string &additional_info, const CStdString& destFile)
+{
+  bool okay = false;
+  COMXImageFile file;
+  COMXImageReEnc reenc;
+  void *pDestBuffer;
+  unsigned int nDestSize;
+  if ((URIUtils::GetExtension(srcFile).Equals(".jpg") || URIUtils::GetExtension(srcFile).Equals(".tbn")) &&
+      file.ReadFile(srcFile) && reenc.ReEncode(file, maxWidth, maxHeight, pDestBuffer, nDestSize))
+  {
+    XFILE::CFile outfile;
+    if (outfile.OpenForWrite(destFile, true))
+    {
+      outfile.Write(pDestBuffer, nDestSize);
+      outfile.Close();
+      okay = true;
+    }
+    else
+      CLog::Log(LOGERROR, "%s: can't open output file: %s\n", __func__, destFile.c_str());
   }
+  return okay;
+}
+
+void COMXImage::AllocTextureInternal(struct textureinfo *tex)
+{
+  glGenTextures(1, (GLuint*) &tex->texture);
+  glBindTexture(GL_TEXTURE_2D, tex->texture);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, tex->width, tex->height, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, 0);
+  tex->egl_image = eglCreateImageKHR(m_egl_display, m_egl_context, EGL_GL_TEXTURE_2D_KHR, (EGLClientBuffer)tex->texture, NULL);
+  tex->sync.Set();
+  GLint m_result;
+  CheckError();
+}
 
-  if(m_encoder_open)
+void COMXImage::GetTexture(void *userdata, GLuint *texture)
+{
+  struct textureinfo *tex = static_cast<struct textureinfo *>(userdata);
+  *texture = tex->texture;
+}
+
+void COMXImage::DestroyTextureInternal(struct textureinfo *tex)
+{
+  bool s = true;
+  if (!tex->egl_image || !tex->texture)
   {
-    m_omx_encoder.Deinitialize();
-    m_encoder_open = false;
+    CLog::Log(LOGNOTICE, "%s: Invalid image/texture %p:%d", __func__, tex->egl_image, tex->texture);
+    return;
   }
+  s = eglDestroyImageKHR(m_egl_display, tex->egl_image);
+  if (!s)
+    CLog::Log(LOGNOTICE, "%s: failed to destroy texture", __func__);
+  glDeleteTextures(1, (GLuint*) &tex->texture);
+  tex->sync.Set();
+}
 
-  m_pFile.Close();
+void COMXImage::DestroyTexture(void *userdata)
+{
+  struct textureinfo *tex = static_cast<struct textureinfo *>(userdata);
+  // we can only call gl functions from the application thread
+
+  tex->action = TEXTURE_DELETE;
+  tex->sync.Reset();
+  if ( g_application.IsCurrentThread() )
+  {
+     DestroyTextureInternal(tex);
+  }
+  else
+  {
+    CSingleLock lock(m_texqueue_lock);
+    m_texqueue.push(tex);
+    m_texqueue_cond.notifyAll();
+  }
+  // wait for function to have finished (in texture thread)
+  tex->sync.Wait();
+  delete tex;
+}
+
+bool COMXImage::DecodeJpegToTexture(COMXImageFile *file, unsigned int width, unsigned int height, void **userdata)
+{
+  bool ret = false;
+  COMXTexture omx_image;
+
+  struct textureinfo *tex = new struct textureinfo;
+  if (!tex)
+    return NULL;
+
+  tex->parent = (void *)this;
+  tex->width = width;
+  tex->height = height;
+  tex->texture = 0;
+  tex->egl_image = NULL;
+  tex->filename = file->GetFilename();
+  tex->action = TEXTURE_ALLOC;
+  tex->sync.Reset();
+
+  {
+    CSingleLock lock(m_texqueue_lock);
+    m_texqueue.push(tex);
+    m_texqueue_cond.notifyAll();
+  }
+
+  // wait for function to have finished (in texture thread)
+  tex->sync.Wait();
+
+  if (tex->egl_image && tex->texture && omx_image.Decode(file->GetImageBuffer(), file->GetImageSize(), width, height, tex->egl_image, m_egl_display))
+  {
+    ret = true;
+    *userdata = tex;
+  }
+  else
+  {
+    CLog::Log(LOGNOTICE, "%s: unable to decode to texture %s %dx%d", __func__, file->GetFilename(), width, height);
+    DestroyTexture(tex);
+  }
+  return ret;
+}
+
+static bool ChooseConfig(EGLDisplay display, const EGLint *configAttrs, EGLConfig *config)
+{
+  EGLBoolean eglStatus = true;
+  EGLint     configCount = 0;
+  EGLConfig* configList = NULL;
+  GLint m_result;
+  // Find out how many configurations suit our needs
+  eglStatus = eglChooseConfig(display, configAttrs, NULL, 0, &configCount);
+  CheckError();
+
+  if (!eglStatus || !configCount)
+  {
+    CLog::Log(LOGERROR, "EGL failed to return any matching configurations: %i", configCount);
+    return false;
+  }
+
+  // Allocate room for the list of matching configurations
+  configList = (EGLConfig*)malloc(configCount * sizeof(EGLConfig));
+  if (!configList)
+  {
+    CLog::Log(LOGERROR, "EGL failure obtaining configuration list");
+    return false;
+  }
+
+  // Obtain the configuration list from EGL
+  eglStatus = eglChooseConfig(display, configAttrs, configList, configCount, &configCount);
+  CheckError();
+  if (!eglStatus || !configCount)
+  {
+    CLog::Log(LOGERROR, "EGL failed to populate configuration list: %d", eglStatus);
+    return false;
+  }
+
+  // Select an EGL configuration that matches the native window
+  *config = configList[0];
+
+  free(configList);
+  return true;
+}
+
+void COMXImage::CreateContext()
+{
+  EGLConfig egl_config;
+  GLint m_result;
+
+  m_egl_display = g_Windowing.GetEGLDisplay();
+  eglInitialize(m_egl_display, NULL, NULL);
+  CheckError();
+  eglBindAPI(EGL_OPENGL_ES_API);
+  CheckError();
+  static const EGLint contextAttrs [] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
+  static const EGLint configAttrs [] = {
+        EGL_RED_SIZE,        8,
+        EGL_GREEN_SIZE,      8,
+        EGL_BLUE_SIZE,       8,
+        EGL_ALPHA_SIZE,      8,
+        EGL_DEPTH_SIZE,     16,
+        EGL_STENCIL_SIZE,    0,
+        EGL_SAMPLE_BUFFERS,  0,
+        EGL_SAMPLES,         0,
+        EGL_SURFACE_TYPE,    EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_NONE
+  };
+  bool s = ChooseConfig(m_egl_display, configAttrs, &egl_config);
+  CheckError();
+  if (!s)
+  {
+    CLog::Log(LOGERROR, "%s: Could not find a compatible configuration",__FUNCTION__);
+    return;
+  }
+  m_egl_context = eglCreateContext(m_egl_display, egl_config, g_Windowing.GetEGLContext(), contextAttrs);
+  CheckError();
+  if (m_egl_context == EGL_NO_CONTEXT)
+  {
+    CLog::Log(LOGERROR, "%s: Could not create a context",__FUNCTION__);
+    return;
+  }
+  EGLSurface egl_surface = eglCreatePbufferSurface(m_egl_display, egl_config, NULL);
+  CheckError();
+  if (egl_surface == EGL_NO_SURFACE)
+  {
+    CLog::Log(LOGERROR, "%s: Could not create a surface",__FUNCTION__);
+    return;
+  }
+  s = eglMakeCurrent(m_egl_display, egl_surface, egl_surface, m_egl_context);
+  CheckError();
+  if (!s)
+  {
+    CLog::Log(LOGERROR, "%s: Could not make current",__FUNCTION__);
+    return;
+  }
+}
+
+void COMXImage::Process()
+{
+  bool firsttime = true;
+
+  while(!m_bStop)
+  {
+    struct textureinfo *tex = NULL;
+    while (!m_bStop)
+    {
+      CSingleLock lock(m_texqueue_lock);
+      if (!m_texqueue.empty())
+      {
+        tex = m_texqueue.front();
+        m_texqueue.pop();
+        break;
+      }
+      m_texqueue_cond.wait(lock);
+    }
+
+    if (m_bStop)
+      return;
+
+    if (firsttime)
+      CreateContext();
+    firsttime = false;
+
+    if (tex && tex->action == TEXTURE_ALLOC)
+      AllocTextureInternal(tex);
+    else if (tex && tex->action == TEXTURE_DELETE)
+      DestroyTextureInternal(tex);
+    else
+      CLog::Log(LOGERROR, "%s: Unexpected texture job: %p:%d", __func__, tex, tex ? tex->action : 0);
+  }
+}
+
+void COMXImage::OnStartup()
+{
+}
+
+void COMXImage::OnExit()
+{
+}
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXImageFile"
+
+COMXImageFile::COMXImageFile()
+{
+  m_image_size    = 0;
+  m_image_buffer  = NULL;
+  m_orientation   = 0;
+  m_width         = 0;
+  m_height        = 0;
+  m_filename      = "";
+}
+
+COMXImageFile::~COMXImageFile()
+{
+  if(m_image_buffer)
+    free(m_image_buffer);
 }
 
 typedef enum {      /* JPEG marker codes */
@@ -195,45 +526,59 @@ typedef enum {      /* JPEG marker codes */
   M_TEM   = 0x01,
 } JPEG_MARKER;
 
-OMX_IMAGE_CODINGTYPE COMXImage::GetCodingType()
+static uint8_t inline READ8(uint8_t * &p)
 {
-  memset(&m_omx_image, 0x0, sizeof(OMX_IMAGE_PORTDEFINITIONTYPE));
-  m_width         = 0;
-  m_height        = 0;
-  m_progressive   = false;
-  m_orientation   = 0;
+  uint8_t r = p[0];
+  p += 1;
+  return r;
+}
+
+static uint16_t inline READ16(uint8_t * &p)
+{
+  uint16_t r = (p[0] << 8) | p[1];
+  p += 2;
+  return r;
+}
+
+static uint32_t inline READ32(uint8_t * &p)
+{
+  uint32_t r = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
+  p += 4;
+  return r;
+}
+
+static void inline SKIPN(uint8_t * &p, unsigned int n)
+{
+  p += n;
+}
 
-  m_omx_image.eCompressionFormat = OMX_IMAGE_CodingMax;
+OMX_IMAGE_CODINGTYPE COMXImageFile::GetCodingType(unsigned int &width, unsigned int &height)
+{
+  OMX_IMAGE_CODINGTYPE eCompressionFormat = OMX_IMAGE_CodingMax;
+  bool progressive = false;
+  int components = 0;
+  m_orientation   = 0;
 
   if(!m_image_size)
     return OMX_IMAGE_CodingMax;
 
-  bits_reader_t br;
-  CBitstreamConverter::bits_reader_set( &br, m_image_buffer, m_image_size );
+  uint8_t *p = m_image_buffer;
+  uint8_t *q = m_image_buffer + m_image_size;
 
   /* JPEG Header */
-  if(CBitstreamConverter::read_bits(&br, 16) == 0xFFD8)
+  if(READ16(p) == 0xFFD8)
   {
-    m_omx_image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+    eCompressionFormat = OMX_IMAGE_CodingJPEG;
 
-    CBitstreamConverter::read_bits(&br, 8);
-    unsigned char marker = CBitstreamConverter::read_bits(&br, 8);
+    READ8(p);
+    unsigned char marker = READ8(p);
     unsigned short block_size = 0;
     bool nMarker = false;
 
-    while(!br.oflow) {
-
+    while(p < q)
+    {
       switch(marker)
       {
-        case M_TEM:
-        case M_DRI:
-          CBitstreamConverter::skip_bits(&br, 16);
-          continue;
-        case M_SOI:
-        case M_EOI:
-          continue;
-        
-        case M_SOS:
         case M_DQT:
         case M_DNL:
         case M_DHP:
@@ -292,10 +637,11 @@ OMX_IMAGE_CODINGTYPE COMXImage::GetCodingType()
         case M_JPG13:
         case M_JPG14:
         case M_COM:
-          block_size = CBitstreamConverter::read_bits(&br, 16);
+          block_size = READ16(p);
           nMarker = true;
           break;
 
+        case M_SOS:
         default:
           nMarker = false;
           break;
@@ -310,27 +656,33 @@ OMX_IMAGE_CODINGTYPE COMXImage::GetCodingType()
       {
         if(marker == M_SOF2 || marker == M_SOF6 || marker == M_SOF10 || marker == M_SOF14)
         {
-          m_progressive = true;
+          progressive = true;
         }
-        CBitstreamConverter::skip_bits(&br, 8);
-        m_omx_image.nFrameHeight = CBitstreamConverter::read_bits(&br, 16);
-        m_omx_image.nFrameWidth = CBitstreamConverter::read_bits(&br, 16);
-        CBitstreamConverter::skip_bits(&br, 8 * (block_size - 9));
+        int readBits = 2;
+        SKIPN(p, 1);
+        readBits ++;
+        height = READ16(p);
+        readBits += 2;
+        width = READ16(p);
+        readBits += 2;
+        components = READ8(p);
+        readBits += 1;
+        SKIPN(p, 1 * (block_size - readBits));
       }
       else if(marker == M_APP1)
       {
         int readBits = 2;
-        bool bMotorolla = false;
-        bool bError = false;
 
         // Exif header
-        if(CBitstreamConverter::read_bits(&br, 32) == 0x45786966)
+        if(READ32(p) == 0x45786966)
         {
-          CBitstreamConverter::skip_bits(&br, 8 * 2);
+          bool bMotorolla = false;
+          bool bError = false;
+          SKIPN(p, 1 * 2);
           readBits += 2;
         
-          char o1 = CBitstreamConverter::read_bits(&br, 8);
-          char o2 = CBitstreamConverter::read_bits(&br, 8);
+          char o1 = READ8(p);
+          char o2 = READ8(p);
           readBits += 2;
 
           /* Discover byte order */
@@ -341,7 +693,7 @@ OMX_IMAGE_CODINGTYPE COMXImage::GetCodingType()
           else
             bError = true;
         
-          CBitstreamConverter::skip_bits(&br, 8 * 2);
+          SKIPN(p, 1 * 2);
           readBits += 2;
 
           if(!bError)
@@ -351,61 +703,61 @@ OMX_IMAGE_CODINGTYPE COMXImage::GetCodingType()
             // Get first IFD offset (offset to IFD0)
             if(bMotorolla)
             {
-              CBitstreamConverter::skip_bits(&br, 8 * 2);
+              SKIPN(p, 1 * 2);
               readBits += 2;
 
-              a = CBitstreamConverter::read_bits(&br, 8);
-              b = CBitstreamConverter::read_bits(&br, 8);
+              a = READ8(p);
+              b = READ8(p);
               readBits += 2;
               offset = (a << 8) + b;
             }
             else
             {
-              a = CBitstreamConverter::read_bits(&br, 8);
-              b = CBitstreamConverter::read_bits(&br, 8);
+              a = READ8(p);
+              b = READ8(p);
               readBits += 2;
               offset = (b << 8) + a;
 
-              CBitstreamConverter::skip_bits(&br, 8 * 2);
+              SKIPN(p, 1 * 2);
               readBits += 2;
             }
 
             offset -= 8;
             if(offset > 0)
             {
-              CBitstreamConverter::skip_bits(&br, 8 * offset);
+              SKIPN(p, 1 * offset);
               readBits += offset;
             } 
 
             // Get the number of directory entries contained in this IFD
             if(bMotorolla)
             {
-              a = CBitstreamConverter::read_bits(&br, 8);
-              b = CBitstreamConverter::read_bits(&br, 8);
+              a = READ8(p);
+              b = READ8(p);
               numberOfTags = (a << 8) + b;
             }
             else
             {
-              a = CBitstreamConverter::read_bits(&br, 8);
-              b = CBitstreamConverter::read_bits(&br, 8);
+              a = READ8(p);
+              b = READ8(p);
               numberOfTags = (b << 8) + a;
             }
             readBits += 2;
 
-            while(numberOfTags && !br.oflow)
+            while(numberOfTags && p < q)
             {
               // Get Tag number
               if(bMotorolla)
               {
-                a = CBitstreamConverter::read_bits(&br, 8);
-                b = CBitstreamConverter::read_bits(&br, 8);
+                a = READ8(p);
+                b = READ8(p);
                 tagNumber = (a << 8) + b;
                 readBits += 2;
               }
               else
               {
-                a = CBitstreamConverter::read_bits(&br, 8);
-                b = CBitstreamConverter::read_bits(&br, 8);
+                a = READ8(p);
+                b = READ8(p);
                 tagNumber = (b << 8) + a;
                 readBits += 2;
               }
@@ -415,27 +767,27 @@ OMX_IMAGE_CODINGTYPE COMXImage::GetCodingType()
               {
                 if(bMotorolla)
                 {
-                  CBitstreamConverter::skip_bits(&br, 8 * 7);
+                  SKIPN(p, 1 * 7);
                   readBits += 7;
-                  m_orientation = CBitstreamConverter::read_bits(&br, 8);
+                  m_orientation = READ8(p);
                   readBits += 1;
-                  CBitstreamConverter::skip_bits(&br, 8 * 2);
+                  SKIPN(p, 1 * 2);
                   readBits += 2;
                 }
                 else
                 {
-                  CBitstreamConverter::skip_bits(&br, 8 * 6);
+                  SKIPN(p, 1 * 6);
                   readBits += 6;
-                  m_orientation = CBitstreamConverter::read_bits(&br, 8);
+                  m_orientation = READ8(p);
                   readBits += 1;
-                  CBitstreamConverter::skip_bits(&br, 8 * 3);
+                  SKIPN(p, 1 * 3);
                   readBits += 3;
                 }
                 break;
               }
               else
               {
-                CBitstreamConverter::skip_bits(&br, 8 * 10);
+                SKIPN(p, 1 * 10);
                 readBits += 10;
               }
               numberOfTags--;
@@ -443,100 +795,51 @@ OMX_IMAGE_CODINGTYPE COMXImage::GetCodingType()
           }
         }
         readBits += 4;
-        CBitstreamConverter::skip_bits(&br, 8 * (block_size - readBits));
+        SKIPN(p, 1 * (block_size - readBits));
       }
       else
       {
-        CBitstreamConverter::skip_bits(&br, 8 * (block_size - 2));
+        SKIPN(p, 1 * (block_size - 2));
       }
 
-      CBitstreamConverter::read_bits(&br, 8);
-      marker = CBitstreamConverter::read_bits(&br, 8);
+      READ8(p);
+      marker = READ8(p);
 
     }
-
   }
 
-  CBitstreamConverter::bits_reader_set( &br, m_image_buffer, m_image_size );
+  if(m_orientation > 8)
+    m_orientation = 0;
 
-  /* PNG Header */
-  if(CBitstreamConverter::read_bits(&br, 32) == 0x89504E47)
+  if(eCompressionFormat == OMX_IMAGE_CodingMax)
   {
-    m_omx_image.eCompressionFormat = OMX_IMAGE_CodingPNG;
-    CBitstreamConverter::skip_bits(&br, 32 * 2);
-    if(CBitstreamConverter::read_bits(&br, 32) == 0x49484452)
-    {
-      m_omx_image.nFrameWidth = CBitstreamConverter::read_bits(&br, 32);
-      m_omx_image.nFrameHeight = CBitstreamConverter::read_bits(&br, 32);
-      (void)CBitstreamConverter::read_bits(&br, 8); // bit depth
-      unsigned int coding_type = CBitstreamConverter::read_bits(&br, 8);
-      m_alpha = coding_type==4 || coding_type==6;
-    }
+    CLog::Log(LOGERROR, "%s::%s error unsupported image format\n", CLASSNAME, __func__);
   }
 
-  if(m_orientation > 8)
-    m_orientation = 0;
+  if(progressive)
+  {
+    CLog::Log(LOGWARNING, "%s::%s progressive images not supported by decoder\n", CLASSNAME, __func__);
+    eCompressionFormat = OMX_IMAGE_CodingMax;
+  }
 
-  m_width  = m_omx_image.nFrameWidth;
-  m_height = m_omx_image.nFrameHeight;
+  if(components > 3)
+  {
+    CLog::Log(LOGWARNING, "%s::%s Only YUV images are supported by decoder\n", CLASSNAME, __func__);
+    eCompressionFormat = OMX_IMAGE_CodingMax;
+  }
 
-  return m_omx_image.eCompressionFormat;
+  return eCompressionFormat;
 }
 
-bool COMXImage::ClampLimits(unsigned int &width, unsigned int &height)
-{
-  RESOLUTION_INFO& res_info =  g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()];
-  const bool transposed = m_orientation & 4;
-  unsigned int max_width = width;
-  unsigned int max_height = height;
-  const unsigned int gui_width  = transposed ? res_info.iHeight:res_info.iWidth;
-  const unsigned int gui_height = transposed ? res_info.iWidth:res_info.iHeight;
-  const float aspect = (float)m_width / m_height;
 
-  if (max_width == 0 || max_height == 0)
+bool COMXImageFile::ReadFile(const CStdString& inputFile)
+{
+  XFILE::CFile      m_pFile;
+  m_filename = inputFile.c_str();
+  if(!m_pFile.Open(inputFile, 0))
   {
-    max_height = g_advancedSettings.m_imageRes;
-
-    if (g_advancedSettings.m_fanartRes > g_advancedSettings.m_imageRes)
-    { // 16x9 images larger than the fanart res use that rather than the image res
-      if (fabsf(aspect / (16.0f/9.0f) - 1.0f) <= 0.01f && m_height >= g_advancedSettings.m_fanartRes)
-      {
-        max_height = g_advancedSettings.m_fanartRes;
-      }
-    }
-    max_width = max_height * 16/9;
-  }
-
-  if (gui_width)
-    max_width = min(max_width, gui_width);
-  if (gui_height)
-    max_height = min(max_height, gui_height);
-
-  max_width  = min(max_width, 2048U);
-  max_height = min(max_height, 2048U);
-
-
-  width = m_width;
-  height = m_height;
-  if (width > max_width || height > max_height)
-  {
-    if ((unsigned int)(max_width / aspect + 0.5f) > max_height)
-      max_width = (unsigned int)(max_height * aspect + 0.5f);
-    else
-      max_height = (unsigned int)(max_width / aspect + 0.5f);
-    width = max_width;
-    height = max_height;
-    return true;
-  }
-  return false;
-}
-
-bool COMXImage::ReadFile(const CStdString& inputFile)
-{
-  if(!m_pFile.Open(inputFile, 0))
-  {
-    CLog::Log(LOGERROR, "%s::%s %s not found\n", CLASSNAME, __func__, inputFile.c_str());
-    return false;
+    CLog::Log(LOGERROR, "%s::%s %s not found\n", CLASSNAME, __func__, inputFile.c_str());
+    return false;
   }
 
   if(m_image_buffer)
@@ -545,34 +848,79 @@ bool COMXImage::ReadFile(const CStdString& inputFile)
 
   m_image_size = m_pFile.GetLength();
 
-  if(!m_image_size) {
+  if(!m_image_size)
+  {
     CLog::Log(LOGERROR, "%s::%s %s m_image_size zero\n", CLASSNAME, __func__, inputFile.c_str());
     return false;
   }
   m_image_buffer = (uint8_t *)malloc(m_image_size);
-  if(!m_image_buffer) {
+  if(!m_image_buffer)
+  {
     CLog::Log(LOGERROR, "%s::%s %s m_image_buffer null (%lu)\n", CLASSNAME, __func__, inputFile.c_str(), m_image_size);
     return false;
   }
   
   m_pFile.Read(m_image_buffer, m_image_size);
+  m_pFile.Close();
 
-  if(GetCodingType() != OMX_IMAGE_CodingJPEG) {
-    CLog::Log(LOGERROR, "%s::%s %s GetCodingType=0x%x\n", CLASSNAME, __func__, inputFile.c_str(), GetCodingType());
+  OMX_IMAGE_CODINGTYPE eCompressionFormat = GetCodingType(m_width, m_height);
+  if(eCompressionFormat != OMX_IMAGE_CodingJPEG)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s GetCodingType=0x%x\n", CLASSNAME, __func__, inputFile.c_str(), eCompressionFormat);
     return false;
   }
 
-  if(m_width < 1 || m_height < 1) {
+  if(m_width < 1 || m_height < 1)
+  {
     CLog::Log(LOGERROR, "%s::%s %s m_width=%d m_height=%d\n", CLASSNAME, __func__, inputFile.c_str(), m_width, m_height);
     return false;
   }
 
-  m_is_open = true;
-
   return true;
 }
 
-bool COMXImage::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height)
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXImageDec"
+
+COMXImageDec::COMXImageDec()
+{
+  m_decoded_buffer = NULL;
+  OMX_INIT_STRUCTURE(m_decoded_format);
+}
+
+COMXImageDec::~COMXImageDec()
+{
+  Close();
+
+  OMX_INIT_STRUCTURE(m_decoded_format);
+  m_decoded_buffer = NULL;
+}
+
+void COMXImageDec::Close()
+{
+  CSingleLock lock(m_OMXSection);
+
+  if(m_omx_decoder.IsInitialized())
+  {
+    m_omx_decoder.FlushInput();
+    m_omx_decoder.FreeInputBuffers();
+  }
+  if(m_omx_resize.IsInitialized())
+  {
+    m_omx_resize.FlushOutput();
+    m_omx_resize.FreeOutputBuffers();
+  }
+  if(m_omx_tunnel_decode.IsInitialized())
+    m_omx_tunnel_decode.Deestablish();
+  if(m_omx_decoder.IsInitialized())
+    m_omx_decoder.Deinitialize();
+  if(m_omx_resize.IsInitialized())
+    m_omx_resize.Deinitialize();
+}
+
+bool COMXImageDec::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, unsigned int resize_stride)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   // on the first port settings changed event, we create the tunnel and alloc the buffer
@@ -583,12 +931,15 @@ bool COMXImage::HandlePortSettingChange(unsigned int resize_width, unsigned int
 
     port_def.nPortIndex = m_omx_decoder.GetOutputPort();
     m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    port_def.format.image.nSliceHeight = 16;
+    m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+
     port_def.nPortIndex = m_omx_resize.GetInputPort();
     m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
 
     m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
 
-    omx_err = m_omx_tunnel_decode.Establish(false);
+    omx_err = m_omx_tunnel_decode.Establish();
     if(omx_err != OMX_ErrorNone)
     {
       CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish\n", CLASSNAME, __func__);
@@ -609,7 +960,7 @@ bool COMXImage::HandlePortSettingChange(unsigned int resize_width, unsigned int
     port_def.format.image.eColorFormat = OMX_COLOR_Format32bitARGB8888;
     port_def.format.image.nFrameWidth = resize_width;
     port_def.format.image.nFrameHeight = resize_height;
-    port_def.format.image.nStride = resize_width*4;
+    port_def.format.image.nStride = resize_stride;
     port_def.format.image.nSliceHeight = 0;
     port_def.format.image.bFlagErrorConcealment = OMX_FALSE;
 
@@ -630,7 +981,7 @@ bool COMXImage::HandlePortSettingChange(unsigned int resize_width, unsigned int
     }
     assert(m_decoded_format.nBufferCountActual == 1);
 
-    omx_err = m_omx_resize.AllocOutputBuffers();//false, true);
+    omx_err = m_omx_resize.AllocOutputBuffers();
     if(omx_err != OMX_ErrorNone)
     {
       CLog::Log(LOGERROR, "%s::%s m_omx_resize.AllocOutputBuffers result(0x%x)\n", CLASSNAME, __func__, omx_err);
@@ -686,66 +1037,50 @@ bool COMXImage::HandlePortSettingChange(unsigned int resize_width, unsigned int
   return true;
 }
 
-bool COMXImage::Decode(unsigned width, unsigned height)
+bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes, unsigned width, unsigned height, unsigned stride, void *pixels)
 {
-  CSingleLock lock(g_OMXSection);
-  std::string componentName = "";
-  unsigned int demuxer_bytes = 0;
-  const uint8_t *demuxer_content = NULL;
+  CSingleLock lock(m_OMXSection);
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
 
-  if(!m_image_buffer)
+  if(!demuxer_content || !demuxer_bytes)
   {
     CLog::Log(LOGERROR, "%s::%s no input buffer\n", CLASSNAME, __func__);
     return false;
   }
 
-  if(GetCompressionFormat() == OMX_IMAGE_CodingMax)
-  {
-    CLog::Log(LOGERROR, "%s::%s error unsupported image format\n", CLASSNAME, __func__);
-    return false;
-  }
-
-  if(IsProgressive())
+  if(!m_omx_decoder.Initialize("OMX.broadcom.image_decode", OMX_IndexParamImageInit))
   {
-    CLog::Log(LOGWARNING, "%s::%s progressive images not supported by decoder\n", CLASSNAME, __func__);
+    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.Initialize\n", CLASSNAME, __func__);
     return false;
   }
 
-  if(!m_is_open)
+  if(!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
   {
-    CLog::Log(LOGERROR, "%s::%s error not opened\n", CLASSNAME, __func__);
+    CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize\n", CLASSNAME, __func__);
     return false;
   }
 
-  componentName = "OMX.broadcom.image_decode";
-  if(!m_omx_decoder.Initialize((const std::string)componentName, OMX_IndexParamImageInit))
-  {
-    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.Initialize\n", CLASSNAME, __func__);
-    return false;
-  }
+  // set input format
+  OMX_PARAM_PORTDEFINITIONTYPE portParam;
+  OMX_INIT_STRUCTURE(portParam);
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
 
-  componentName = "OMX.broadcom.resize";
-  if(!m_omx_resize.Initialize((const std::string)componentName, OMX_IndexParamImageInit))
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize\n", CLASSNAME, __func__);
+    CLog::Log(LOGERROR, "%s::%s error GetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
     return false;
   }
 
-  m_decoder_open = true;
-  ClampLimits(width, height);
+  portParam.nBufferCountActual = portParam.nBufferCountMin;
+  portParam.nBufferSize = std::max(portParam.nBufferSize, ALIGN_UP(demuxer_bytes, portParam.nBufferAlignment));
+  portParam.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
 
-  // set input format
-  OMX_IMAGE_PARAM_PORTFORMATTYPE imagePortFormat;
-  OMX_INIT_STRUCTURE(imagePortFormat);
-  imagePortFormat.nPortIndex = m_omx_decoder.GetInputPort();
-  imagePortFormat.eCompressionFormat = OMX_IMAGE_CodingJPEG;
-
-  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamImagePortFormat, &imagePortFormat);
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &portParam);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter OMX_IndexParamImagePortFormat result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    CLog::Log(LOGERROR, "%s::%s error SetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
     return false;
   }
 
@@ -763,11 +1098,6 @@ bool COMXImage::Decode(unsigned width, unsigned height)
     return false;
   }
 
-  demuxer_bytes   = GetImageSize();
-  demuxer_content = GetImageBuffer();
-  if(!demuxer_bytes || !demuxer_content)
-    return false;
-
   while(demuxer_bytes > 0 || !m_decoded_buffer)
   {
     long timeout = 0;
@@ -795,7 +1125,7 @@ bool COMXImage::Decode(unsigned width, unsigned height)
          return false;
        }
     }
-    else
+    if (!demuxer_bytes)
     {
        // we've submitted all buffers so can wait now
        timeout = 1000;
@@ -803,41 +1133,66 @@ bool COMXImage::Decode(unsigned width, unsigned height)
     omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, timeout);
     if(omx_err == OMX_ErrorNone)
     {
-      if (!HandlePortSettingChange(width, height))
+      if (!HandlePortSettingChange(width, height, stride))
       {
         CLog::Log(LOGERROR, "%s::%s HandlePortSettingChange() failed\n", CLASSNAME, __func__);
         return false;
       }
     }
-    // we treat it as an error if a real timeout occurred
-    else  if (timeout)
+    else if(omx_err == OMX_ErrorStreamCorrupt)
+    {
+      CLog::Log(LOGERROR, "%s::%s - image not supported", CLASSNAME, __func__);
+      return false;
+    }
+    else if(timeout || omx_err != OMX_ErrorTimeout)
     {
-      CLog::Log(LOGERROR, "%s::%s HandlePortSettingChange() failed\n", CLASSNAME, __func__);
+      CLog::Log(LOGERROR, "%s::%s WaitForEvent:OMX_EventPortSettingsChanged failed (%x)\n", CLASSNAME, __func__, omx_err);
       return false;
     }
   }
 
-  omx_err = m_omx_decoder.WaitForEvent(OMX_EventBufferFlag, 1000);
+  omx_err = m_omx_resize.WaitForOutputDone(1000);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.WaitForEvent result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    CLog::Log(LOGERROR, "%s::%s m_omx_resize.WaitForOutputDone result(0x%x)\n", CLASSNAME, __func__, omx_err);
     return false;
   }
 
-  m_omx_tunnel_decode.Deestablish();
-
   if(m_omx_decoder.BadState())
     return false;
 
+  memcpy( (char*)pixels, m_decoded_buffer->pBuffer, stride * height);
+
+  Close();
   return true;
 }
 
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXImageEnc"
+
+COMXImageEnc::COMXImageEnc()
+{
+  CSingleLock lock(m_OMXSection);
+  OMX_INIT_STRUCTURE(m_encoded_format);
+  m_encoded_buffer = NULL;
+}
+
+COMXImageEnc::~COMXImageEnc()
+{
+  CSingleLock lock(m_OMXSection);
+
+  OMX_INIT_STRUCTURE(m_encoded_format);
+  m_encoded_buffer = NULL;
+  if(m_omx_encoder.IsInitialized())
+    m_omx_encoder.Deinitialize();
+}
 
-bool COMXImage::Encode(unsigned char *buffer, int size, unsigned width, unsigned height, unsigned int pitch)
+bool COMXImageEnc::Encode(unsigned char *buffer, int size, unsigned width, unsigned height, unsigned int pitch)
 {
-  CSingleLock lock(g_OMXSection);
+  CSingleLock lock(m_OMXSection);
 
-  std::string componentName = "";
   unsigned int demuxer_bytes = 0;
   const uint8_t *demuxer_content = NULL;
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
@@ -853,15 +1208,12 @@ bool COMXImage::Encode(unsigned char *buffer, int size, unsigned width, unsigned
     return false;
   }
 
-  componentName = "OMX.broadcom.image_encode";
-  if(!m_omx_encoder.Initialize((const std::string)componentName, OMX_IndexParamImageInit))
+  if(!m_omx_encoder.Initialize("OMX.broadcom.image_encode", OMX_IndexParamImageInit))
   {
     CLog::Log(LOGERROR, "%s::%s error m_omx_encoder.Initialize\n", CLASSNAME, __func__);
     return false;
   }
 
-  m_encoder_open = true;
-
   OMX_PARAM_PORTDEFINITIONTYPE port_def;
   OMX_INIT_STRUCTURE(port_def);
   port_def.nPortIndex = m_omx_encoder.GetInputPort();
@@ -991,10 +1343,10 @@ bool COMXImage::Encode(unsigned char *buffer, int size, unsigned width, unsigned
   if(omx_err != OMX_ErrorNone)
     return false;
 
-  omx_err = m_omx_encoder.WaitForEvent(OMX_EventBufferFlag, 1000);
+  omx_err = m_omx_encoder.WaitForOutputDone(1000);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s m_omx_encoder WaitForEvent result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    CLog::Log(LOGERROR, "%s::%s m_omx_resize.WaitForOutputDone result(0x%x)\n", CLASSNAME, __func__, omx_err);
     return false;
   }
 
@@ -1012,110 +1364,773 @@ bool COMXImage::Encode(unsigned char *buffer, int size, unsigned width, unsigned
   return true;
 }
 
-unsigned char *COMXImage::GetDecodedData()
+bool COMXImageEnc::CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
+    unsigned int format, unsigned int pitch, const CStdString& destFile)
 {
-  if(!m_decoded_buffer)
-    return NULL;
+  if(format != XB_FMT_A8R8G8B8 || !buffer)
+  {
+    CLog::Log(LOGDEBUG, "%s::%s : %s failed format=0x%x\n", CLASSNAME, __func__, destFile.c_str(), format);
+    return false;
+  }
 
-  return (unsigned char *)m_decoded_buffer->pBuffer;
-}
+  if(!Encode(buffer, height * pitch, width, height, pitch))
+  {
+    CLog::Log(LOGDEBUG, "%s::%s : %s encode failed\n", CLASSNAME, __func__, destFile.c_str());
+    return false;
+  }
 
-unsigned int COMXImage::GetDecodedSize()
-{
-  if(!m_decoded_buffer)
-    return 0;
-  return (unsigned int)m_decoded_buffer->nFilledLen;
+  XFILE::CFile file;
+  if (file.OpenForWrite(destFile, true))
+  {
+    CLog::Log(LOGDEBUG, "%s::%s : %s width %d height %d\n", CLASSNAME, __func__, destFile.c_str(), width, height);
+
+    file.Write(m_encoded_buffer->pBuffer, m_encoded_buffer->nFilledLen);
+    file.Close();
+    return true;
+  }
+
+  return false;
 }
 
-unsigned char *COMXImage::GetEncodedData()
-{
-  if(!m_encoded_buffer)
-    return NULL;
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXReEnc"
 
-  return (unsigned char *)m_encoded_buffer->pBuffer;
+COMXImageReEnc::COMXImageReEnc()
+{
+  m_encoded_buffer = NULL;
+  m_pDestBuffer = NULL;
+  m_nDestAllocSize = 0;
 }
 
-unsigned int COMXImage::GetEncodedSize()
+COMXImageReEnc::~COMXImageReEnc()
 {
-  if(!m_encoded_buffer)
-    return 0;
-  return (unsigned int)m_encoded_buffer->nFilledLen;
+  Close();
+  if (m_pDestBuffer)
+    free (m_pDestBuffer);
+  m_pDestBuffer = NULL;
+  m_nDestAllocSize = 0;
 }
 
-bool COMXImage::SwapBlueRed(unsigned char *pixels, unsigned int height, unsigned int pitch, 
-  unsigned int elements, unsigned int offset)
+void COMXImageReEnc::Close()
 {
-  if (!pixels) return false;
-  unsigned char *dst = pixels;
-  for (unsigned int y = 0; y < height; y++)
+  CSingleLock lock(m_OMXSection);
+
+  if(m_omx_decoder.IsInitialized())
   {
-    dst = pixels + (y * pitch);
-    for (unsigned int x = 0; x < pitch; x+=elements)
-      std::swap(dst[x+offset], dst[x+2+offset]);
+    m_omx_decoder.FlushInput();
+    m_omx_decoder.FreeInputBuffers();
   }
-  return true;
+  if(m_omx_encoder.IsInitialized())
+  {
+    m_omx_encoder.FlushOutput();
+    m_omx_encoder.FreeOutputBuffers();
+  }
+  if(m_omx_tunnel_decode.IsInitialized())
+    m_omx_tunnel_decode.Deestablish();
+  if(m_omx_tunnel_resize.IsInitialized())
+    m_omx_tunnel_resize.Deestablish();
+  if(m_omx_decoder.IsInitialized())
+    m_omx_decoder.Deinitialize();
+  if(m_omx_resize.IsInitialized())
+    m_omx_resize.Deinitialize();
+  if(m_omx_encoder.IsInitialized())
+    m_omx_encoder.Deinitialize();
 }
 
-bool COMXImage::CreateThumbnail(const CStdString& sourceFile, const CStdString& destFile, 
-    int minx, int miny, bool rotateExif)
-{
-  if (!ReadFile(sourceFile))
-    return false;
 
-  return CreateThumbnailFromMemory(m_image_buffer, m_image_size, destFile, minx, miny);
-}
 
-bool COMXImage::CreateThumbnailFromMemory(unsigned char* buffer, unsigned int bufSize, const CStdString& destFile, 
-    unsigned int minx, unsigned int miny)
+bool COMXImageReEnc::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, int orientation, bool port_settings_changed)
 {
-  if(!bufSize || !buffer)
-    return false;
-
-  if(!m_is_open)
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+  // on the first port settings changed event, we create the tunnel and alloc the buffer
+  if (!port_settings_changed)
   {
-    m_image_size = bufSize;
-    m_image_buffer = (uint8_t *)malloc(m_image_size);
-    if(!m_image_buffer)
+    OMX_PARAM_PORTDEFINITIONTYPE port_def;
+    OMX_INIT_STRUCTURE(port_def);
+
+    port_def.nPortIndex = m_omx_decoder.GetOutputPort();
+    m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_decoder.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
       return false;
+    }
 
-    memcpy(m_image_buffer, buffer, m_image_size);
+    // TODO: jpeg decoder can decimate by factors of 2
+    port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+    port_def.format.image.nSliceHeight = 16;//(port_def.format.image.nFrameHeight+15) & ~15;
+    port_def.format.image.nStride = 0;
 
-    if(GetCodingType() != OMX_IMAGE_CodingJPEG) {
-      CLog::Log(LOGERROR, "%s::%s : %s GetCodingType()=0x%x\n", CLASSNAME, __func__, destFile.c_str(), GetCodingType());
+    m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
       return false;
     }
-    m_is_open = true;
-  }
 
-  if(!Decode(minx, miny))
-    return false;
+    if(!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
+    {
+      CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize\n", CLASSNAME, __func__);
+      return false;
+    }
 
-  return CreateThumbnailFromSurface(GetDecodedData(), GetDecodedWidth(), GetDecodedHeight(), 
-    XB_FMT_A8R8G8B8, GetDecodedStride(), destFile);
-}
+    port_def.nPortIndex = m_omx_resize.GetInputPort();
 
-bool COMXImage::CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height, 
-    unsigned int format, unsigned int pitch, const CStdString& destFile)
-{
-  if(format != XB_FMT_A8R8G8B8 || !buffer) {
-    CLog::Log(LOGDEBUG, "%s::%s : %s failed format=0x%x\n", CLASSNAME, __func__, destFile.c_str(), format);
-    return false;
-  }
+    m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
 
-  if(!Encode(buffer, height * pitch, width, height, pitch)) {
-    CLog::Log(LOGDEBUG, "%s::%s : %s encode failed\n", CLASSNAME, __func__, destFile.c_str());
-    return false;
-  }
+    port_def.nPortIndex = m_omx_resize.GetOutputPort();
+    m_omx_resize.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+    port_def.format.image.nFrameWidth = resize_width;
+    port_def.format.image.nFrameHeight = resize_height;
+    port_def.format.image.nSliceHeight = (resize_height+15) & ~15;
+    port_def.format.image.nStride = 0;
+    m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
 
-  XFILE::CFile file;
-  if (file.OpenForWrite(destFile, true))
-  {
-    CLog::Log(LOGDEBUG, "%s::%s : %s width %d height %d\n", CLASSNAME, __func__, destFile.c_str(), width, height);
+    if(!m_omx_encoder.Initialize("OMX.broadcom.image_encode", OMX_IndexParamImageInit))
+    {
+      CLog::Log(LOGERROR, "%s::%s error m_omx_encoder.Initialize\n", CLASSNAME, __func__);
+      return false;
+    }
 
-    file.Write(GetEncodedData(), GetEncodedSize());
-    file.Close();
-    return true;
-  }
+    port_def.nPortIndex = m_omx_encoder.GetInputPort();
+    m_omx_encoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+    port_def.format.image.nFrameWidth = resize_width;
+    port_def.format.image.nFrameHeight = resize_height;
+    port_def.format.image.nSliceHeight = (resize_height+15) & ~15;
+    port_def.format.image.nStride = 0;
+    m_omx_encoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
 
-  return false;
-}
+    port_def.nPortIndex = m_omx_encoder.GetOutputPort();
+    omx_err = m_omx_encoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    port_def.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+    port_def.format.image.eColorFormat = OMX_COLOR_FormatUnused;
+    port_def.format.image.nFrameWidth = resize_width;
+    port_def.format.image.nFrameHeight = resize_height;
+    port_def.format.image.nStride = 0;
+    port_def.format.image.nSliceHeight = 0;
+    port_def.format.image.bFlagErrorConcealment = OMX_FALSE;
+
+    omx_err = m_omx_encoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    OMX_IMAGE_PARAM_QFACTORTYPE qfactor;
+    OMX_INIT_STRUCTURE(qfactor);
+    qfactor.nPortIndex = m_omx_encoder.GetOutputPort();
+    qfactor.nQFactor = 16;
+
+    omx_err = m_omx_encoder.SetParameter(OMX_IndexParamQFactor, &qfactor);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetParameter OMX_IndexParamQFactor result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    if (orientation)
+    {
+      struct {
+        // metadata, these two fields need to be together
+        OMX_CONFIG_METADATAITEMTYPE metadata;
+        char metadata_space[64];
+      } item;
+      OMX_INIT_STRUCTURE(item.metadata);
+
+      item.metadata.nSize = sizeof(item);
+      item.metadata.eScopeMode = OMX_MetadataScopePortLevel;
+      item.metadata.nScopeSpecifier = m_omx_encoder.GetOutputPort();
+      item.metadata.nMetadataItemIndex = 0;
+      item.metadata.eSearchMode = OMX_MetadataSearchValueSizeByIndex;
+      item.metadata.eKeyCharset = OMX_MetadataCharsetASCII;
+      strcpy((char *)item.metadata.nKey, "IFD0.Orientation");
+      item.metadata.nKeySizeUsed = strlen((char *)item.metadata.nKey);
+
+      item.metadata.eValueCharset = OMX_MetadataCharsetASCII;
+      item.metadata.sLanguageCountry = 0;
+      item.metadata.nValueMaxSize = sizeof(item.metadata_space);
+      sprintf((char *)item.metadata.nValue, "%d", orientation);
+      item.metadata.nValueSizeUsed = strlen((char *)item.metadata.nValue);
+
+      omx_err = m_omx_encoder.SetParameter(OMX_IndexConfigMetadataItem, &item);
+      if (omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetParameter:OMX_IndexConfigMetadataItem omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
+    omx_err = m_omx_encoder.AllocOutputBuffers();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.AllocOutputBuffers result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
+
+    omx_err = m_omx_tunnel_decode.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish\n", CLASSNAME, __func__);
+      return false;
+    }
+
+    m_omx_tunnel_resize.Initialize(&m_omx_resize, m_omx_resize.GetOutputPort(), &m_omx_encoder, m_omx_encoder.GetInputPort());
+
+    omx_err = m_omx_tunnel_resize.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_resize.Establish\n", CLASSNAME, __func__);
+      return false;
+    }
+
+    omx_err = m_omx_resize.SetStateForComponent(OMX_StateExecuting);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetStateForComponent result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    omx_err = m_omx_encoder.SetStateForComponent(OMX_StateExecuting);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetStateForComponent result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    if(m_omx_encoder.BadState())
+      return false;
+  }
+  // on subsequent port settings changed event, we just copy the port settings
+  else
+  {
+    // a little surprising, make a note
+    CLog::Log(LOGDEBUG, "%s::%s m_omx_resize second port changed event\n", CLASSNAME, __func__);
+    m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
+    m_omx_resize.DisablePort(m_omx_resize.GetInputPort(), true);
+
+    OMX_PARAM_PORTDEFINITIONTYPE port_def;
+    OMX_INIT_STRUCTURE(port_def);
+
+    port_def.nPortIndex = m_omx_decoder.GetOutputPort();
+    m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    port_def.nPortIndex = m_omx_resize.GetInputPort();
+    m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+
+    omx_err = m_omx_resize.WaitForEvent(OMX_EventPortSettingsChanged);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.WaitForEvent=%x\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
+    m_omx_resize.EnablePort(m_omx_resize.GetInputPort(), true);
+  }
+  return true;
+}
+
+bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, unsigned int maxHeight, void * &pDestBuffer, unsigned int &nDestSize)
+{
+  CSingleLock lock(m_OMXSection);
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+
+  COMXImage::ClampLimits(maxWidth, maxHeight, srcFile.GetWidth(), srcFile.GetHeight(), srcFile.GetOrientation() & 4);
+  unsigned int demuxer_bytes = srcFile.GetImageSize();
+  unsigned char *demuxer_content = (unsigned char *)srcFile.GetImageBuffer();
+  // initial dest buffer size
+  nDestSize = 0;
+
+  if(!demuxer_content || !demuxer_bytes)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s no input buffer\n", CLASSNAME, __func__, srcFile.GetFilename());
+    return false;
+  }
+
+  if(!m_omx_decoder.Initialize("OMX.broadcom.image_decode", OMX_IndexParamImageInit))
+  {
+    CLog::Log(LOGERROR, "%s::%s %s error m_omx_decoder.Initialize\n", CLASSNAME, __func__, srcFile.GetFilename());
+    return false;
+  }
+
+  // set input format
+  OMX_PARAM_PORTDEFINITIONTYPE portParam;
+  OMX_INIT_STRUCTURE(portParam);
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
+
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s error GetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+    return false;
+  }
+
+  portParam.nBufferCountActual = portParam.nBufferCountMin;
+  portParam.nBufferSize = std::max(portParam.nBufferSize, ALIGN_UP(demuxer_bytes, portParam.nBufferAlignment));
+  portParam.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s error SetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_decoder.AllocInputBuffers();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s m_omx_decoder.AllocInputBuffers result(0x%x)", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s m_omx_decoder.SetStateForComponent result(0x%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+    return false;
+  }
+
+  bool port_settings_changed = false, eos = false;
+  while(demuxer_bytes > 0 || !port_settings_changed || !eos)
+  {
+    long timeout = 0;
+    if (demuxer_bytes)
+    {
+       OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(1000);
+       if(omx_buffer)
+       {
+         omx_buffer->nOffset = omx_buffer->nFlags  = 0;
+
+         omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
+         memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
+
+         demuxer_content += omx_buffer->nFilledLen;
+         demuxer_bytes -= omx_buffer->nFilledLen;
+         if(demuxer_bytes == 0)
+           omx_buffer->nFlags |= OMX_BUFFERFLAG_EOS;
+
+         omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
+         if (omx_err != OMX_ErrorNone)
+         {
+           CLog::Log(LOGERROR, "%s::%s %s OMX_EmptyThisBuffer() failed with result(0x%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+           return false;
+         }
+      }
+    }
+    if (!demuxer_bytes)
+    {
+       // we've submitted all buffers so can wait now
+       timeout = 1000;
+    }
+
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, timeout);
+    if(omx_err == OMX_ErrorNone)
+    {
+      if (!HandlePortSettingChange(maxWidth, maxHeight, srcFile.GetOrientation(), port_settings_changed))
+      {
+        CLog::Log(LOGERROR, "%s::%s %s HandlePortSettingChange() failed\n", srcFile.GetFilename(), CLASSNAME, __func__);
+        return false;
+      }
+      port_settings_changed = true;
+    }
+    else if(omx_err == OMX_ErrorStreamCorrupt)
+    {
+      CLog::Log(LOGERROR, "%s::%s %s - image not supported", CLASSNAME, __func__, srcFile.GetFilename());
+      return false;
+    }
+    else if(timeout || omx_err != OMX_ErrorTimeout)
+    {
+      CLog::Log(LOGERROR, "%s::%s %s WaitForEvent:OMX_EventPortSettingsChanged failed (%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+      return false;
+    }
+
+    if (!m_encoded_buffer && port_settings_changed && demuxer_bytes == 0)
+    {
+      m_encoded_buffer = m_omx_encoder.GetOutputBuffer();
+      omx_err = m_omx_encoder.FillThisBuffer(m_encoded_buffer);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s %s FillThisBuffer() failed (%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+        return false;
+      }
+    }
+    if (m_encoded_buffer)
+    {
+      omx_err = m_omx_encoder.WaitForOutputDone(1000);
+      if (omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s %s m_omx_encoder.WaitForOutputDone result(0x%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+        return false;
+      }
+      if (!m_encoded_buffer->nFilledLen)
+      {
+        CLog::Log(LOGERROR, "%s::%s %s m_omx_encoder.WaitForOutputDone no data\n", CLASSNAME, __func__, srcFile.GetFilename());
+        return false;
+      }
+      if (m_encoded_buffer->nFlags & OMX_BUFFERFLAG_EOS)
+         eos = true;
+
+      if (nDestSize + m_encoded_buffer->nFilledLen > m_nDestAllocSize)
+      {
+         m_nDestAllocSize = std::max(1024U*1024U, m_nDestAllocSize*2);
+         m_pDestBuffer = realloc(m_pDestBuffer, m_nDestAllocSize);
+      }
+      memcpy((char *)m_pDestBuffer + nDestSize, m_encoded_buffer->pBuffer, m_encoded_buffer->nFilledLen);
+      nDestSize += m_encoded_buffer->nFilledLen;
+      m_encoded_buffer = NULL;
+    }
+  }
+
+  Close();
+
+  if(m_omx_decoder.BadState())
+    return false;
+
+  pDestBuffer = m_pDestBuffer;
+  CLog::Log(LOGDEBUG, "%s::%s : %s %dx%d -> %dx%d\n", CLASSNAME, __func__, srcFile.GetFilename(), srcFile.GetWidth(), srcFile.GetHeight(), maxWidth, maxHeight);
+
+  return true;
+}
+
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXTexture"
+
+COMXTexture::COMXTexture()
+{
+}
+
+COMXTexture::~COMXTexture()
+{
+  Close();
+}
+
+void COMXTexture::Close()
+{
+  CSingleLock lock(m_OMXSection);
+
+  if (m_omx_tunnel_decode.IsInitialized())
+    m_omx_tunnel_decode.Deestablish();
+  if (m_omx_tunnel_egl.IsInitialized())
+    m_omx_tunnel_egl.Deestablish();
+  // delete components
+  if (m_omx_decoder.IsInitialized())
+    m_omx_decoder.Deinitialize();
+  if (m_omx_resize.IsInitialized())
+    m_omx_resize.Deinitialize();
+  if (m_omx_egl_render.IsInitialized())
+    m_omx_egl_render.Deinitialize();
+}
+
+bool COMXTexture::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, void *egl_image, void *egl_display, bool port_settings_changed)
+{
+  OMX_ERRORTYPE omx_err;
+
+  if (port_settings_changed)
+    CLog::Log(LOGERROR, "%s::%s Unexpected second port_settings_changed call\n", CLASSNAME, __func__);
+
+  OMX_PARAM_PORTDEFINITIONTYPE port_def;
+  OMX_INIT_STRUCTURE(port_def);
+
+  port_def.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  // TODO: jpeg decoder can decimate by factors of 2
+  port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+  port_def.format.image.nSliceHeight = 16;
+  port_def.format.image.nStride = 0;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if (!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize", CLASSNAME, __func__);
+    return false;
+  }
+
+  port_def.nPortIndex = m_omx_resize.GetInputPort();
+
+  omx_err = m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  port_def.nPortIndex = m_omx_resize.GetOutputPort();
+  omx_err = m_omx_resize.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_resize.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+  port_def.format.image.nFrameWidth = resize_width;
+  port_def.format.image.nFrameHeight = resize_height;
+  port_def.format.image.nSliceHeight = 16;
+  port_def.format.image.nStride = 0;
+  omx_err = m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if (!m_omx_egl_render.Initialize("OMX.broadcom.egl_render", OMX_IndexParamVideoInit))
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.Initialize", CLASSNAME, __func__);
+    return false;
+  }
+
+  port_def.nPortIndex = m_omx_egl_render.GetOutputPort();
+  omx_err = m_omx_egl_render.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+  port_def.nBufferCountActual = 1;
+  port_def.format.video.pNativeWindow = egl_display;
+
+  omx_err = m_omx_egl_render.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_egl_render.UseEGLImage(&m_egl_buffer, m_omx_egl_render.GetOutputPort(), NULL, egl_image);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.UseEGLImage (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
+
+  omx_err = m_omx_tunnel_decode.Establish();
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  m_omx_tunnel_egl.Initialize(&m_omx_resize, m_omx_resize.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+
+  omx_err = m_omx_tunnel_egl.Establish();
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_egl.Establish (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_resize.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.GetParameter (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_egl_render.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.SetStateForComponent (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  return true;
+}
+
+bool COMXTexture::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes, unsigned int width, unsigned int height, void *egl_image, void *egl_display)
+{
+  CSingleLock lock(m_OMXSection);
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+
+  if (!demuxer_content || !demuxer_bytes)
+  {
+    CLog::Log(LOGERROR, "%s::%s no input buffer\n", CLASSNAME, __func__);
+    return false;
+  }
+
+  if (!m_omx_decoder.Initialize("OMX.broadcom.image_decode", OMX_IndexParamImageInit))
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.Initialize", CLASSNAME, __func__);
+    return false;
+  }
+
+  // set input format
+  OMX_PARAM_PORTDEFINITIONTYPE portParam;
+  OMX_INIT_STRUCTURE(portParam);
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
+
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error GetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  portParam.nBufferCountActual = portParam.nBufferCountMin;
+  portParam.nBufferSize = std::max(portParam.nBufferSize, ALIGN_UP(demuxer_bytes, portParam.nBufferAlignment));
+  portParam.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error SetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_decoder.AllocInputBuffers();
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Error alloc buffers  (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_sched.SetStateForComponent (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  bool port_settings_changed = false;
+  bool eos = false;
+  while(demuxer_bytes > 0 || !port_settings_changed || !eos)
+  {
+    long timeout = 0;
+    if (demuxer_bytes)
+    {
+      OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(1000);
+      if (omx_buffer)
+      {
+        omx_buffer->nOffset = omx_buffer->nFlags  = 0;
+
+        omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
+        memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
+
+        demuxer_content += omx_buffer->nFilledLen;
+        demuxer_bytes -= omx_buffer->nFilledLen;
+
+        if (demuxer_bytes == 0)
+          omx_buffer->nFlags |= OMX_BUFFERFLAG_EOS;
+
+        omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
+        if (omx_err != OMX_ErrorNone)
+        {
+          CLog::Log(LOGERROR, "%s::%s - m_omx_decoder.OMX_EmptyThisBuffer (%x)", CLASSNAME, __func__, omx_err);
+          return false;
+         }
+      }
+    }
+    if (!demuxer_bytes)
+    {
+       // we've submitted all buffers so can wait now
+       timeout = 1000;
+    }
+
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, timeout);
+    if (omx_err == OMX_ErrorNone)
+    {
+      if (!HandlePortSettingChange(width, height, egl_image, egl_display, port_settings_changed))
+      {
+        CLog::Log(LOGERROR, "%s::%s - HandlePortSettingChange failed (%x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      port_settings_changed = true;
+    }
+    else if (omx_err == OMX_ErrorStreamCorrupt)
+    {
+      CLog::Log(LOGERROR, "%s::%s - image not supported", CLASSNAME, __func__);
+      return false;
+    }
+    else if (timeout || omx_err != OMX_ErrorTimeout)
+    {
+      CLog::Log(LOGERROR, "%s::%s WaitForEvent:OMX_EventPortSettingsChanged failed (%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    if (port_settings_changed && m_egl_buffer && demuxer_bytes == 0 && !eos)
+    {
+      OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_egl_render.GetOutputBuffer();
+      if (!omx_buffer)
+      {
+        CLog::Log(LOGERROR, "%s::%s GetOutputBuffer failed\n", CLASSNAME, __func__);
+        return false;
+      }
+      if (omx_buffer != m_egl_buffer)
+      {
+        CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.GetOutputBuffer (%p,%p)", CLASSNAME, __func__, omx_buffer, m_egl_buffer);
+        return false;
+      }
+
+      omx_err = m_omx_egl_render.FillThisBuffer(m_egl_buffer);
+      if (omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.FillThisBuffer (%x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+
+      omx_err = m_omx_egl_render.WaitForOutputDone(1000);
+      if (omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.WaitForOutputDone result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      eos = true;
+    }
+  }
+  Close();
+  return true;
+}
+
+COMXImage g_OMXImage;
diff --git a/xbmc/cores/omxplayer/OMXImage.h b/xbmc/cores/omxplayer/OMXImage.h
index ce582bb..41104a5 100644
--- a/xbmc/cores/omxplayer/OMXImage.h
+++ b/xbmc/cores/omxplayer/OMXImage.h
@@ -34,75 +34,171 @@
 #include "guilib/XBTF.h"
 #endif
 
+#include "system_gl.h"
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include "threads/Thread.h"
+
 using namespace XFILE;
 using namespace std;
 
-class COMXImage
+class COMXImageFile;
+
+class COMXImage : public CThread
 {
+enum TextureAction {TEXTURE_ALLOC, TEXTURE_DELETE };
+
+struct textureinfo {
+  TextureAction action;
+  int width, height;
+  GLuint texture;
+  EGLImageKHR egl_image;
+  void *parent;
+  const char *filename;
+  CEvent sync;
+};
+
+protected:
+  virtual void OnStartup();
+  virtual void OnExit();
+  virtual void Process();
 public:
   COMXImage();
   virtual ~COMXImage();
+  void Initialize();
+  void Deinitialize();
+  static COMXImageFile *LoadJpeg(const CStdString& texturePath);
+  static void CloseJpeg(COMXImageFile *file);
 
-  // Required overrides
-  void Close(void);
-  bool ClampLimits(unsigned int &width, unsigned int &height);
+  static bool DecodeJpeg(COMXImageFile *file, unsigned int maxWidth, unsigned int maxHeight, unsigned int stride, void *pixels);
+  static bool CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
+      unsigned int format, unsigned int pitch, const CStdString& destFile);
+  static bool ClampLimits(unsigned int &width, unsigned int &height, unsigned int m_width, unsigned int m_height, bool transposed = false);
+  static bool CreateThumb(const CStdString& srcFile, unsigned int width, unsigned int height, std::string &additional_info, const CStdString& destFile);
+  bool DecodeJpegToTexture(COMXImageFile *file, unsigned int width, unsigned int height, void **userdata);
+  void DestroyTexture(void *userdata);
+  void GetTexture(void *userdata, GLuint *texture);
+private:
+  EGLDisplay m_egl_display;
+  EGLContext m_egl_context;
+
+  void CreateContext();
+  CCriticalSection               m_texqueue_lock;
+  XbmcThreads::ConditionVariable m_texqueue_cond;
+  std::queue <struct textureinfo *> m_texqueue;
+  void AllocTextureInternal(struct textureinfo *tex);
+  void DestroyTextureInternal(struct textureinfo *tex);
+};
+
+class COMXImageFile
+{
+public:
+  COMXImageFile();
+  virtual ~COMXImageFile();
   bool ReadFile(const CStdString& inputFile);
-  bool IsProgressive() { return m_progressive; };
-  bool IsAlpha() { return m_alpha; };
   int  GetOrientation() { return m_orientation; };
-  unsigned int GetOriginalWidth()  { return m_omx_image.nFrameWidth; };
-  unsigned int GetOriginalHeight() { return m_omx_image.nFrameHeight; };
   unsigned int GetWidth()  { return m_width; };
   unsigned int GetHeight() { return m_height; };
-  OMX_IMAGE_CODINGTYPE GetCodingType();
-  const uint8_t *GetImageBuffer() { return (const uint8_t *)m_image_buffer; };
   unsigned long GetImageSize() { return m_image_size; };
-  OMX_IMAGE_CODINGTYPE GetCompressionFormat() { return m_omx_image.eCompressionFormat; };
-  bool Decode(unsigned int width, unsigned int height);
-  bool Encode(unsigned char *buffer, int size, unsigned int width, unsigned int height, unsigned int pitch);
-  unsigned int GetDecodedWidth() { return (unsigned int)m_decoded_format.format.image.nFrameWidth; };
-  unsigned int GetDecodedHeight() { return (unsigned int)m_decoded_format.format.image.nFrameHeight; };
-  unsigned int GetDecodedStride() { return (unsigned int)m_decoded_format.format.image.nStride; };
-  unsigned char *GetDecodedData();
-  unsigned int GetDecodedSize();
-  unsigned int GetEncodedWidth() { return (unsigned int)m_encoded_format.format.image.nFrameWidth; };
-  unsigned int GetEncodedHeight() { return (unsigned int)m_encoded_format.format.image.nFrameHeight; };
-  unsigned int GetEncodedStride() { return (unsigned int)m_encoded_format.format.image.nStride; };
-  unsigned char *GetEncodedData();
-  unsigned int GetEncodedSize();
-  bool SwapBlueRed(unsigned char *pixels, unsigned int height, unsigned int pitch, 
-      unsigned int elements = 4, unsigned int offset=0);
-  bool CreateThumbnail(const CStdString& sourceFile, const CStdString& destFile, 
-      int minx, int miny, bool rotateExif);
-  bool CreateThumbnailFromMemory(unsigned char* buffer, unsigned int bufSize, 
-      const CStdString& destFile, unsigned int minx, unsigned int miny);
-  bool CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height, 
-      unsigned int format, unsigned int pitch, const CStdString& destFile);
+  const uint8_t *GetImageBuffer() { return (const uint8_t *)m_image_buffer; };
+  const char *GetFilename() { return m_filename; };
 protected:
-  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height);
+  OMX_IMAGE_CODINGTYPE GetCodingType(unsigned int &width, unsigned int &height);
   uint8_t           *m_image_buffer;
-  bool              m_is_open;
   unsigned long     m_image_size;
   unsigned int      m_width;
   unsigned int      m_height;
-  bool              m_progressive;
-  bool              m_alpha;
   int               m_orientation;
-  XFILE::CFile      m_pFile;
-  OMX_IMAGE_PORTDEFINITIONTYPE  m_omx_image;
+  const char *      m_filename;
+};
 
+class COMXImageDec
+{
+public:
+  COMXImageDec();
+  virtual ~COMXImageDec();
+
+  // Required overrides
+  void Close();
+  bool Decode(const uint8_t *data, unsigned size, unsigned int width, unsigned int height, unsigned stride, void *pixels);
+  unsigned int GetDecodedWidth() { return (unsigned int)m_decoded_format.format.image.nFrameWidth; };
+  unsigned int GetDecodedHeight() { return (unsigned int)m_decoded_format.format.image.nFrameHeight; };
+  unsigned int GetDecodedStride() { return (unsigned int)m_decoded_format.format.image.nStride; };
+protected:
+  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, unsigned int resize_stride);
   // Components
   COMXCoreComponent             m_omx_decoder;
-  COMXCoreComponent             m_omx_encoder;
   COMXCoreComponent             m_omx_resize;
   COMXCoreTunel                 m_omx_tunnel_decode;
   OMX_BUFFERHEADERTYPE          *m_decoded_buffer;
-  OMX_BUFFERHEADERTYPE          *m_encoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_decoded_format;
+  CCriticalSection              m_OMXSection;
+};
+
+class COMXImageEnc
+{
+public:
+  COMXImageEnc();
+  virtual ~COMXImageEnc();
+
+  // Required overrides
+  bool CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
+      unsigned int format, unsigned int pitch, const CStdString& destFile);
+protected:
+  bool Encode(unsigned char *buffer, int size, unsigned int width, unsigned int height, unsigned int pitch);
+  // Components
+  COMXCoreComponent             m_omx_encoder;
+  OMX_BUFFERHEADERTYPE          *m_encoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_encoded_format;
+  CCriticalSection              m_OMXSection;
+};
+
+class COMXImageReEnc
+{
+public:
+  COMXImageReEnc();
+  virtual ~COMXImageReEnc();
+
+  // Required overrides
+  void Close();
+  bool ReEncode(COMXImageFile &srcFile, unsigned int width, unsigned int height, void * &pDestBuffer, unsigned int &nDestSize);
+protected:
+  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, int orientation, bool port_settings_changed);
+  // Components
+  COMXCoreComponent             m_omx_decoder;
+  COMXCoreComponent             m_omx_resize;
+  COMXCoreComponent             m_omx_encoder;
+  COMXCoreTunel                 m_omx_tunnel_decode;
+  COMXCoreTunel                 m_omx_tunnel_resize;
+  OMX_BUFFERHEADERTYPE          *m_encoded_buffer;
+  CCriticalSection              m_OMXSection;
+  void                          *m_pDestBuffer;
+  unsigned int                  m_nDestAllocSize;
+};
+
+class COMXTexture
+{
+public:
+  COMXTexture();
+  virtual ~COMXTexture();
+
+  // Required overrides
+  void Close(void);
+  bool Decode(const uint8_t *data, unsigned size, unsigned int width, unsigned int height, void *egl_image, void *egl_display);
+protected:
+  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, void *egl_image, void *egl_display, bool port_settings_changed);
+
+  // Components
+  COMXCoreComponent m_omx_decoder;
+  COMXCoreComponent m_omx_resize;
+  COMXCoreComponent m_omx_egl_render;
+
+  COMXCoreTunel     m_omx_tunnel_decode;
+  COMXCoreTunel     m_omx_tunnel_egl;
 
-  bool                          m_decoder_open;
-  bool                          m_encoder_open;
+  OMX_BUFFERHEADERTYPE *m_egl_buffer;
+  CCriticalSection              m_OMXSection;
 };
 
+extern COMXImage g_OMXImage;
 #endif
diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index 78cb5aa..9582eb9 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2005-2012 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -18,6 +18,7 @@
  *
  */
 
+#include "threads/SystemClock.h"
 #include "system.h"
 
 #if defined (HAS_OMXPLAYER)
@@ -62,33 +63,71 @@
 #include "DVDInputStreams/DVDInputStreamTV.h"
 #include "DVDInputStreams/DVDInputStreamPVRManager.h"
 
+#include "DVDDemuxers/DVDDemux.h"
 #include "DVDDemuxers/DVDDemuxUtils.h"
 #include "DVDDemuxers/DVDDemuxVobsub.h"
 #include "DVDDemuxers/DVDFactoryDemuxer.h"
 #include "DVDDemuxers/DVDDemuxFFmpeg.h"
 
-#include "DVDFileInfo.h"
+#include "DVDCodecs/DVDCodecs.h"
+#include "DVDCodecs/DVDFactoryCodec.h"
 
-#include "Util.h"
-#include "LangInfo.h"
+#include "DVDFileInfo.h"
 
-#include "utils/JobManager.h"
-//#include "cores/AudioEngine/AEFactory.h"
-//#include "cores/AudioEngine/Utils/AEUtil.h"
-#include "video/VideoThumbLoader.h"
+#include "utils/LangCodeExpander.h"
+#include "guilib/LocalizeStrings.h"
 
+#include "utils/URIUtils.h"
+#include "GUIInfoManager.h"
+#include "guilib/GUIWindowManager.h"
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include "DVDPerformanceCounter.h"
+#include "filesystem/File.h"
+#include "pictures/Picture.h"
+#include "DllSwScale.h"
+#ifdef HAS_VIDEO_PLAYBACK
+#include "cores/VideoRenderers/RenderManager.h"
+#endif
+#ifdef HAS_PERFORMANCE_SAMPLE
+#include "xbmc/utils/PerformanceSample.h"
+#else
+#define MEASURE_FUNCTION
+#endif
+#include "settings/AdvancedSettings.h"
+#include "FileItem.h"
+#include "settings/GUISettings.h"
+#include "GUIUserMessages.h"
+#include "settings/Settings.h"
+#include "utils/log.h"
+#include "utils/TimeUtils.h"
+#include "utils/StreamDetails.h"
 #include "pvr/PVRManager.h"
 #include "pvr/channels/PVRChannel.h"
 #include "pvr/windows/GUIWindowPVR.h"
 #include "pvr/addons/PVRClients.h"
 #include "filesystem/PVRFile.h"
-
+#include "video/dialogs/GUIDialogFullScreenInfo.h"
+#include "utils/StreamUtils.h"
+#include "utils/Variant.h"
+#include "storage/MediaManager.h"
+#include "dialogs/GUIDialogBusy.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "xbmc/playlists/PlayListM3U.h"
 #include "utils/StringUtils.h"
+#include "Util.h"
+#include "URL.h"
+#include "LangInfo.h"
+#include "ApplicationMessenger.h"
+
+// video not playing from clock, but stepped
+#define TP(speed)  ((speed) < 0 || (speed) > 4*DVD_PLAYSPEED_NORMAL)
+// audio not playing
+#define TPA(speed) ((speed) != DVD_PLAYSPEED_PAUSE && (speed) != DVD_PLAYSPEED_NORMAL)
 
-using namespace XFILE;
+using namespace std;
 using namespace PVR;
 
-// ****************************************************************
 void COMXSelectionStreams::Clear(StreamType type, StreamSource source)
 {
   CSingleLock lock(m_section);
@@ -393,7 +432,6 @@ void COMXSelectionStreams::Update(CDVDInputStream* input, CDVDDemux* demuxer)
   }
 }
 
-// ****************************************************************
 COMXPlayer::COMXPlayer(IPlayerCallback &callback) 
     : IPlayer(callback),
       CThread("COMXPlayer"),
@@ -402,35 +440,48 @@ COMXPlayer::COMXPlayer(IPlayerCallback &callback)
       m_CurrentSubtitle(STREAM_SUBTITLE, DVDPLAYER_SUBTITLE),
       m_CurrentTeletext(STREAM_TELETEXT, DVDPLAYER_TELETEXT),
       m_messenger("player"),
-      m_player_video(&m_av_clock, &m_overlayContainer, m_messenger),
-      m_player_audio(&m_av_clock, m_messenger),
-      m_player_subtitle(&m_overlayContainer),
-      m_player_teletext(),
+      m_omxPlayerVideo(&m_av_clock, &m_overlayContainer, m_messenger),
+      m_omxPlayerAudio(&m_av_clock, m_messenger),
+      m_dvdPlayerSubtitle(&m_overlayContainer),
+      m_dvdPlayerTeletext(),
       m_ready(true)
 {
-  m_bAbortRequest     = false;
   m_pDemuxer          = NULL;
   m_pSubtitleDemuxer  = NULL;
   m_pInputStream      = NULL;
-  m_UpdateApplication = 0;
-  m_caching           = CACHESTATE_DONE;
-  m_playSpeed         = DVD_PLAYSPEED_NORMAL;
-  m_HasVideo = false;
-  m_HasAudio = false;
 
   m_dvd.Clear();
   m_State.Clear();
   m_EdlAutoSkipMarkers.Clear();
+  m_UpdateApplication = 0;
+
+  m_bAbortRequest = false;
+  m_errorCount = 0;
+  m_offset_pts = 0.0;
+  m_playSpeed = DVD_PLAYSPEED_NORMAL;
+  m_caching           = CACHESTATE_DONE;
+  m_HasVideo          = false;
+  m_HasAudio          = false;
+  m_stepped           = false;
+  m_video_fifo        = 0;
+  m_audio_fifo        = 0;
+  m_last_check_time   = 0.0;
+  m_stamp             = 0.0;
 
   memset(&m_SpeedState, 0, sizeof(m_SpeedState));
+
+#ifdef DVDDEBUG_MESSAGE_TRACKER
+  g_dvdMessageTracker.Init();
+#endif
 }
 
 COMXPlayer::~COMXPlayer()
 {
   CloseFile();
 
-  if(m_messenger.IsInited())
-    m_messenger.End();
+#ifdef DVDDEBUG_MESSAGE_TRACKER
+  g_dvdMessageTracker.DeInit();
+#endif
 }
 
 bool COMXPlayer::OpenFile(const CFileItem &file, const CPlayerOptions &options)
@@ -444,34 +495,24 @@ bool COMXPlayer::OpenFile(const CFileItem &file, const CPlayerOptions &options)
     if(IsRunning())
       CloseFile();
 
-    if(!m_av_clock.OMXInitialize(false, false))
-    {
-      return false;
-    }
-    if(g_guiSettings.GetBool("videoplayer.adjustrefreshrate"))
-      m_av_clock.HDMIClockSync();
+    m_bAbortRequest = false;
 
-    m_playSpeed = DVD_PLAYSPEED_NORMAL;
     SetPlaySpeed(DVD_PLAYSPEED_NORMAL);
 
-    m_PlayerOptions     = options;
-    m_bAbortRequest     = false;
-
+    m_State.Clear();
     m_UpdateApplication = 0;
     m_offset_pts        = 0;
-    m_current_volume    = 0;
-    m_current_mute      = false;
-    m_change_volume     = true;
 
+    m_PlayerOptions = options;
     m_item              = file;
     m_mimetype          = file.GetMimeType();
     m_filename          = file.GetPath();
 
-    m_State.Clear();
-
     m_ready.Reset();
 
+#if defined(HAS_VIDEO_PLAYBACK)
     g_renderManager.PreInit();
+#endif
 
     Create();
     if(!m_ready.WaitMSec(100))
@@ -480,7 +521,7 @@ bool COMXPlayer::OpenFile(const CFileItem &file, const CPlayerOptions &options)
       if(dialog)
       {
         dialog->Show();
-        while(!m_ready.WaitMSec(1))
+        while(!m_ready.WaitMSec(100))
           g_windowManager.ProcessRenderLoop(false);
         dialog->Close();
       }
@@ -501,7 +542,7 @@ bool COMXPlayer::OpenFile(const CFileItem &file, const CPlayerOptions &options)
 
 bool COMXPlayer::CloseFile()
 {
-  CLog::Log(LOGDEBUG, "COMXPlayer::CloseFile");
+  CLog::Log(LOGNOTICE, "COMXPlayer::CloseFile");
 
   // unpause the player
   SetPlaySpeed(DVD_PLAYSPEED_NORMAL);
@@ -519,22 +560,23 @@ bool COMXPlayer::CloseFile()
   if(m_pInputStream)
     m_pInputStream->Abort();
 
-  CLog::Log(LOGDEBUG, "COMXPlayer: waiting for threads to exit");
+  CLog::Log(LOGNOTICE, "COMXPlayer: waiting for threads to exit");
 
   // wait for the main thread to finish up
   // since this main thread cleans up all other resources and threads
   // we are done after the StopThread call
   StopThread();
   
-  CLog::Log(LOGDEBUG, "COMXPlayer: finished waiting");
-
   m_Edl.Clear();
   m_EdlAutoSkipMarkers.Clear();
 
   m_HasVideo = false;
   m_HasAudio = false;
 
+  CLog::Log(LOGNOTICE, "COMXPlayer: finished waiting");
+#if defined(HAS_VIDEO_PLAYBACK)
   g_renderManager.UnInit();
+#endif
   return true;
 }
 
@@ -572,7 +614,8 @@ bool COMXPlayer::OpenInputStream()
 
   // before creating the input stream, if this is an HLS playlist then get the
   // most appropriate bitrate based on our network settings
-  if (filename.Left(7) == "http://" && filename.Right(5) == ".m3u8")
+  // ensure to strip off the url options by using a temp CURL object
+  if (filename.Left(7) == "http://" && CURL(filename).GetFileName().Right(5) == ".m3u8")
   {
     // get the available bandwidth (as per user settings)
     int maxrate = g_guiSettings.GetInt("network.bandwidth");
@@ -641,8 +684,9 @@ bool COMXPlayer::OpenInputStream()
 
   SetAVDelay(g_settings.m_currentVideoSettings.m_AudioDelay);
   SetSubTitleDelay(g_settings.m_currentVideoSettings.m_SubtitleDelay);
-  m_av_clock.Reset();
+  m_clock.Reset();
   m_dvd.Clear();
+  m_errorCount = 0;
   m_iChannelEntryTimeOut = 0;
 
   return true;
@@ -660,7 +704,11 @@ bool COMXPlayer::OpenDemuxStream()
     int attempts = 10;
     while(!m_bStop && attempts-- > 0)
     {
-      m_pDemuxer = CDVDFactoryDemuxer::CreateDemuxer(m_pInputStream);
+      /* PLEX */
+      CStdString error;
+      m_pDemuxer = CDVDFactoryDemuxer::CreateDemuxer(m_pInputStream, error);
+      /* END PLEX */
+
       if(!m_pDemuxer && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
       {
         continue;
@@ -735,7 +783,7 @@ void COMXPlayer::OpenDefaultStreams(bool reset)
     CloseAudioStream(true);
 
   // enable subtitles
-  m_player_video.EnableSubtitle(g_settings.m_currentVideoSettings.m_SubtitleOn);
+  m_omxPlayerVideo.EnableSubtitle(g_settings.m_currentVideoSettings.m_SubtitleOn);
 
   // open subtitle stream
   streams = m_SelectionStreams.Get(STREAM_SUBTITLE, PredicateSubtitlePriority);
@@ -746,34 +794,29 @@ void COMXPlayer::OpenDefaultStreams(bool reset)
     {
       valid = true;
       if(it->flags & CDemuxStream::FLAG_FORCED)
-        m_player_video.EnableSubtitle(true);
+        m_omxPlayerVideo.EnableSubtitle(true);
     }
   }
   if(!valid)
     CloseSubtitleStream(true);
 
   // open teletext stream
-  /*
   streams = m_SelectionStreams.Get(STREAM_TELETEXT);
   valid   = false;
-  for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)
+  for(OMXSelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)
   {
     if(OpenTeletextStream(it->id, it->source))
       valid = true;
   }
   if(!valid)
     CloseTeletextStream(true);
-  */
-
-  //m_av_clock.OMXStop();
-  //m_av_clock.OMXReset();
 }
 
 bool COMXPlayer::ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream)
 {
 
   // check if we should read from subtitle demuxer
-  if(m_player_subtitle.AcceptsData() &&  m_pSubtitleDemuxer)
+  if(m_dvdPlayerSubtitle.AcceptsData() &&  m_pSubtitleDemuxer)
   {
     if(m_pSubtitleDemuxer)
       packet = m_pSubtitleDemuxer->Read();
@@ -944,6 +987,7 @@ void COMXPlayer::Process()
   bool bOmxWaitVideo = false;
   bool bOmxWaitAudio = false;
   bool bOmxSentEOFs = false;
+  float m_threshold = 0.2f;
 
   if (!OpenInputStream())
   {
@@ -953,7 +997,7 @@ void COMXPlayer::Process()
 
   if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
   {
-    CLog::Log(LOGNOTICE, "OMXPlayer: playing a file with menu's");
+    CLog::Log(LOGNOTICE, "OMXPlayer: playing a dvd with menu's");
     m_PlayerOptions.starttime = 0;
 
     if(m_PlayerOptions.state.size() > 0)
@@ -970,7 +1014,19 @@ void COMXPlayer::Process()
     return;
   }
 
-  m_player_video.EnableFullscreen(true);
+  // allow renderer to switch to fullscreen if requested
+  m_omxPlayerVideo.EnableFullscreen(m_PlayerOptions.fullscreen);
+
+  if(!m_av_clock.OMXInitialize(&m_clock))
+  {
+    m_bAbortRequest = true;
+    return;
+  }
+  if(g_guiSettings.GetBool("videoplayer.adjustrefreshrate"))
+    m_av_clock.HDMIClockSync();
+  m_av_clock.OMXStateIdle();
+  m_av_clock.OMXStop();
+  m_av_clock.OMXPause();
 
   OpenDefaultStreams();
 
@@ -1057,39 +1113,125 @@ void COMXPlayer::Process()
   if (!CachePVRStream())
     SetCaching(CACHESTATE_FLUSH);
 
-  // stop thumb jobs
-  CJobManager::GetInstance().Pause(kJobTypeMediaFlags);
-
-  /*
-  if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
-  {
-    if (!WaitForPausedThumbJobs(20000))
-    {
-      CJobManager::GetInstance().UnPause(kJobTypeMediaFlags);
-      CLog::Log(LOGINFO, "COMXPlayer::Process:thumbgen jobs still running !!!");
-    }
-  }
-  */
+  EDEINTERLACEMODE current_deinterlace = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
 
   while (!m_bAbortRequest)
   {
-    #ifdef _DEBUG
-    char response[80];
-    static unsigned count;
-    if ((count++ & 15) == 0)
+    double now = m_clock.GetAbsoluteClock();
+    if (m_last_check_time == 0.0 || m_last_check_time + DVD_MSEC_TO_TIME(20) <= now)
     {
-      vc_gencmd(response, sizeof response, "render_bar 4 video_fifo %d %d %d %d",
-            m_player_video.GetDecoderBufferSize()-m_player_video.GetDecoderFreeSpace(),
-            0 , 0, m_player_video.GetDecoderBufferSize());
-      vc_gencmd(response, sizeof response, "render_bar 5 audio_fifo %d %d %d %d",
-            (int)(100.0*m_player_audio.GetDelay()), 0, 0, 100*AUDIO_BUFFER_SECONDS);
-      vc_gencmd(response, sizeof response, "render_bar 6 video_queue %d %d %d %d",
-            m_player_video.GetLevel(), 0, 0, 100);
-      vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
-            m_player_audio.GetLevel(), 0, 0, 100);
+      m_last_check_time = now;
+      m_stamp = m_av_clock.OMXMediaTime();
+      const bool m_Pause = m_playSpeed == DVD_PLAYSPEED_PAUSE;
+      const bool not_accepts_data = (!m_omxPlayerAudio.AcceptsData() && m_CurrentAudio.id >= 0) ||
+          (!m_omxPlayerVideo.AcceptsData() && m_CurrentVideo.id >= 0);
+      /* when the video/audio fifos are low, we pause clock, when high we resume */
+      double audio_pts = floor(m_omxPlayerAudio.GetCurrentPts());
+      double video_pts = floor(m_omxPlayerVideo.GetCurrentPts());
+
+      float audio_fifo = audio_pts / DVD_TIME_BASE - m_stamp * 1e-6;
+      float video_fifo = video_pts / DVD_TIME_BASE - m_stamp * 1e-6;
+      float threshold = 0.1f;
+      bool audio_fifo_low = false, video_fifo_low = false, audio_fifo_high = false, video_fifo_high = false;
+
+      // if deinterlace setting has changed, we should close and open video
+      if (current_deinterlace != g_settings.m_currentVideoSettings.m_DeinterlaceMode)
+      {
+        int iStream = m_CurrentVideo.id, source = m_CurrentVideo.source;
+        CloseVideoStream(false);
+        OpenVideoStream(iStream, source);
+        if (m_State.canseek)
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true, true, true));
+        current_deinterlace = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
+      }
+
+      m_video_fifo = (int)(100.0*(m_omxPlayerVideo.GetDecoderBufferSize()-m_omxPlayerVideo.GetDecoderFreeSpace())/m_omxPlayerVideo.GetDecoderBufferSize());
+      m_audio_fifo = (int)(100.0*audio_fifo/m_omxPlayerAudio.GetCacheTotal());
+
+      #ifdef _DEBUG
+      static unsigned count;
+      if ((count++ & 7) == 0)
+      {
+        char response[80];
+        if (m_omxPlayerVideo.GetDecoderBufferSize() && m_omxPlayerAudio.GetCacheTotal())
+          vc_gencmd(response, sizeof response, "render_bar 4 video_fifo %d %d %d %d",
+              m_video_fifo,
+              (int)(100.0*video_fifo/m_omxPlayerAudio.GetCacheTotal()),
+              0, 100);
+        if (m_omxPlayerAudio.GetCacheTotal())
+          vc_gencmd(response, sizeof response, "render_bar 5 audio_fifo %d %d %d %d",
+              m_audio_fifo,
+              (int)(100.0*m_omxPlayerAudio.GetDelay()/m_omxPlayerAudio.GetCacheTotal()),
+              0, 100);
+        vc_gencmd(response, sizeof response, "render_bar 6 video_queue %d %d %d %d",
+              m_omxPlayerVideo.GetLevel(), 0, 0, 100);
+        vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
+              m_omxPlayerAudio.GetLevel(), 0, 0, 100);
+      }
+      #endif
+      if (audio_pts != DVD_NOPTS_VALUE)
+      {
+        audio_fifo_low = m_HasAudio && audio_fifo < threshold;
+        audio_fifo_high = audio_pts != DVD_NOPTS_VALUE && audio_fifo >= m_threshold;
+      }
+      if (video_pts != DVD_NOPTS_VALUE)
+      {
+        video_fifo_low = m_HasVideo && video_fifo < threshold;
+        video_fifo_high = video_pts != DVD_NOPTS_VALUE && video_fifo >= m_threshold;
+      }
+      if (!m_HasAudio && m_HasVideo)
+        audio_fifo_high = true;
+      if (!m_HasVideo && m_HasAudio)
+        video_fifo_high = true;
+
+      #ifdef _DEBUG
+      CLog::Log(LOGDEBUG, "%s - M:%.6f-%.6f (A:%.6f V:%.6f) PEF:%d%d%d S:%.2f A:%.2f V:%.2f/T:%.2f (A:%d%d V:%d%d) A:%d%% V:%d%% (%.2f,%.2f)", __FUNCTION__,
+        m_stamp*1e-6, m_av_clock.OMXClockAdjustment()*1e-6, audio_pts*1e-6, video_pts*1e-6, m_av_clock.OMXIsPaused(), bOmxSentEOFs, not_accepts_data, m_playSpeed * (1.0f/DVD_PLAYSPEED_NORMAL),
+        audio_pts == DVD_NOPTS_VALUE ? 0.0:audio_fifo, video_pts == DVD_NOPTS_VALUE ? 0.0:video_fifo, m_threshold,
+        audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high,
+        m_omxPlayerAudio.GetLevel(), m_omxPlayerVideo.GetLevel(), m_omxPlayerAudio.GetDelay(), (float)m_omxPlayerAudio.GetCacheTotal());
+      #endif
+
+      if (TP(m_playSpeed))
+      {
+        if (m_CurrentVideo.started)
+        {
+          if (m_stamp == 0.0 && (!m_stepped || m_playSpeed > 0))
+          {
+            /* trickplay modes progress by stepping */
+            CLog::Log(LOGDEBUG, "COMXPlayer::Process - Seeking step speed:%.2f last:%.2f v:%.2f", (double)m_playSpeed / DVD_PLAYSPEED_NORMAL, m_SpeedState.lastpts*1e-6, video_pts*1e-6);
+            m_av_clock.OMXStep();
+          }
+          else
+          {
+            m_av_clock.OMXMediaTime(0.0);
+            m_last_check_time = 0.0;
+            m_stepped = true;
+          }
+        }
+      }
+      else if(!m_Pause && (bOmxSentEOFs || not_accepts_data || (audio_fifo_high && video_fifo_high)))
+      {
+        if (m_av_clock.OMXIsPaused())
+        {
+          CLog::Log(LOGDEBUG, "Resume %.2f,%.2f (A:%d%d V:%d%d) EOF:%d FULL:%d T:%.2f\n", audio_fifo, video_fifo,
+            audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high, bOmxSentEOFs, not_accepts_data, m_threshold);
+          m_av_clock.OMXStateExecute();
+          m_av_clock.OMXResume();
+        }
+      }
+      else if (m_Pause || audio_fifo_low || video_fifo_low)
+      {
+        if (!m_av_clock.OMXIsPaused() && !TPA(m_playSpeed))
+        {
+          if (!m_Pause)
+            m_threshold = std::min(2.0f*m_threshold, 16.0f);
+          CLog::Log(LOGDEBUG, "Pause %.2f,%.2f (A:%d%d V:%d%d) EOF:%d FULL:%d T:%.2f\n", audio_fifo, video_fifo,
+            audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high, bOmxSentEOFs, not_accepts_data, m_threshold);
+          m_av_clock.OMXPause();
+        }
+      }
     }
-    #endif
-    // handle messages send to this thread, like seek or demuxer reset requests
     HandleMessages();
 
     if(m_bAbortRequest)
@@ -1141,9 +1283,9 @@ void COMXPlayer::Process()
     UpdateApplication(1000);
 
     // OMX emergency exit
-    if(HasAudio() && m_player_audio.BadState())
+    if(HasAudio() && m_omxPlayerAudio.BadState())
     {
-      CLog::Log(LOGERROR, "%s - Closing stream due to m_player_audio.BadState()", __FUNCTION__);
+      CLog::Log(LOGERROR, "%s - Closing stream due to m_omxPlayerAudio.BadState()", __FUNCTION__);
       m_bAbortRequest = true;
       break;
     }
@@ -1152,16 +1294,16 @@ void COMXPlayer::Process()
       continue;
 
     // if the queues are full, no need to read more
-    if ((!m_player_audio.AcceptsData() && m_CurrentAudio.id >= 0)
-    ||  (!m_player_video.AcceptsData() && m_CurrentVideo.id >= 0))
+    if ((!m_omxPlayerAudio.AcceptsData() && m_CurrentAudio.id >= 0) ||
+        (!m_omxPlayerVideo.AcceptsData() && m_CurrentVideo.id >= 0))
     {
       Sleep(10);
       continue;
     }
 
     // always yield to players if they have data levels > 50 percent
-    if((m_player_audio.GetLevel() > 50 || m_CurrentAudio.id < 0)
-    && (m_player_video.GetLevel() > 50 || m_CurrentVideo.id < 0))
+    if((m_omxPlayerAudio.GetLevel() > 50 || m_CurrentAudio.id < 0)
+    && (m_omxPlayerVideo.GetLevel() > 50 || m_CurrentVideo.id < 0))
       Sleep(0);
 
     DemuxPacket* pPacket = NULL;
@@ -1173,7 +1315,13 @@ void COMXPlayer::Process()
       CDVDDemuxUtils::FreeDemuxPacket(pPacket);
       continue;
     }
-
+    if (pPacket)
+    {
+      // reset eos state when we get a packet (e.g. for case of seek after eos)
+      bOmxWaitVideo = false;
+      bOmxWaitAudio = false;
+      bOmxSentEOFs = false;
+    }
     if (!pPacket)
     {
       // when paused, demuxer could be be returning empty
@@ -1219,33 +1367,28 @@ void COMXPlayer::Process()
         Sleep(100);
         continue;
       }
-      else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
-      {
-        CDVDInputStreamPVRManager* pStream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
-        if (pStream->IsEOF())
-          break;
-
-        Sleep(100);
-        continue;
-      }
 
       // make sure we tell all players to finish it's data
       if (!bOmxSentEOFs)
       {
         if(m_CurrentAudio.inited)
         {
-          m_player_audio.SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
+          m_omxPlayerAudio.SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
           bOmxWaitAudio = true;
         }
         if(m_CurrentVideo.inited)
         {
-          m_player_video.SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
+          m_omxPlayerVideo.SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
           bOmxWaitVideo = true;
         }
         if(m_CurrentSubtitle.inited)
-          m_player_subtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
+          m_dvdPlayerSubtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
         if(m_CurrentTeletext.inited)
-          m_player_teletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
+          m_dvdPlayerTeletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
+        m_CurrentAudio.inited    = false;
+        m_CurrentVideo.inited    = false;
+        m_CurrentSubtitle.inited = false;
+        m_CurrentTeletext.inited = false;
         bOmxSentEOFs = true;
       }
 
@@ -1253,20 +1396,20 @@ void COMXPlayer::Process()
       SetCaching(CACHESTATE_DONE);
 
       // while players are still playing, keep going to allow seekbacks
-      if(m_player_video.HasData()
-      || m_player_audio.HasData())
+      if(m_omxPlayerVideo.HasData()
+      || m_omxPlayerAudio.HasData())
       {
         Sleep(100);
         continue;
       }
 
       // wait for omx components to finish
-      if(bOmxWaitVideo && !m_player_video.IsEOS())
+      if(bOmxWaitVideo && !m_omxPlayerVideo.IsEOS())
       {
         Sleep(100);
         continue;
       }
-      if(bOmxWaitAudio && !m_player_audio.IsEOS())
+      if(bOmxWaitAudio && !m_omxPlayerAudio.IsEOS())
       {
         Sleep(100);
         continue;
@@ -1275,10 +1418,6 @@ void COMXPlayer::Process()
       if (!m_pInputStream->IsEOF())
         CLog::Log(LOGINFO, "%s - eof reading from demuxer", __FUNCTION__);
 
-      m_CurrentAudio.inited    = false;
-      m_CurrentVideo.inited    = false;
-      m_CurrentSubtitle.inited = false;
-      m_CurrentTeletext.inited = false;
       m_CurrentAudio.started    = false;
       m_CurrentVideo.started    = false;
       m_CurrentSubtitle.started = false;
@@ -1287,10 +1426,13 @@ void COMXPlayer::Process()
       break;
     }
 
+    // it's a valid data packet, reset error counter
+    m_errorCount = 0;
+
     // check so that none of our streams has become invalid
-    if (!IsValidStream(m_CurrentAudio)    && m_player_audio.IsStalled())    CloseAudioStream(true);
-    if (!IsValidStream(m_CurrentVideo)    && m_player_video.IsStalled())    CloseVideoStream(true);
-    if (!IsValidStream(m_CurrentSubtitle) && m_player_subtitle.IsStalled()) CloseSubtitleStream(true);
+    if (!IsValidStream(m_CurrentAudio)    && m_omxPlayerAudio.IsStalled())    CloseAudioStream(true);
+    if (!IsValidStream(m_CurrentVideo)    && m_omxPlayerVideo.IsStalled())    CloseVideoStream(true);
+    if (!IsValidStream(m_CurrentSubtitle) && m_dvdPlayerSubtitle.IsStalled()) CloseSubtitleStream(true);
     if (!IsValidStream(m_CurrentTeletext))                                  CloseTeletextStream(true);
 
     // see if we can find something better to play
@@ -1299,21 +1441,12 @@ void COMXPlayer::Process()
     if (IsBetterStream(m_CurrentSubtitle, pStream)) OpenSubtitleStream(pStream->iId, pStream->source);
     if (IsBetterStream(m_CurrentTeletext, pStream)) OpenTeletextStream(pStream->iId, pStream->source);
 
-    if(m_change_volume && m_CurrentAudio.started)
-    {
-      m_player_audio.SetCurrentVolume(m_current_mute ? VOLUME_MINIMUM : m_current_volume);
-      m_change_volume = false;
-    }
-
     // process the packet
     ProcessPacket(pStream, pPacket);
 
     // check if in a cut or commercial break that should be automatically skipped
     CheckAutoSceneSkip();
   }
-
-  // let thumbgen jobs resume.
-  CJobManager::GetInstance().UnPause(kJobTypeMediaFlags);
 }
 
 bool COMXPlayer::CheckDelayedChannelEntry(void)
@@ -1397,17 +1530,17 @@ void COMXPlayer::ProcessAudioData(CDemuxStream* pStream, DemuxPacket* pPacket)
   else if (m_Edl.InCut(DVD_TIME_TO_MSEC(m_CurrentAudio.dts + m_offset_pts), &cut) && cut.action == CEdl::MUTE // Inside EDL mute
   &&      !m_EdlAutoSkipMarkers.mute) // Mute not already triggered
   {
-    m_player_audio.SendMessage(new CDVDMsgBool(CDVDMsg::AUDIO_SILENCE, true));
+    m_omxPlayerAudio.SendMessage(new CDVDMsgBool(CDVDMsg::AUDIO_SILENCE, true));
     m_EdlAutoSkipMarkers.mute = true;
   }
   else if (!m_Edl.InCut(DVD_TIME_TO_MSEC(m_CurrentAudio.dts + m_offset_pts), &cut) // Outside of any EDL
   &&        m_EdlAutoSkipMarkers.mute) // But the mute hasn't been removed yet
   {
-    m_player_audio.SendMessage(new CDVDMsgBool(CDVDMsg::AUDIO_SILENCE, false));
+    m_omxPlayerAudio.SendMessage(new CDVDMsgBool(CDVDMsg::AUDIO_SILENCE, false));
     m_EdlAutoSkipMarkers.mute = false;
   }
 
-  m_player_audio.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
+  m_omxPlayerAudio.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
 }
 
 void COMXPlayer::ProcessVideoData(CDemuxStream* pStream, DemuxPacket* pPacket)
@@ -1440,7 +1573,7 @@ void COMXPlayer::ProcessVideoData(CDemuxStream* pStream, DemuxPacket* pPacket)
   if (CheckSceneSkip(m_CurrentVideo))
     drop = true;
 
-  m_player_video.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
+  m_omxPlayerVideo.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
 }
 
 void COMXPlayer::ProcessSubData(CDemuxStream* pStream, DemuxPacket* pPacket)
@@ -1466,10 +1599,10 @@ void COMXPlayer::ProcessSubData(CDemuxStream* pStream, DemuxPacket* pPacket)
   if (CheckSceneSkip(m_CurrentSubtitle))
     drop = true;
 
-  m_player_subtitle.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
+  m_dvdPlayerSubtitle.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
 
   if(m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
-    m_player_subtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_NORMAL);
+    m_dvdPlayerSubtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_NORMAL);
 }
 
 void COMXPlayer::ProcessTeletextData(CDemuxStream* pStream, DemuxPacket* pPacket)
@@ -1493,7 +1626,7 @@ void COMXPlayer::ProcessTeletextData(CDemuxStream* pStream, DemuxPacket* pPacket
   if (CheckSceneSkip(m_CurrentTeletext))
     drop = true;
 
-  m_player_teletext.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
+  m_dvdPlayerTeletext.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
 }
 
 bool COMXPlayer::GetCachingTimes(double& level, double& delay, double& offset)
@@ -1554,14 +1687,17 @@ void COMXPlayer::HandlePlaySpeed()
     if(GetCachingTimes(level, delay, offset))
     {
       if(level  < 0.0)
+      {
+        CGUIDialogKaiToast::QueueNotification(g_localizeStrings.Get(21454), g_localizeStrings.Get(21455));
         caching = CACHESTATE_INIT;
+      }
       if(level >= 1.0)
         caching = CACHESTATE_INIT;
     }
     else
     {
-      if ((!m_player_audio.AcceptsData() && m_CurrentAudio.id >= 0)
-      ||  (!m_player_video.AcceptsData() && m_CurrentVideo.id >= 0))
+      if ((!m_omxPlayerAudio.AcceptsData() && m_CurrentAudio.id >= 0)
+      ||  (!m_omxPlayerVideo.AcceptsData() && m_CurrentVideo.id >= 0))
         caching = CACHESTATE_INIT;
     }
   }
@@ -1576,8 +1712,8 @@ void COMXPlayer::HandlePlaySpeed()
     // handle situation that we get no data on one stream
     if(m_CurrentAudio.id >= 0 && m_CurrentVideo.id >= 0)
     {
-      if ((!m_player_audio.AcceptsData() && !m_CurrentVideo.started)
-      ||  (!m_player_video.AcceptsData() && !m_CurrentAudio.started))
+      if ((!m_omxPlayerAudio.AcceptsData() && !m_CurrentVideo.started)
+      ||  (!m_omxPlayerVideo.AcceptsData() && !m_CurrentAudio.started))
       {
         caching = CACHESTATE_DONE;
       }
@@ -1588,10 +1724,10 @@ void COMXPlayer::HandlePlaySpeed()
   {
     bool bGotAudio(m_pDemuxer->GetNrOfAudioStreams() > 0);
     bool bGotVideo(m_pDemuxer->GetNrOfVideoStreams() > 0);
-    bool bAudioLevelOk(m_player_audio.GetLevel() > g_advancedSettings.m_iPVRMinAudioCacheLevel);
-    bool bVideoLevelOk(m_player_video.GetLevel() > g_advancedSettings.m_iPVRMinVideoCacheLevel);
-    bool bAudioFull(!m_player_audio.AcceptsData());
-    bool bVideoFull(!m_player_video.AcceptsData());
+    bool bAudioLevelOk(m_omxPlayerAudio.GetLevel() > g_advancedSettings.m_iPVRMinAudioCacheLevel);
+    bool bVideoLevelOk(m_omxPlayerVideo.GetLevel() > g_advancedSettings.m_iPVRMinVideoCacheLevel);
+    bool bAudioFull(!m_omxPlayerAudio.AcceptsData());
+    bool bVideoFull(!m_omxPlayerVideo.AcceptsData());
 
     if (/* if all streams got at least g_advancedSettings.m_iPVRMinCacheLevel in their buffers, we're done */
         ((bGotVideo || bGotAudio) && (!bGotAudio || bAudioLevelOk) && (!bGotVideo || bVideoLevelOk)) ||
@@ -1599,8 +1735,8 @@ void COMXPlayer::HandlePlaySpeed()
         (bAudioFull || bVideoFull))
     {
       CLog::Log(LOGDEBUG, "set caching from pvr to done. audio (%d) = %d. video (%d) = %d",
-          bGotAudio, m_player_audio.GetLevel(),
-          bGotVideo, m_player_video.GetLevel());
+          bGotAudio, m_omxPlayerAudio.GetLevel(),
+          bGotVideo, m_omxPlayerVideo.GetLevel());
 
       CFileItem currentItem(g_application.CurrentFileItem());
       if (currentItem.HasPVRChannelInfoTag())
@@ -1612,17 +1748,17 @@ void COMXPlayer::HandlePlaySpeed()
     {
       /* ensure that automatically started players are stopped while caching */
       if (m_CurrentAudio.started)
-        m_player_audio.SetSpeed(DVD_PLAYSPEED_PAUSE);
+        m_omxPlayerAudio.SetSpeed(DVD_PLAYSPEED_PAUSE);
       if (m_CurrentVideo.started)
-        m_player_video.SetSpeed(DVD_PLAYSPEED_PAUSE);
+        m_omxPlayerVideo.SetSpeed(DVD_PLAYSPEED_PAUSE);
     }
   }
 
   if(caching == CACHESTATE_PLAY)
   {
     // if all enabled streams have started playing we are done
-    if((m_CurrentVideo.id < 0 || !m_player_video.IsStalled())
-    && (m_CurrentAudio.id < 0 || !m_player_audio.IsStalled()))
+    if((m_CurrentVideo.id < 0 || !m_omxPlayerVideo.IsStalled())
+    && (m_CurrentAudio.id < 0 || !m_omxPlayerAudio.IsStalled()))
       caching = CACHESTATE_DONE;
   }
 
@@ -1640,10 +1776,11 @@ void COMXPlayer::HandlePlaySpeed()
     }
     else if (m_CurrentVideo.id >= 0
           &&  m_CurrentVideo.inited == true
-          &&  m_SpeedState.lastpts  != m_player_video.GetCurrentPTS()
-          &&  m_SpeedState.lasttime != GetTime())
+          &&  m_SpeedState.lastpts  != m_omxPlayerVideo.GetCurrentPts()
+          &&  m_SpeedState.lasttime != GetTime()
+          &&  m_stepped)
     {
-      m_SpeedState.lastpts  = m_player_video.GetCurrentPTS();
+      m_SpeedState.lastpts  = m_omxPlayerVideo.GetCurrentPts();
       m_SpeedState.lasttime = GetTime();
       // check how much off clock video is when ff/rw:ing
       // a problem here is that seeking isn't very accurate
@@ -1656,13 +1793,13 @@ void COMXPlayer::HandlePlaySpeed()
       // when seeking, give the player a headstart to make sure
       // the time it takes to seek doesn't make a difference.
       double error;
-      error  = m_av_clock.GetClock() - m_SpeedState.lastpts;
+      error  = m_clock.GetClock() - m_SpeedState.lastpts;
       error *= m_playSpeed / abs(m_playSpeed);
 
       if(error > DVD_MSEC_TO_TIME(1000))
       {
         CLog::Log(LOGDEBUG, "COMXPlayer::Process - Seeking to catch up");
-        int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_av_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
+        int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
         m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true));
       }
     }
@@ -1678,13 +1815,13 @@ bool COMXPlayer::CheckStartCaching(COMXCurrentStream& current)
   if(IsInMenu())
     return false;
 
-  if((current.type == STREAM_AUDIO && m_player_audio.IsStalled())
-  || (current.type == STREAM_VIDEO && m_player_video.IsStalled()))
+  if((current.type == STREAM_AUDIO && m_omxPlayerAudio.IsStalled())
+  || (current.type == STREAM_VIDEO && m_omxPlayerVideo.IsStalled()))
   {
     if (CachePVRStream())
     {
-      if ((current.type == STREAM_AUDIO && current.started && m_player_audio.GetLevel() == 0) ||
-         (current.type == STREAM_VIDEO && current.started && m_player_video.GetLevel() == 0))
+      if ((current.type == STREAM_AUDIO && current.started && m_omxPlayerAudio.GetLevel() == 0) ||
+         (current.type == STREAM_VIDEO && current.started && m_omxPlayerVideo.GetLevel() == 0))
       {
         CLog::Log(LOGDEBUG, "%s stream stalled. start buffering", current.type == STREAM_AUDIO ? "audio" : "video");
         SetCaching(CACHESTATE_PVR);
@@ -1693,8 +1830,8 @@ bool COMXPlayer::CheckStartCaching(COMXCurrentStream& current)
     }
 
     // don't start caching if it's only a single stream that has run dry
-    if(m_player_audio.GetLevel() > 50
-    || m_player_video.GetLevel() > 50)
+    if(m_omxPlayerAudio.GetLevel() > 50
+    || m_omxPlayerVideo.GetLevel() > 50)
       return false;
 
     if(current.inited)
@@ -1779,13 +1916,14 @@ bool COMXPlayer::CheckPlayerInit(COMXCurrentStream& current, unsigned int source
     }
 
     SendPlayerMessage(new CDVDMsgGeneralResync(current.dts, setclock), source);
+    if(setclock)
+      m_clock.Discontinuity(current.dts);
   }
   return false;
 }
 
 void COMXPlayer::UpdateCorrection(DemuxPacket* pkt, double correction)
 {
-  //CLog::Log(LOGINFO,"%s: %d dts:%.0f pts:%.0f s:%d c:%.0f (%d,%d)", __func__, (int)pkt->iStreamId, pkt->dts, pkt->pts, pkt->iSize, correction, pkt->dts==DVD_NOPTS_VALUE, pkt->pts==DVD_NOPTS_VALUE);
   if(pkt->dts != DVD_NOPTS_VALUE) pkt->dts -= correction;
   if(pkt->pts != DVD_NOPTS_VALUE) pkt->pts -= correction;
 }
@@ -1808,7 +1946,7 @@ void COMXPlayer::UpdateTimestamps(COMXCurrentStream& current, DemuxPacket* pPack
   current.dts = dts;
 }
 
-void COMXPlayer::UpdateLimits(double& minimum, double& maximum, double dts)
+static void UpdateLimits(double& minimum, double& maximum, double dts)
 {
   if(dts == DVD_NOPTS_VALUE)
     return;
@@ -1974,15 +2112,15 @@ void COMXPlayer::SynchronizePlayers(unsigned int sources)
 
   CDVDMsgGeneralSynchronize* message = new CDVDMsgGeneralSynchronize(timeout, sources);
   if (m_CurrentAudio.id >= 0)
-    m_player_audio.SendMessage(message->Acquire());
+    m_omxPlayerAudio.SendMessage(message->Acquire());
 
   if (m_CurrentVideo.id >= 0)
-    m_player_video.SendMessage(message->Acquire());
+    m_omxPlayerVideo.SendMessage(message->Acquire());
 /* TODO - we have to rewrite the sync class, to not require
           all other players waiting for subtitle, should only
           be the oposite way
   if (m_CurrentSubtitle.id >= 0)
-    m_player_subtitle.SendMessage(message->Acquire()); 
+    m_dvdPlayerSubtitle.SendMessage(message->Acquire());
 */
   message->Release();
 }
@@ -1990,13 +2128,13 @@ void COMXPlayer::SynchronizePlayers(unsigned int sources)
 void COMXPlayer::SendPlayerMessage(CDVDMsg* pMsg, unsigned int target)
 {
   if(target == DVDPLAYER_AUDIO)
-    m_player_audio.SendMessage(pMsg);
+    m_omxPlayerAudio.SendMessage(pMsg);
   if(target == DVDPLAYER_VIDEO)
-    m_player_video.SendMessage(pMsg);
+    m_omxPlayerVideo.SendMessage(pMsg);
   if(target == DVDPLAYER_SUBTITLE)
-    m_player_subtitle.SendMessage(pMsg);
+    m_dvdPlayerSubtitle.SendMessage(pMsg);
   if(target == DVDPLAYER_TELETEXT)
-    m_player_teletext.SendMessage(pMsg);
+    m_dvdPlayerTeletext.SendMessage(pMsg);
 }
 
 void COMXPlayer::OnExit()
@@ -2059,7 +2197,7 @@ void COMXPlayer::OnExit()
     // clean up all selection streams
     m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_NONE);
 
-    m_messenger.Flush();
+    m_messenger.End();
 
     m_av_clock.OMXDeinitialize();
 
@@ -2109,9 +2247,9 @@ void COMXPlayer::HandleMessages()
         if(!msg.GetTrickPlay())
         {
           g_infoManager.SetDisplayAfterSeek(100000);
-          if(msg.GetFlush())
-            SetCaching(CACHESTATE_FLUSH);
         }
+        if(msg.GetFlush())
+          SetCaching(CACHESTATE_FLUSH);
 
         double start = DVD_NOPTS_VALUE;
 
@@ -2131,6 +2269,12 @@ void COMXPlayer::HandleMessages()
               CLog::Log(LOGDEBUG, "failed to seek subtitle demuxer: %d, success", time);
           }
           FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
+          // mark mediatime as invalid
+          if(TP(m_playSpeed))
+          {
+            m_av_clock.OMXMediaTime(0.0);
+            m_last_check_time = 0.0;
+          }
         }
         else
           CLog::Log(LOGWARNING, "error while seeking");
@@ -2225,7 +2369,7 @@ void COMXPlayer::HandleMessages()
       {
         CDVDMsgBool* pValue = (CDVDMsgBool*)pMsg;
 
-        m_player_video.EnableSubtitle(pValue->m_value);
+        m_omxPlayerVideo.EnableSubtitle(pValue->m_value);
 
         if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
           static_cast<CDVDInputStreamNavigator*>(m_pInputStream)->EnableSubtitleStream(pValue->m_value);
@@ -2267,22 +2411,24 @@ void COMXPlayer::HandleMessages()
         if(m_State.timestamp > 0)
         {
           double offset;
-          offset  = m_av_clock.GetAbsoluteClock() - m_State.timestamp;
+          offset  = m_clock.GetAbsoluteClock() - m_State.timestamp;
           offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
           if(offset >  1000) offset =  1000;
           if(offset < -1000) offset = -1000;
           m_State.time     += DVD_TIME_TO_MSEC(offset);
-          m_State.timestamp =  m_av_clock.GetAbsoluteClock();
+          m_State.timestamp =  m_clock.GetAbsoluteClock();
         }
 
         if (speed != DVD_PLAYSPEED_PAUSE && m_playSpeed != DVD_PLAYSPEED_PAUSE && speed != m_playSpeed)
           m_callback.OnPlayBackSpeedChanged(speed / DVD_PLAYSPEED_NORMAL);
 
+#ifndef __PLEX__
         if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && speed != m_playSpeed)
         {
           CDVDInputStreamPVRManager* pvrinputstream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
           pvrinputstream->Pause( speed == 0 );
         }
+#endif
 
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
         // audioplayer, stops outputing audio to audiorender, but still tries to
@@ -2290,12 +2436,21 @@ void COMXPlayer::HandleMessages()
         // videoplayer just plays faster after the clock speed has been increased
         // 1. disable audio
         // 2. skip frames and adjust their pts or the clock
+
+        // when switching from trickplay to normal, we may not have a full set of reference frames
+        // in decoder and we may get corrupt frames out. Seeking to current time will avoid this.
+        if ( TP(speed) || TP(m_playSpeed) ||
+           ( (speed == DVD_PLAYSPEED_PAUSE || speed == DVD_PLAYSPEED_NORMAL) &&
+             (m_playSpeed != DVD_PLAYSPEED_PAUSE && m_playSpeed != DVD_PLAYSPEED_NORMAL) ) )
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), (speed < 0), true, false, false, true));
+
         m_playSpeed = speed;
         m_caching = CACHESTATE_DONE;
-        m_av_clock.SetSpeed(speed);
+        m_clock.SetSpeed(speed);
         m_av_clock.OMXSetSpeed(speed);
-        m_player_audio.SetSpeed(speed);
-        m_player_video.SetSpeed(speed);
+        m_av_clock.OMXPause();
+        m_omxPlayerAudio.SetSpeed(speed);
+        m_omxPlayerVideo.SetSpeed(speed);
 
         // TODO - we really shouldn't pause demuxer
         //        until our buffers are somewhat filled
@@ -2380,7 +2535,16 @@ void COMXPlayer::HandleMessages()
           m_CurrentAudio.started = true;
         if(player == DVDPLAYER_VIDEO)
           m_CurrentVideo.started = true;
-        CLog::Log(LOGDEBUG, "COMXPlayer::HandleMessages - player started %d", player);
+
+        if ((player == DVDPLAYER_AUDIO || player == DVDPLAYER_VIDEO) &&
+           (TPA(m_playSpeed) || !m_HasAudio || m_CurrentAudio.started) &&
+           (!m_HasVideo || m_CurrentVideo.started))
+        {
+          CLog::Log(LOGDEBUG, "COMXPlayer::HandleMessages - player started RESET");
+          m_av_clock.OMXReset(m_HasVideo, m_playSpeed != DVD_PLAYSPEED_NORMAL && m_playSpeed != DVD_PLAYSPEED_PAUSE ? false:m_HasAudio);
+        }
+
+        CLog::Log(LOGDEBUG, "COMXPlayer::HandleMessages - player started %d (tpa:%d,a:%d,v:%d)", player, TPA(m_playSpeed), m_CurrentAudio.started, m_CurrentVideo.started);
       }
     }
     catch (...)
@@ -2412,12 +2576,12 @@ void COMXPlayer::SetCaching(ECacheState state)
   || state == CACHESTATE_INIT
   || state == CACHESTATE_PVR)
   {
-    m_av_clock.SetSpeed(DVD_PLAYSPEED_PAUSE);
-    m_av_clock.OMXSetSpeed(DVD_PLAYSPEED_PAUSE);
-    m_player_audio.SetSpeed(DVD_PLAYSPEED_PAUSE);
-    m_player_audio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
-    m_player_video.SetSpeed(DVD_PLAYSPEED_PAUSE);
-    m_player_video.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
+    m_clock.SetSpeed(DVD_PLAYSPEED_PAUSE);
+    m_av_clock.OMXPause();
+    m_omxPlayerAudio.SetSpeed(DVD_PLAYSPEED_PAUSE);
+    m_omxPlayerAudio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
+    m_omxPlayerVideo.SetSpeed(DVD_PLAYSPEED_PAUSE);
+    m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
 
     if (state == CACHESTATE_PVR)
       m_pInputStream->ResetScanTimeout((unsigned int) g_guiSettings.GetInt("pvrplayback.scantime") * 1000);
@@ -2426,21 +2590,19 @@ void COMXPlayer::SetCaching(ECacheState state)
   if(state == CACHESTATE_PLAY
   ||(state == CACHESTATE_DONE && m_caching != CACHESTATE_PLAY))
   {
-    m_av_clock.SetSpeed(m_playSpeed);
-    m_av_clock.OMXSetSpeed(m_playSpeed);
-    m_player_audio.SetSpeed(m_playSpeed);
-    m_player_video.SetSpeed(m_playSpeed);
+    m_clock.SetSpeed(m_playSpeed);
+    m_omxPlayerAudio.SetSpeed(m_playSpeed);
+    m_omxPlayerVideo.SetSpeed(m_playSpeed);
+    m_pInputStream->ResetScanTimeout(0);
   }
   m_caching = state;
 }
 
 void COMXPlayer::SetPlaySpeed(int speed)
 {
-  /* only pause and normal playspeeds are allowed */
-  if(speed < 0 || speed > DVD_PLAYSPEED_NORMAL)
-    return;
-
   m_messenger.Put(new CDVDMsgInt(CDVDMsg::PLAYER_SETSPEED, speed));
+  m_omxPlayerAudio.SetSpeed(speed);
+  m_omxPlayerVideo.SetSpeed(speed);
   SynchronizeDemuxer(100);
 }
 
@@ -2493,7 +2655,7 @@ bool COMXPlayer::HasAudio() const
 
 bool COMXPlayer::IsPassthrough() const
 {
-  return m_player_audio.Passthrough();
+  return m_omxPlayerAudio.Passthrough();
 }
 
 bool COMXPlayer::CanSeek()
@@ -2504,6 +2666,13 @@ bool COMXPlayer::CanSeek()
 
 void COMXPlayer::Seek(bool bPlus, bool bLargeStep)
 {
+  // Single step
+  if( m_playSpeed == DVD_PLAYSPEED_PAUSE && bPlus && !bLargeStep)
+  {
+    m_av_clock.OMXStep();
+    return;
+  }
+
   if (!m_State.canseek)
     return;
 
@@ -2548,7 +2717,7 @@ void COMXPlayer::Seek(bool bPlus, bool bLargeStep)
      * Alter the standard seek position based on whether any commercial breaks have been
      * automatically skipped.
      */
-    const int clock = DVD_TIME_TO_MSEC(m_av_clock.GetClock());
+    const int clock = DVD_TIME_TO_MSEC(m_clock.GetClock());
     /*
      * If a large backwards seek occurs within 10 seconds of the end of the last automated
      * commercial skip, then seek back to the start of the commercial break under the assumption
@@ -2636,7 +2805,7 @@ void COMXPlayer::GetAudioInfo(CStdString &strAudioInfo)
   { CSingleLock lock(m_StateSection);
     strAudioInfo.Format("D(%s)", m_State.demux_audio.c_str());
   }
-  strAudioInfo.AppendFormat(" P(%s)", m_player_audio.GetPlayerInfo().c_str());
+  strAudioInfo.AppendFormat(" P(%s)", m_omxPlayerAudio.GetPlayerInfo().c_str());
 }
 
 void COMXPlayer::GetVideoInfo(CStdString &strVideoInfo)
@@ -2644,17 +2813,15 @@ void COMXPlayer::GetVideoInfo(CStdString &strVideoInfo)
   { CSingleLock lock(m_StateSection);
     strVideoInfo.Format("D(%s)", m_State.demux_video.c_str());
   }
-  strVideoInfo.AppendFormat(" P(%s)", m_player_video.GetPlayerInfo().c_str());
+  strVideoInfo.AppendFormat(" P(%s)", m_omxPlayerVideo.GetPlayerInfo().c_str());
 }
 
 void COMXPlayer::GetGeneralInfo(CStdString& strGeneralInfo)
 {
   if (!m_bStop)
   {
-    double dDelay = m_player_video.GetDelay() / DVD_TIME_BASE - g_renderManager.GetDisplayLatency();
-
-    double apts = m_player_audio.GetCurrentPTS();
-    double vpts = m_player_video.GetCurrentPTS();
+    double apts = m_omxPlayerAudio.GetCurrentPts();
+    double vpts = m_omxPlayerVideo.GetCurrentPts();
     double dDiff = 0;
 
     if( apts != DVD_NOPTS_VALUE && vpts != DVD_NOPTS_VALUE )
@@ -2674,28 +2841,29 @@ void COMXPlayer::GetGeneralInfo(CStdString& strGeneralInfo)
         strBuf.AppendFormat(" %d sec", DVD_TIME_TO_SEC(m_State.cache_delay));
     }
 
-    strGeneralInfo.Format("C( ad:% 6.3f, a/v:% 6.3f%s, dcpu:%2i%% acpu:%2i%% vcpu:%2i%%%s, omx vb:%8d ad:% 6.3f )"
-                         , dDelay
+    strGeneralInfo.Format("C( ad:% 6.3f a/v:% 6.3f%s, dcpu:%2i%% acpu:%2i%% vcpu:%2i%%%s af:%d%% vf:%d%% amp:% 5.2f )"
+                         , m_omxPlayerAudio.GetDelay()
                          , dDiff
                          , strEDL.c_str()
                          , (int)(CThread::GetRelativeUsage()*100)
-                         , (int)(m_player_audio.GetRelativeUsage()*100)
-                         , (int)(m_player_video.GetRelativeUsage()*100)
+                         , (int)(m_omxPlayerAudio.GetRelativeUsage()*100)
+                         , (int)(m_omxPlayerVideo.GetRelativeUsage()*100)
                          , strBuf.c_str()
-                         , m_player_video.GetFreeSpace()
-                         , m_player_audio.GetDelay());
+                         , m_audio_fifo
+                         , m_video_fifo
+                         , m_omxPlayerAudio.GetDynamicRangeAmplification());
 
   }
 }
 
-void COMXPlayer::SeekPercentage(float fPercent)
+void COMXPlayer::SeekPercentage(float iPercent)
 {
   int64_t iTotalTime = GetTotalTimeInMsec();
 
   if (!iTotalTime)
     return;
 
-  SeekTime((int64_t)(iTotalTime * fPercent / 100));
+  SeekTime((int64_t)(iTotalTime * iPercent / 100));
 }
 
 float COMXPlayer::GetPercentage()
@@ -2716,22 +2884,22 @@ float COMXPlayer::GetCachePercentage()
 
 void COMXPlayer::SetAVDelay(float fValue)
 {
-  m_player_video.SetDelay(fValue * DVD_TIME_BASE);
+  m_omxPlayerVideo.SetDelay(fValue * DVD_TIME_BASE);
 }
 
 float COMXPlayer::GetAVDelay()
 {
-  return m_player_video.GetDelay() / (float)DVD_TIME_BASE;
+  return m_omxPlayerVideo.GetDelay() / (float)DVD_TIME_BASE;
 }
 
 void COMXPlayer::SetSubTitleDelay(float fValue)
 {
-  m_player_video.SetSubtitleDelay(-fValue * DVD_TIME_BASE);
+  m_omxPlayerVideo.SetSubtitleDelay(-fValue * DVD_TIME_BASE);
 }
 
 float COMXPlayer::GetSubTitleDelay()
 {
-  return -m_player_video.GetSubtitleDelay() / DVD_TIME_BASE;
+  return -m_omxPlayerVideo.GetSubtitleDelay() / DVD_TIME_BASE;
 }
 
 // priority: 1: libdvdnav, 2: external subtitles, 3: muxed subtitles
@@ -2783,7 +2951,7 @@ bool COMXPlayer::GetSubtitleVisible()
       return pStream->IsSubtitleStreamEnabled();
   }
 
-  return m_player_video.IsSubtitleEnabled();
+  return m_omxPlayerVideo.IsSubtitleEnabled();
 }
 
 void COMXPlayer::SetSubtitleVisible(bool bVisible)
@@ -2828,7 +2996,7 @@ TextCacheStruct_t* COMXPlayer::GetTeletextCache()
   if (m_CurrentTeletext.id < 0)
     return 0;
 
-  return m_player_teletext.GetTeletextCache();
+  return m_dvdPlayerTeletext.GetTeletextCache();
 }
 
 void COMXPlayer::LoadPage(int p, int sp, unsigned char* buffer)
@@ -2836,7 +3004,7 @@ void COMXPlayer::LoadPage(int p, int sp, unsigned char* buffer)
   if (m_CurrentTeletext.id < 0)
       return;
 
-  return m_player_teletext.LoadPage(p, sp, buffer);
+  return m_dvdPlayerTeletext.LoadPage(p, sp, buffer);
 }
 
 void COMXPlayer::SeekTime(int64_t iTime)
@@ -2855,12 +3023,12 @@ int64_t COMXPlayer::GetTime()
   const double limit  = DVD_MSEC_TO_TIME(200);
   if(m_State.timestamp > 0)
   {
-    offset  = m_av_clock.GetAbsoluteClock() - m_State.timestamp;
+    offset  = m_clock.GetAbsoluteClock() - m_State.timestamp;
     offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
     if(offset >  limit) offset =  limit;
     if(offset < -limit) offset = -limit;
   }
-  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)m_State.time, (double)m_State.timestamp, (int)DVD_TIME_TO_MSEC(m_State.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime()), (int)m_playSpeed, (int)m_caching, llrint(m_State.time + DVD_TIME_TO_MSEC(offset)));}
+  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)m_State.time, (double)m_State.timestamp, (int)DVD_TIME_TO_MSEC(m_State.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_stamp), (int)m_playSpeed, (int)m_caching, llrint(m_State.time + DVD_TIME_TO_MSEC(offset)));}
   return llrint(m_State.time + DVD_TIME_TO_MSEC(offset));
 }
 
@@ -2882,11 +3050,6 @@ void COMXPlayer::ToFFRW(int iSpeed)
   // can't rewind in menu as seeking isn't possible
   // forward is fine
   if (iSpeed < 0 && IsInMenu()) return;
-
-  /* only pause and normal playspeeds are allowed */
-  if(iSpeed > 1 || iSpeed < 0)
-    return;
-
   SetPlaySpeed(iSpeed * DVD_PLAYSPEED_NORMAL);
 }
 
@@ -2926,7 +3089,7 @@ bool COMXPlayer::OpenAudioStream(int iStream, int source, bool reset)
   if(m_CurrentAudio.id    < 0
   || m_CurrentAudio.hint != hint)
   {
-    if(!m_player_audio.OpenStream(hint))
+    if(!m_omxPlayerAudio.OpenStream(hint))
     {
       /* mark stream as disabled, to disallaw further attempts*/
       CLog::Log(LOGWARNING, "%s - Unsupported stream %d. Stream disabled.", __FUNCTION__, iStream);
@@ -2934,11 +3097,9 @@ bool COMXPlayer::OpenAudioStream(int iStream, int source, bool reset)
       pStream->SetDiscard(AVDISCARD_ALL);
       return false;
     }
-    m_av_clock.SetSpeed(DVD_PLAYSPEED_NORMAL);
-    m_av_clock.OMXSetSpeed(DVD_PLAYSPEED_NORMAL);
   }
   else if (reset)
-    m_player_audio.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerAudio.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
   /* store information about stream */
   m_CurrentAudio.id = iStream;
@@ -2946,13 +3107,14 @@ bool COMXPlayer::OpenAudioStream(int iStream, int source, bool reset)
   m_CurrentAudio.hint = hint;
   m_CurrentAudio.stream = (void*)pStream;
   m_CurrentAudio.started = false;
+  m_clock.SetMasterClock(false);
   m_HasAudio = true;
 
   /* we are potentially going to be waiting on this */
-  m_player_audio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
+  m_omxPlayerAudio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
 
-  /* software decoding normaly consumes full cpu time so prio it */
-  m_player_audio.SetPriority(GetPriority()+1);
+  /* audio normally won't consume full cpu, so let it have prio */
+  m_omxPlayerAudio.SetPriority(GetPriority()+1);
 
   return true;
 }
@@ -3007,7 +3169,7 @@ bool COMXPlayer::OpenVideoStream(int iStream, int source, bool reset)
   if(m_CurrentVideo.id    < 0
   || m_CurrentVideo.hint != hint)
   {
-    if (!m_player_video.OpenStream(hint))
+    if (!m_omxPlayerVideo.OpenStream(hint))
     {
       /* mark stream as disabled, to disallaw further attempts */
       CLog::Log(LOGWARNING, "%s - Unsupported stream %d. Stream disabled.", __FUNCTION__, iStream);
@@ -3015,18 +3177,16 @@ bool COMXPlayer::OpenVideoStream(int iStream, int source, bool reset)
       pStream->SetDiscard(AVDISCARD_ALL);
       return false;
     }
-    m_av_clock.SetSpeed(DVD_PLAYSPEED_NORMAL);
-    m_av_clock.OMXSetSpeed(DVD_PLAYSPEED_NORMAL);
   }
   else if (reset)
-    m_player_video.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
   unsigned flags = 0;
   if(m_filename.find("3DSBS") != string::npos || m_filename.find("HSBS") != string::npos)
     flags = CONF_FLAGS_FORMAT_SBS;
   else if(m_filename.find("3DTAB") != string::npos || m_filename.find("HTAB") != string::npos)
     flags = CONF_FLAGS_FORMAT_TB;
-  m_player_video.SetFlags(flags);
+  m_omxPlayerVideo.SetFlags(flags);
 
   /* store information about stream */
   m_CurrentVideo.id = iStream;
@@ -3037,11 +3197,11 @@ bool COMXPlayer::OpenVideoStream(int iStream, int source, bool reset)
   m_HasVideo = true;
 
   /* we are potentially going to be waiting on this */
-  m_player_video.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
+  m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
 
   /* use same priority for video thread as demuxing thread, as */
   /* otherwise demuxer will starve if video consumes the full cpu */
-  m_player_video.SetPriority(GetPriority());
+  m_omxPlayerVideo.SetPriority(GetPriority());
 
   return true;
 }
@@ -3074,7 +3234,7 @@ bool COMXPlayer::OpenSubtitleStream(int iStream, int source)
     if(!pStream || pStream->disabled)
       return false;
     pStream->SetDiscard(AVDISCARD_NONE);
-    double pts = m_player_video.GetCurrentPTS();
+    double pts = m_omxPlayerVideo.GetCurrentPts();
     if(pts == DVD_NOPTS_VALUE)
       pts = m_CurrentVideo.dts;
     if(pts == DVD_NOPTS_VALUE)
@@ -3119,7 +3279,7 @@ bool COMXPlayer::OpenSubtitleStream(int iStream, int source)
       CloseSubtitleStream(false);
     }
 
-    if(!m_player_subtitle.OpenStream(hint, filename))
+    if(!m_dvdPlayerSubtitle.OpenStream(hint, filename))
     {
       CLog::Log(LOGWARNING, "%s - Unsupported stream %d. Stream disabled.", __FUNCTION__, iStream);
       if(pStream)
@@ -3131,7 +3291,7 @@ bool COMXPlayer::OpenSubtitleStream(int iStream, int source)
     }
   }
   else
-    m_player_subtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_dvdPlayerSubtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
   m_CurrentSubtitle.id     = iStream;
   m_CurrentSubtitle.source = source;
@@ -3153,7 +3313,7 @@ bool COMXPlayer::OpenTeletextStream(int iStream, int source)
 
   CDVDStreamInfo hint(*pStream, true);
 
-  if (!m_player_teletext.CheckStream(hint))
+  if (!m_dvdPlayerTeletext.CheckStream(hint))
     return false;
 
   CLog::Log(LOGNOTICE, "Opening teletext stream: %i source: %i", iStream, source);
@@ -3167,7 +3327,7 @@ bool COMXPlayer::OpenTeletextStream(int iStream, int source)
       CloseTeletextStream(true);
     }
 
-    if (!m_player_teletext.OpenStream(hint))
+    if (!m_dvdPlayerTeletext.OpenStream(hint))
     {
       /* mark stream as disabled, to disallaw further attempts*/
       CLog::Log(LOGWARNING, "%s - Unsupported teletext stream %d. Stream disabled.", __FUNCTION__, iStream);
@@ -3177,7 +3337,7 @@ bool COMXPlayer::OpenTeletextStream(int iStream, int source)
     }
   }
   else
-    m_player_teletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_dvdPlayerTeletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
   /* store information about stream */
   m_CurrentTeletext.id      = iStream;
@@ -3199,7 +3359,7 @@ bool COMXPlayer::CloseAudioStream(bool bWaitForBuffers)
   if(bWaitForBuffers)
     SetCaching(CACHESTATE_DONE);
 
-  m_player_audio.CloseStream(bWaitForBuffers);
+  m_omxPlayerAudio.CloseStream(bWaitForBuffers);
 
   m_CurrentAudio.Clear();
   return true;
@@ -3215,7 +3375,7 @@ bool COMXPlayer::CloseVideoStream(bool bWaitForBuffers)
   if(bWaitForBuffers)
     SetCaching(CACHESTATE_DONE);
 
-  m_player_video.CloseStream(bWaitForBuffers);
+  m_omxPlayerVideo.CloseStream(bWaitForBuffers);
 
   m_CurrentVideo.Clear();
   return true;
@@ -3228,7 +3388,7 @@ bool COMXPlayer::CloseSubtitleStream(bool bKeepOverlays)
 
   CLog::Log(LOGNOTICE, "Closing subtitle stream");
 
-  m_player_subtitle.CloseStream(!bKeepOverlays);
+  m_dvdPlayerSubtitle.CloseStream(!bKeepOverlays);
 
   m_CurrentSubtitle.Clear();
   return true;
@@ -3244,7 +3404,7 @@ bool COMXPlayer::CloseTeletextStream(bool bWaitForBuffers)
   if(bWaitForBuffers)
     SetCaching(CACHESTATE_DONE);
 
-  m_player_teletext.CloseStream(bWaitForBuffers);
+  m_dvdPlayerTeletext.CloseStream(bWaitForBuffers);
 
   m_CurrentTeletext.Clear();
   return true;
@@ -3256,7 +3416,13 @@ void COMXPlayer::FlushBuffers(bool queued, double pts, bool accurate)
 
   CLog::Log(LOGNOTICE, "FlushBuffers: q:%d pts:%.0f a:%d", queued, pts, accurate);
 
-  if(accurate)
+  if (!TP(m_playSpeed))
+    m_av_clock.OMXStop();
+  m_av_clock.OMXPause();
+  m_stepped           = false;
+
+  /* for now, ignore accurate flag as it discards keyframes and causes corrupt frames */
+  if(0 && accurate)
     startpts = pts;
   else
     startpts = DVD_NOPTS_VALUE;
@@ -3283,19 +3449,19 @@ void COMXPlayer::FlushBuffers(bool queued, double pts, bool accurate)
 
   if(queued)
   {
-    m_player_audio.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
-    m_player_video.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
-    m_player_video.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
-    m_player_subtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
-    m_player_teletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerAudio.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
+    m_dvdPlayerSubtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_dvdPlayerTeletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
     SynchronizePlayers(SYNCSOURCE_ALL);
   }
   else
   {
-    m_player_video.Flush();
-    m_player_audio.Flush();
-    m_player_subtitle.Flush();
-    m_player_teletext.Flush();
+    m_omxPlayerAudio.Flush();
+    m_omxPlayerVideo.Flush();
+    m_dvdPlayerSubtitle.Flush();
+    m_dvdPlayerTeletext.Flush();
 
     // clear subtitle and menu overlays
     m_overlayContainer.Clear();
@@ -3305,8 +3471,8 @@ void COMXPlayer::FlushBuffers(bool queued, double pts, bool accurate)
     {
       // make sure players are properly flushed, should put them in stalled state
       CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(1000, 0);
-      m_player_video.SendMessage(msg->Acquire(), 1);
-      m_player_audio.SendMessage(msg->Acquire(), 1);
+      m_omxPlayerAudio.SendMessage(msg->Acquire(), 1);
+      m_omxPlayerVideo.SendMessage(msg->Acquire(), 1);
       msg->Wait(&m_bStop, 0);
       msg->Release();
 
@@ -3322,7 +3488,7 @@ void COMXPlayer::FlushBuffers(bool queued, double pts, bool accurate)
     }
 
     if(pts != DVD_NOPTS_VALUE)
-      m_av_clock.Discontinuity(pts);
+      m_clock.Discontinuity(pts);
     UpdatePlayState(0);
   }
   // let clock know the new time so progress bar updates immediately
@@ -3344,7 +3510,7 @@ int COMXPlayer::OnDVDNavResult(void* pData, int iMessage)
     else if(iMessage == 3)
       m_dvd.iSelectedSPUStream   = *(int*)pData;
     else if(iMessage == 4)
-      m_player_video.EnableSubtitle(*(int*)pData ? true: false);
+      m_omxPlayerVideo.EnableSubtitle(*(int*)pData ? true: false);
 
     return 0;
   }
@@ -3378,7 +3544,7 @@ int COMXPlayer::OnDVDNavResult(void* pData, int iMessage)
           DWORD time = 0;
           if( m_CurrentVideo.stream && m_dvd.iDVDStillTime > 0 )
           {
-            time = (DWORD)(m_player_video.GetOutputDelay() / ( DVD_TIME_BASE / 1000 ));
+            time = (DWORD)(m_omxPlayerVideo.GetOutputDelay() / ( DVD_TIME_BASE / 1000 ));
             if( time < 10000 && time > 0 )
               m_dvd.iDVDStillTime += time;
           }
@@ -3392,7 +3558,7 @@ int COMXPlayer::OnDVDNavResult(void* pData, int iMessage)
       break;
     case DVDNAV_SPU_CLUT_CHANGE:
       {
-        m_player_subtitle.SendMessage(new CDVDMsgSubtitleClutChange((BYTE*)pData));
+        m_dvdPlayerSubtitle.SendMessage(new CDVDMsgSubtitleClutChange((BYTE*)pData));
       }
       break;
     case DVDNAV_SPU_STREAM_CHANGE:
@@ -3402,7 +3568,7 @@ int COMXPlayer::OnDVDNavResult(void* pData, int iMessage)
         int iStream = event->physical_wide;
         bool visible = !(iStream & 0x80);
 
-        m_player_video.EnableSubtitle(visible);
+        m_omxPlayerVideo.EnableSubtitle(visible);
 
         if (iStream >= 0)
           m_dvd.iSelectedSPUStream = (iStream & ~0x80);
@@ -3432,7 +3598,7 @@ int COMXPlayer::OnDVDNavResult(void* pData, int iMessage)
         //dvdnav_highlight_event_t* pInfo = (dvdnav_highlight_event_t*)pData;
         int iButton = pStream->GetCurrentButton();
         CLog::Log(LOGDEBUG, "DVDNAV_HIGHLIGHT: Highlight button %d\n", iButton);
-        m_player_subtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_NORMAL);
+        m_dvdPlayerSubtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_NORMAL);
       }
       break;
     case DVDNAV_VTS_CHANGE:
@@ -3445,8 +3611,8 @@ int COMXPlayer::OnDVDNavResult(void* pData, int iMessage)
 
         //Force an aspect ratio that is set in the dvdheaders if available
         m_CurrentVideo.hint.aspect = pStream->GetVideoAspectRatio();
-        if( m_player_video.IsInited() )
-          m_player_video.SendMessage(new CDVDMsgDouble(CDVDMsg::VIDEO_SET_ASPECT, m_CurrentVideo.hint.aspect));
+        if( m_omxPlayerVideo.IsInited() )
+          m_omxPlayerVideo.SendMessage(new CDVDMsgDouble(CDVDMsg::VIDEO_SET_ASPECT, m_CurrentVideo.hint.aspect));
 
         m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_NAV);
         m_SelectionStreams.Update(m_pInputStream, m_pDemuxer);
@@ -3461,8 +3627,8 @@ int COMXPlayer::OnDVDNavResult(void* pData, int iMessage)
 
         m_dvd.state = DVDSTATE_NORMAL;
 
-        if( m_player_video.IsInited() )
-          m_player_video.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
+        if( m_omxPlayerVideo.IsInited() )
+          m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
       }
       break;
     case DVDNAV_NAV_PACKET:
@@ -3667,7 +3833,7 @@ bool COMXPlayer::OnAction(const CAction &action)
           CLog::Log(LOGDEBUG, " - button select");
           // show button pushed overlay
           if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
-            m_player_subtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_CLICKED);
+            m_dvdPlayerSubtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_CLICKED);
 
           pMenus->ActivateButton();
         }
@@ -3783,15 +3949,15 @@ bool COMXPlayer::HasMenu()
 
 bool COMXPlayer::GetCurrentSubtitle(CStdString& strSubtitle)
 {
+  double pts = m_av_clock.OMXMediaTime();
+
   if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
     return false;
 
-  double pts = m_av_clock.OMXMediaTime(false);
-
-  m_player_subtitle.GetCurrentSubtitle(strSubtitle, pts - m_player_video.GetSubtitleDelay());
+  m_dvdPlayerSubtitle.GetCurrentSubtitle(strSubtitle, pts - m_omxPlayerVideo.GetSubtitleDelay());
 
   // In case we stalled, don't output any subs
-  if ((m_player_video.IsStalled() && HasVideo()) || (m_player_audio.IsStalled() && HasAudio()))
+  if ((m_omxPlayerVideo.IsStalled() && HasVideo()) || (m_omxPlayerAudio.IsStalled() && HasAudio()))
     strSubtitle = m_lastSub;
   else
     m_lastSub = strSubtitle;
@@ -3859,19 +4025,19 @@ int COMXPlayer::GetCacheLevel() const
 
 double COMXPlayer::GetQueueTime()
 {
-  int a = m_player_video.GetLevel();
-  int v = m_player_audio.GetLevel();
+  int a = m_omxPlayerVideo.GetLevel();
+  int v = m_omxPlayerAudio.GetLevel();
   return max(a, v) * 8000.0 / 100;
 }
 
 int COMXPlayer::GetAudioBitrate()
 {
-  return m_player_audio.GetAudioBitrate();
+  return m_omxPlayerAudio.GetAudioBitrate();
 }
 
 int COMXPlayer::GetVideoBitrate()
 {
-  return m_player_video.GetVideoBitrate();
+  return m_omxPlayerVideo.GetVideoBitrate();
 }
 
 int COMXPlayer::GetSourceBitrate()
@@ -3920,7 +4086,7 @@ int COMXPlayer::AddSubtitleFile(const std::string& filename, const std::string&
 void COMXPlayer::UpdatePlayState(double timeout)
 {
   if(m_State.timestamp != 0
-  && m_State.timestamp + DVD_MSEC_TO_TIME(timeout) > m_av_clock.GetAbsoluteClock())
+  && m_State.timestamp + DVD_MSEC_TO_TIME(timeout) > m_clock.GetAbsoluteClock())
     return;
 
   SPlayerState state(m_State);
@@ -3940,7 +4106,7 @@ void COMXPlayer::UpdatePlayState(double timeout)
 
     // TODO : workaround until omx clock handling is rewritten
     if(m_playSpeed == DVD_PLAYSPEED_NORMAL)
-      state.time       = DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime(true));
+      state.time       = DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime());
     else
       state.time       = DVD_TIME_TO_MSEC(m_av_clock.GetClock() + m_offset_pts);
     state.time_total = m_pDemuxer->GetStreamLength();
@@ -4045,8 +4211,8 @@ void COMXPlayer::UpdatePlayState(double timeout)
   else
     state.cache_bytes = 0;
 
-  state.timestamp = m_av_clock.GetAbsoluteClock();
-  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)state.time, (double)state.timestamp, (int)DVD_TIME_TO_MSEC(state.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime()), (int)m_playSpeed, (int)m_caching, llrint(state.time + DVD_TIME_TO_MSEC(offset)));}
+  state.timestamp = m_clock.GetAbsoluteClock();
+  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)state.time, (double)state.timestamp, (int)DVD_TIME_TO_MSEC(state.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_stamp), (int)m_playSpeed, (int)m_caching, llrint(state.time + DVD_TIME_TO_MSEC(offset)));}
 
   CSingleLock lock(m_StateSection);
   m_State = state;
@@ -4055,7 +4221,7 @@ void COMXPlayer::UpdatePlayState(double timeout)
 void COMXPlayer::UpdateApplication(double timeout)
 {
   if(m_UpdateApplication != 0
-  && m_UpdateApplication + DVD_MSEC_TO_TIME(timeout) > m_av_clock.GetAbsoluteClock())
+  && m_UpdateApplication + DVD_MSEC_TO_TIME(timeout) > m_clock.GetAbsoluteClock())
     return;
 
   CDVDInputStream::IChannel* pStream = dynamic_cast<CDVDInputStream::IChannel*>(m_pInputStream);
@@ -4068,7 +4234,7 @@ void COMXPlayer::UpdateApplication(double timeout)
       CApplicationMessenger::Get().SetCurrentItem(item);
     }
   }
-  m_UpdateApplication = m_av_clock.GetAbsoluteClock();
+  m_UpdateApplication = m_clock.GetAbsoluteClock();
 }
 
 bool COMXPlayer::CanRecord()
@@ -4173,7 +4339,7 @@ bool COMXPlayer::GetStreamDetails(CStreamDetails &details)
 CStdString COMXPlayer::GetPlayingTitle()
 {
   /* Currently we support only Title Name from Teletext line 30 */
-  TextCacheStruct_t* ttcache = m_player_teletext.GetTeletextCache();
+  TextCacheStruct_t* ttcache = m_dvdPlayerTeletext.GetTeletextCache();
   if (ttcache && !ttcache->line30.empty())
     return ttcache->line30;
 
@@ -4210,54 +4376,12 @@ bool COMXPlayer::CachePVRStream(void) const
       g_advancedSettings.m_bPVRCacheInDvdPlayer;
 }
 
-void COMXPlayer::GetVideoRect(CRect& SrcRect, CRect& DestRect)
-{
-  g_renderManager.GetVideoRect(SrcRect, DestRect);
-}
-
-void COMXPlayer::SetMute(bool bOnOff)
-{
-  m_current_mute = bOnOff;
-  m_change_volume = true;
-}
-
-void COMXPlayer::SetVolume(float fVolume)
-{
-  m_current_volume = fVolume;
-  m_change_volume = true;
-}
-
-bool COMXPlayer::WaitForPausedThumbJobs(int timeout_ms)
-{
-  // use m_bStop and Sleep so we can get canceled.
-  while (!m_bStop && (timeout_ms > 0))
-  {
-    if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
-    {
-      Sleep(100);
-      timeout_ms -= 100;
-    }
-    else
-      return true;
-  }
-
-  return false;
-}
-
-void COMXPlayer::Update(bool bPauseDrawing)
-{
-  g_renderManager.Update(bPauseDrawing);
-}
-
-void COMXPlayer::GetVideoAspectRatio(float &fAR)
-{
-  fAR = g_renderManager.GetAspectRatio();
-}
-
 void COMXPlayer::GetRenderFeatures(std::vector<int> &renderFeatures)
 {
   renderFeatures.push_back(RENDERFEATURE_STRETCH);
   renderFeatures.push_back(RENDERFEATURE_CROP);
+  renderFeatures.push_back(RENDERFEATURE_PIXEL_RATIO);
+  renderFeatures.push_back(RENDERFEATURE_ZOOM);
 }
 
 void COMXPlayer::GetDeinterlaceMethods(std::vector<int> &deinterlaceMethods)
@@ -4281,6 +4405,7 @@ void COMXPlayer::GetAudioCapabilities(std::vector<int> &audioCaps)
   audioCaps.push_back(IPC_AUD_OFFSET);
   audioCaps.push_back(IPC_AUD_SELECT_STREAM);
   audioCaps.push_back(IPC_AUD_SELECT_OUTPUT);
+  audioCaps.push_back(IPC_AUD_AMP);
 }
 
 void COMXPlayer::GetSubtitleCapabilities(std::vector<int> &subCaps)
diff --git a/xbmc/cores/omxplayer/OMXPlayer.h b/xbmc/cores/omxplayer/OMXPlayer.h
index d6c9d66..0f5ce6b 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.h
+++ b/xbmc/cores/omxplayer/OMXPlayer.h
@@ -1,6 +1,7 @@
 #pragma once
+
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2005-2012 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -19,21 +20,12 @@
  *
  */
 
-#if defined(HAVE_CONFIG_H) && !defined(TARGET_WINDOWS)
-#include "config.h"
-#define DECLARE_UNUSED(a,b) a __attribute__((unused)) b;
-#endif
-
-#include <semaphore.h>
-#include <deque>
-
-#include "FileItem.h"
 #include "cores/IPlayer.h"
-#include "cores/dvdplayer/IDVDPlayer.h"
-#include "dialogs/GUIDialogBusy.h"
 #include "threads/Thread.h"
-#include "threads/SingleLock.h"
 
+#include "cores/dvdplayer/IDVDPlayer.h"
+
+#include "DVDMessageQueue.h"
 #include "OMXCore.h"
 #include "OMXClock.h"
 #include "OMXPlayerAudio.h"
@@ -41,32 +33,32 @@
 #include "DVDPlayerSubtitle.h"
 #include "DVDPlayerTeletext.h"
 
+//#include "DVDChapterReader.h"
+#include "DVDSubtitles/DVDFactorySubtitle.h"
 #include "utils/BitstreamStats.h"
 
 #include "linux/DllBCM.h"
 #include "Edl.h"
+#include "FileItem.h"
+#include "threads/SingleLock.h"
 
-#define MAX_CHAPTERS 64
-
-#define DVDPLAYER_AUDIO    1
-#define DVDPLAYER_VIDEO    2
-#define DVDPLAYER_SUBTITLE 3
-#define DVDPLAYER_TELETEXT 4
-
-#define DVDSTATE_NORMAL           0x00000001 // normal dvd state
-#define DVDSTATE_STILL            0x00000002 // currently displaying a still frame
-#define DVDSTATE_WAIT             0x00000003 // waiting for demuxer read error
-#define DVDSTATE_SEEK             0x00000004 // we are finishing a seek request
+class CDVDInputStream;
 
 class COMXPlayer;
 class OMXPlayerVideo;
 class OMXPlayerAudio;
+class CStreamInfo;
 
 namespace PVR
 {
   class CPVRChannel;
 }
 
+#define DVDSTATE_NORMAL           0x00000001 // normal dvd state
+#define DVDSTATE_STILL            0x00000002 // currently displaying a still frame
+#define DVDSTATE_WAIT             0x00000003 // waiting for demuxer read error
+#define DVDSTATE_SEEK             0x00000004 // we are finishing a seek request
+
 class COMXCurrentStream
 {
 public:
@@ -166,83 +158,50 @@ class COMXSelectionStreams
 };
 
 
+#define DVDPLAYER_AUDIO    1
+#define DVDPLAYER_VIDEO    2
+#define DVDPLAYER_SUBTITLE 3
+#define DVDPLAYER_TELETEXT 4
+
 class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
 {
 public:
-
   COMXPlayer(IPlayerCallback &callback);
   virtual ~COMXPlayer();
   
-  virtual void RegisterAudioCallback(IAudioCallback* pCallback) { m_player_audio.RegisterAudioCallback(pCallback); };
-  virtual void UnRegisterAudioCallback()                        { m_player_audio.UnRegisterAudioCallback();        };
-
-  virtual bool  IsValidStream(COMXCurrentStream& stream);
-  virtual bool  IsBetterStream(COMXCurrentStream& current, CDemuxStream* stream);
-  virtual bool  CheckDelayedChannelEntry(void);
-  virtual bool  ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream);
-  virtual bool  CloseAudioStream(bool bWaitForBuffers);
-  virtual bool  CloseVideoStream(bool bWaitForBuffers);
-  virtual bool  CloseSubtitleStream(bool bKeepOverlays);
-  virtual bool  CloseTeletextStream(bool bWaitForBuffers);
-  virtual bool  OpenAudioStream(int iStream, int source, bool reset = true);
-  virtual bool  OpenVideoStream(int iStream, int source, bool reset = true);
-  virtual bool  OpenSubtitleStream(int iStream, int source); 
-  virtual bool  OpenTeletextStream(int iStream, int source);
-  virtual void  OpenDefaultStreams(bool reset = true);
-  virtual bool  OpenDemuxStream();
-  virtual bool  OpenInputStream();
-  virtual bool  CheckPlayerInit(COMXCurrentStream& current, unsigned int source);
-  virtual void  UpdateCorrection(DemuxPacket* pkt, double correction);
-  virtual void  UpdateTimestamps(COMXCurrentStream& current, DemuxPacket* pPacket);
-  virtual void  UpdateLimits(double& minimum, double& maximum, double dts);
-  virtual bool  CheckSceneSkip(COMXCurrentStream& current);
-  virtual void  CheckAutoSceneSkip();
-  virtual void  CheckContinuity(COMXCurrentStream& current, DemuxPacket* pPacket);
-  virtual void  ProcessAudioData(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  ProcessVideoData(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  ProcessSubData(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  ProcessTeletextData(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  ProcessPacket(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  SynchronizeDemuxer(unsigned int timeout);
-  virtual void  SynchronizePlayers(unsigned int sources);
-  virtual void  SendPlayerMessage(CDVDMsg* pMsg, unsigned int target);
-  virtual void  HandleMessages();
-
   virtual bool  OpenFile(const CFileItem &file, const CPlayerOptions &options);
-  virtual bool  QueueNextFile(const CFileItem &file)             {return false;}
-  virtual void  OnNothingToQueueNotify()                         {}
   virtual bool  CloseFile();
   virtual bool  IsPlaying() const;
-  virtual void  SetPlaySpeed(int speed);
-  int GetPlaySpeed()                                                { return m_playSpeed; }
   virtual void  Pause();
   virtual bool  IsPaused() const;
   virtual bool  HasVideo() const;
   virtual bool  HasAudio() const;
   virtual bool  IsPassthrough() const;
   virtual bool  CanSeek();
-  virtual void  Seek(bool bPlus = true, bool bLargeStep = false);
+  virtual void Seek(bool bPlus, bool bLargeStep);
   virtual bool  SeekScene(bool bPlus = true);
-  virtual void  SeekPercentage(float fPercent = 0.0f);
+  virtual void SeekPercentage(float iPercent);
   virtual float GetPercentage();
   virtual float GetCachePercentage();
 
-  virtual void  SetMute(bool bOnOff);
-  virtual bool  ControlsVolume() {return true;}
-  virtual void  SetVolume(float fVolume);
-  virtual void  SetDynamicRangeCompression(long drc)              {}
-  virtual void  GetAudioInfo(CStdString &strAudioInfo);
-  virtual void  GetVideoInfo(CStdString &strVideoInfo);
-  virtual void  GetGeneralInfo(CStdString &strVideoInfo);
-  virtual void  Update(bool bPauseDrawing);
-  virtual void  GetVideoRect(CRect& SrcRect, CRect& DestRect);
-  virtual void  GetVideoAspectRatio(float &fAR);
-  virtual void  UpdateApplication(double timeout);
-  virtual bool  CanRecord();
-  virtual bool  IsRecording();
-  virtual bool  CanPause();
-  virtual bool  Record(bool bOnOff);
-  virtual void  SetAVDelay(float fValue = 0.0f);
+  virtual void RegisterAudioCallback(IAudioCallback* pCallback) { m_omxPlayerAudio.RegisterAudioCallback(pCallback); }
+  virtual void UnRegisterAudioCallback()                        { m_omxPlayerAudio.UnRegisterAudioCallback(); }
+  virtual void SetVolume(float nVolume)                         { m_omxPlayerAudio.SetVolume(nVolume); }
+  virtual void SetMute(bool bOnOff)                             { m_omxPlayerAudio.SetMute(bOnOff); }
+  virtual void SetDynamicRangeCompression(long drc)             { m_omxPlayerAudio.SetDynamicRangeCompression(drc); }
+  virtual bool ControlsVolume() {return true;}
+  virtual void GetAudioInfo(CStdString &strAudioInfo);
+  virtual void GetVideoInfo(CStdString &strVideoInfo);
+  virtual void GetGeneralInfo(CStdString &strVideoInfo);
+  virtual void Update(bool bPauseDrawing)                       {}
+  virtual void GetVideoRect(CRect& SrcRect, CRect& DestRect)    { g_renderManager.GetVideoRect(SrcRect, DestRect); }
+  virtual void GetVideoAspectRatio(float& fAR)                  { fAR = m_omxPlayerVideo.GetAspectRatio(); }
+
+  virtual bool CanRecord();
+  virtual bool IsRecording();
+  virtual bool CanPause();
+  virtual bool Record(bool bOnOff);
+  virtual void SetAVDelay(float fValue = 0.0f);
   virtual float GetAVDelay();
 
   virtual void  SetSubTitleDelay(float fValue = 0.0f);
@@ -271,28 +230,25 @@ class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
   virtual void  GetChapterName(CStdString& strChapterName);
   virtual int   SeekChapter(int iChapter);
 
-  virtual void  SeekTime(int64_t iTime = 0);
-  virtual int64_t GetTotalTimeInMsec();
+  virtual void SeekTime(int64_t iTime);
   virtual int64_t GetTime();
   virtual int64_t GetTotalTime();
-  virtual void  ToFFRW(int iSpeed = 0);
-  virtual int   GetAudioBitrate();
-  virtual int   GetVideoBitrate();
-  virtual int   GetSourceBitrate();
-  virtual int   GetChannels();
+  virtual void ToFFRW(int iSpeed);
+  virtual bool OnAction(const CAction &action);
+  virtual bool HasMenu();
+  virtual int GetAudioBitrate();
+  virtual int GetVideoBitrate();
+  virtual int GetSourceBitrate();
+  virtual int GetChannels();
   virtual CStdString GetAudioCodecName();
   virtual CStdString GetVideoCodecName();
   virtual int   GetPictureWidth();
   virtual int   GetPictureHeight();
   virtual bool  GetStreamDetails(CStreamDetails &details);
 
-  virtual bool  IsInMenu() const;
-  virtual bool  HasMenu();
-
   virtual bool  GetCurrentSubtitle(CStdString& strSubtitle);
-  //returns a state that is needed for resuming from a specific time
   virtual CStdString GetPlayerState();
-  virtual bool  SetPlayerState(CStdString state);
+  virtual bool SetPlayerState(CStdString state);
   
   virtual CStdString GetPlayingTitle();
 
@@ -308,23 +264,10 @@ class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
   , CACHESTATE_FLUSH    // temporary state player will choose startup between init or full
   };
 
-  int m_playSpeed;
-  struct SSpeedState
-  {
-    double lastpts;  // holds last display pts during ff/rw operations
-    double lasttime;
-  } m_SpeedState;
-
-  void    HandlePlaySpeed();
-  bool    GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
-  bool    CheckStartCaching(COMXCurrentStream& current);
-  void    SetCaching(ECacheState state);
-  double  GetQueueTime();
-  virtual bool  IsCaching() const                                 { return m_caching == CACHESTATE_FULL; }
+  virtual bool  IsCaching() const                                 { return m_caching == CACHESTATE_FULL || m_caching == CACHESTATE_PVR; }
   virtual int   GetCacheLevel() const;
 
   virtual int  OnDVDNavResult(void* pData, int iMessage);
-  virtual bool OnAction(const CAction &action);
 
   virtual void  GetRenderFeatures(std::vector<int> &renderFeatures);
   virtual void  GetDeinterlaceMethods(std::vector<int> &deinterlaceMethods);
@@ -343,19 +286,118 @@ class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
 
   virtual void  OnStartup();
   virtual void  OnExit();
-  bool WaitForPausedThumbJobs(int timeout_ms);
   virtual void  Process();
 
+  bool OpenAudioStream(int iStream, int source, bool reset = true);
+  bool OpenVideoStream(int iStream, int source, bool reset = true);
+  bool OpenSubtitleStream(int iStream, int source);
+  bool OpenTeletextStream(int iStream, int source);
+  bool CloseAudioStream(bool bWaitForBuffers);
+  bool CloseVideoStream(bool bWaitForBuffers);
+  bool CloseSubtitleStream(bool bKeepOverlays);
+  bool CloseTeletextStream(bool bWaitForBuffers);
+
+  void ProcessPacket(CDemuxStream* pStream, DemuxPacket* pPacket);
+  void ProcessAudioData(CDemuxStream* pStream, DemuxPacket* pPacket);
+  void ProcessVideoData(CDemuxStream* pStream, DemuxPacket* pPacket);
+  void ProcessSubData(CDemuxStream* pStream, DemuxPacket* pPacket);
+  void ProcessTeletextData(CDemuxStream* pStream, DemuxPacket* pPacket);
+
+  bool ShowPVRChannelInfo();
+
+  int  AddSubtitleFile(const std::string& filename, const std::string& subfilename = "", CDemuxStream::EFlags flags = CDemuxStream::FLAG_NONE);
+
+  /**
+   * one of the DVD_PLAYSPEED defines
+   */
+  void SetPlaySpeed(int iSpeed);
+  int GetPlaySpeed()                                                { return m_playSpeed; }
+  void    SetCaching(ECacheState state);
+
+  int64_t GetTotalTimeInMsec();
+
+  double  GetQueueTime();
+  bool    GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
+
+
+  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
+
+
+  void  HandleMessages();
+  void    HandlePlaySpeed();
+  bool  IsInMenu() const;
+
+  void SynchronizePlayers(unsigned int sources);
+  void SynchronizeDemuxer(unsigned int timeout);
+  void CheckAutoSceneSkip();
+  void CheckContinuity(COMXCurrentStream& current, DemuxPacket* pPacket);
+  bool CheckSceneSkip(COMXCurrentStream& current);
+  bool CheckPlayerInit(COMXCurrentStream& current, unsigned int source);
+  bool CheckStartCaching(COMXCurrentStream& current);
+  void UpdateCorrection(DemuxPacket* pkt, double correction);
+  void UpdateTimestamps(COMXCurrentStream& current, DemuxPacket* pPacket);
+  void SendPlayerMessage(CDVDMsg* pMsg, unsigned int target);
+  bool ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream);
+  bool IsValidStream(COMXCurrentStream& stream);
+  bool IsBetterStream(COMXCurrentStream& current, CDemuxStream* stream);
+  bool CheckDelayedChannelEntry(void);
+  bool OpenInputStream();
+  bool OpenDemuxStream();
+  void OpenDefaultStreams(bool reset = true);
+
+  void UpdateApplication(double timeout);
+  void UpdatePlayState(double timeout);
+  double m_UpdateApplication;
+
+  bool m_bAbortRequest;
+
   std::string           m_filename; // holds the actual filename
-  CDVDInputStream       *m_pInputStream;
-  CDVDDemux             *m_pDemuxer;
+  std::string  m_mimetype;  // hold a hint to what content file contains (mime type)
+  ECacheState  m_caching;
+  CFileItem    m_item;
+  unsigned int m_iChannelEntryTimeOut;
+
+
+  COMXCurrentStream m_CurrentAudio;
+  COMXCurrentStream m_CurrentVideo;
+  COMXCurrentStream m_CurrentSubtitle;
+  COMXCurrentStream m_CurrentTeletext;
+
+  COMXSelectionStreams m_SelectionStreams;
+
+  int m_playSpeed;
+  struct SSpeedState
+  {
+    double lastpts;  // holds last display pts during ff/rw operations
+    double lasttime;
+  } m_SpeedState;
+
+  int m_errorCount;
+  double m_offset_pts;
+
+  CDVDMessageQueue m_messenger;     // thread messenger
+
+  OMXPlayerVideo m_omxPlayerVideo; // video part
+  OMXPlayerAudio m_omxPlayerAudio; // audio part
+  CDVDPlayerSubtitle m_dvdPlayerSubtitle; // subtitle part
+  CDVDTeletextData m_dvdPlayerTeletext; // teletext part
+
+  CDVDClock m_clock;                // master clock
+  OMXClock m_av_clock;
+
+  bool m_stepped;
+  int m_video_fifo;
+  int m_audio_fifo;
+  double m_last_check_time;         // we periodically check for gpu underrun
+  double m_stamp;                   // last media stamp
+
+  CDVDOverlayContainer m_overlayContainer;
+
+  CDVDInputStream* m_pInputStream;  // input stream for current playing file
+  CDVDDemux* m_pDemuxer;            // demuxer for current playing file
   CDVDDemux*            m_pSubtitleDemuxer;
-  COMXSelectionStreams  m_SelectionStreams;
-  std::string           m_mimetype;
-  COMXCurrentStream     m_CurrentAudio;
-  COMXCurrentStream     m_CurrentVideo;
-  COMXCurrentStream     m_CurrentSubtitle;
-  COMXCurrentStream     m_CurrentTeletext;
+
+  CStdString m_lastSub;
 
   struct SDVDInfo
   {
@@ -439,6 +481,9 @@ class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
   } m_State;
   CCriticalSection m_StateSection;
 
+  CEvent m_ready;
+  CCriticalSection m_critStreamSection; // need to have this lock when switching streams (audio / video)
+
   CEdl m_Edl;
 
   struct SEdlAutoSkipMarkers {
@@ -460,45 +505,7 @@ class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
 
   } m_EdlAutoSkipMarkers;
 
-  bool ShowPVRChannelInfo();
-
-  int  AddSubtitleFile(const std::string& filename, const std::string& subfilename = "", CDemuxStream::EFlags flags = CDemuxStream::FLAG_NONE);
-  virtual void UpdatePlayState(double timeout);
-
-  double m_UpdateApplication;
-
-  void RenderUpdateCallBack(const void *ctx, const CRect &SrcRect, const CRect &DestRect);
-
-private:
-  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
-
-  CCriticalSection        m_critStreamSection;
-
-  bool                    m_paused;
-  bool                    m_bAbortRequest;
-  CFileItem               m_item;
   CPlayerOptions          m_PlayerOptions;
-  unsigned int            m_iChannelEntryTimeOut;
-
-  std::string             m_lastSub;
-
-  double                  m_offset_pts;
-
-  CDVDMessageQueue        m_messenger;
-
-  OMXClock                m_av_clock;
-  OMXPlayerVideo          m_player_video;
-  OMXPlayerAudio          m_player_audio;
-  CDVDPlayerSubtitle      m_player_subtitle;
-  CDVDTeletextData        m_player_teletext;
-
-  CEvent                  m_ready;
-
-  float                   m_current_volume;
-  bool                    m_current_mute;
-  bool                    m_change_volume;
-  CDVDOverlayContainer    m_overlayContainer;
-  ECacheState             m_caching;
 
   bool m_HasVideo;
   bool m_HasAudio;
diff --git a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
index e309d2e..f9c1b7d 100644
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
@@ -42,6 +42,7 @@
 #include "utils/TimeUtils.h"
 
 #include "OMXPlayer.h"
+#include "linux/RBP.h"
 
 #include <iostream>
 #include <sstream>
@@ -72,18 +73,23 @@ OMXPlayerAudio::OMXPlayerAudio(OMXClock *av_clock, CDVDMessageQueue& parent)
   m_speed         = DVD_PLAYSPEED_NORMAL;
   m_started       = false;
   m_stalled       = false;
-  m_audioClock    = 0;
+  m_audioClock    = DVD_NOPTS_VALUE;
   m_buffer_empty  = false;
   m_nChannels     = 0;
   m_DecoderOpen   = false;
-  m_freq          = CurrentHostFrequency();
   m_bad_state     = false;
   m_hints_current.Clear();
 
-  m_av_clock->SetMasterClock(false);
+  bool small_mem = g_RBP.GetArmMem() < 256;
+  m_messageQueue.SetMaxDataSize((small_mem ? 3:6) * 1024 * 1024);
 
-  m_messageQueue.SetMaxDataSize(3 * 1024 * 1024);
   m_messageQueue.SetMaxTimeSize(8.0);
+  m_use_passthrough = false;
+  m_passthrough = false;
+  m_use_hw_decode = false;
+  m_hw_decode = false;
+  m_silence = false;
+  m_flush = false;
 }
 
 
@@ -134,24 +140,18 @@ void OMXPlayerAudio::OpenStream(CDVDStreamInfo &hints, COMXAudioCodecOMX *codec)
     m_hints.bitspersample = 16;
 
   m_speed           = DVD_PLAYSPEED_NORMAL;
-  m_audioClock      = 0;
-  m_error           = 0;
-  m_errorbuff       = 0;
-  m_errorcount      = 0;
-  m_integral        = 0;
-  m_skipdupcount    = 0;
-  m_prevskipped     = false;
-  m_syncclock       = true;
+  m_audioClock      = DVD_NOPTS_VALUE;
   m_hw_decode       = false;
-  m_errortime       = CurrentHostCounter();
   m_silence         = false;
   m_started         = false;
   m_flush           = false;
   m_nChannels       = 0;
-  m_synctype        = SYNC_DISCON;
   m_stalled         = m_messageQueue.GetPacketCount(CDVDMsg::DEMUXER_PACKET) == 0;
-  m_use_passthrough = (g_guiSettings.GetInt("audiooutput.mode") == AUDIO_HDMI) ? true : false ;
+  m_use_passthrough = (g_guiSettings.GetInt("audiooutput.mode") == AUDIO_HDMI && !g_guiSettings.GetBool("audiooutput.dualaudio")) ? true : false ;
   m_use_hw_decode   = g_advancedSettings.m_omxHWAudioDecode;
+  m_format.m_dataFormat    = GetDataFormat(m_hints);
+  m_format.m_sampleRate    = 0;
+  m_format.m_channelLayout = 0;
 }
 
 bool OMXPlayerAudio::CloseStream(bool bWaitForBuffers)
@@ -190,110 +190,6 @@ void OMXPlayerAudio::OnExit()
   CLog::Log(LOGNOTICE, "thread end: OMXPlayerAudio::OnExit()");
 }
 
-
-
-void OMXPlayerAudio::HandleSyncError(double duration)
-{
-  double clock = m_av_clock->GetClock();
-  double error = m_audioClock - clock;
-  int64_t now;
-
-  if( fabs(error) > DVD_MSEC_TO_TIME(100) || m_syncclock )
-  {
-    m_av_clock->Discontinuity(clock+error);
-    /*
-    if(m_speed == DVD_PLAYSPEED_NORMAL)
-    CLog::Log(LOGDEBUG, "OMXPlayerAudio:: Discontinuity - was:%f, should be:%f, error:%f\n", clock, clock+error, error);
-    */
-
-    m_errorbuff = 0;
-    m_errorcount = 0;
-    m_skipdupcount = 0;
-    m_error = 0;
-    m_syncclock = false;
-    m_errortime = CurrentHostCounter();
-
-    return;
-  }
-
-  if (m_speed != DVD_PLAYSPEED_NORMAL)
-  {
-    m_errorbuff = 0;
-    m_errorcount = 0;
-    m_integral = 0;
-    m_skipdupcount = 0;
-    m_error = 0;
-    m_errortime = CurrentHostCounter();
-    return;
-  }
-
-  //check if measured error for 1 second
-  now = CurrentHostCounter();
-  if ((now - m_errortime) >= m_freq)
-  {
-    m_errortime = now;
-    m_error = m_errorbuff / m_errorcount;
-
-    m_errorbuff = 0;
-    m_errorcount = 0;
-
-    if (m_synctype == SYNC_DISCON)
-    {
-      double limit, error;
-
-      if (m_av_clock->GetRefreshRate(&limit) > 0)
-      {
-        //when the videoreferenceclock is running, the discontinuity limit is one vblank period
-        limit *= DVD_TIME_BASE;
-
-        //make error a multiple of limit, rounded towards zero,
-        //so it won't interfere with the sync methods in CXBMCRenderManager::WaitPresentTime
-        if (m_error > 0.0)
-          error = limit * floor(m_error / limit);
-        else
-          error = limit * ceil(m_error / limit);
-      }
-      else
-      {
-        limit = DVD_MSEC_TO_TIME(10);
-        error = m_error;
-      }
-
-      /*
-      limit = DVD_MSEC_TO_TIME(10);
-      error = m_error;
-      */
-
-      if (fabs(error) > limit - 0.001)
-      {
-        m_av_clock->Discontinuity(clock+error);
-        /*
-        if(m_speed == DVD_PLAYSPEED_NORMAL)
-          CLog::Log(LOGDEBUG, "COMXPlayerAudio:: Discontinuity - was:%f, should be:%f, error:%f", clock, clock+error, error);
-        */
-      }
-    }
-    /*
-    else if (m_synctype == SYNC_SKIPDUP && m_skipdupcount == 0 && fabs(m_error) > DVD_MSEC_TO_TIME(10))
-    if (m_skipdupcount == 0 && fabs(m_error) > DVD_MSEC_TO_TIME(10))
-    {
-      //check how many packets to skip/duplicate
-      m_skipdupcount = (int)(m_error / duration);
-      //if less than one frame off, see if it's more than two thirds of a frame, so we can get better in sync
-      if (m_skipdupcount == 0 && fabs(m_error) > duration / 3 * 2)
-        m_skipdupcount = (int)(m_error / (duration / 3 * 2));
-
-      if (m_skipdupcount > 0)
-        CLog::Log(LOGDEBUG, "OMXPlayerAudio:: Duplicating %i packet(s) of %.2f ms duration",
-                  m_skipdupcount, duration / DVD_TIME_BASE * 1000.0);
-      else if (m_skipdupcount < 0)
-        CLog::Log(LOGDEBUG, "OMXPlayerAudio:: Skipping %i packet(s) of %.2f ms duration ",
-                  m_skipdupcount * -1,  duration / DVD_TIME_BASE * 1000.0);
-    }
-    */
-  }
-}
-
 bool OMXPlayerAudio::CodecChange()
 {
   unsigned int old_bitrate = m_hints.bitrate;
@@ -308,13 +204,15 @@ bool OMXPlayerAudio::CodecChange()
   /* only check bitrate changes on CODEC_ID_DTS, CODEC_ID_AC3, CODEC_ID_EAC3 */
   if(m_hints.codec != CODEC_ID_DTS && m_hints.codec != CODEC_ID_AC3 && m_hints.codec != CODEC_ID_EAC3)
     new_bitrate = old_bitrate = 0;
-    
+
+  // for passthrough we only care about the codec and the samplerate
+  bool minor_change = m_hints_current.channels       != m_hints.channels ||
+                      m_hints_current.bitspersample  != m_hints.bitspersample ||
+                      old_bitrate                    != new_bitrate;
+
   if(m_hints_current.codec          != m_hints.codec ||
-     m_hints_current.channels       != m_hints.channels ||
      m_hints_current.samplerate     != m_hints.samplerate ||
-     m_hints_current.bitspersample  != m_hints.bitspersample ||
-     old_bitrate                    != new_bitrate ||
-     !m_DecoderOpen)
+     (!m_passthrough && minor_change) || !m_DecoderOpen)
   {
     m_hints_current = m_hints;
     return true;
@@ -334,7 +232,7 @@ bool OMXPlayerAudio::Decode(DemuxPacket *pkt, bool bDropPacket)
   const uint8_t *data_dec = pkt->pData;
   int            data_len = pkt->iSize;
 
-  if(!OMX_IS_RAW(m_format.m_dataFormat))
+  if(!OMX_IS_RAW(m_format.m_dataFormat) && !bDropPacket)
   {
     while(!m_bStop && data_len > 0)
     {
@@ -391,18 +289,12 @@ bool OMXPlayerAudio::Decode(DemuxPacket *pkt, bool bDropPacket)
           }
         }
 
-        int n = (m_nChannels * m_hints.bitspersample * m_hints.samplerate)>>3;
-        if (n > 0)
-          m_audioClock += ((double)decoded_size * DVD_TIME_BASE) / n;
-
-        if(m_speed == DVD_PLAYSPEED_NORMAL)
-          HandleSyncError((((double)decoded_size * DVD_TIME_BASE) / n));
         break;
 
       }
     }
   }
-  else
+  else if(!bDropPacket)
   {
     if(CodecChange())
     {
@@ -430,9 +322,6 @@ bool OMXPlayerAudio::Decode(DemuxPacket *pkt, bool bDropPacket)
         m_omxAudio.AddPackets(pkt->pData, pkt->iSize, m_audioClock, m_audioClock);
       }
 
-      if(m_speed == DVD_PLAYSPEED_NORMAL)
-        HandleSyncError(0);
-
       m_audioStats.AddSampleBytes(pkt->iSize);
 
       break;
@@ -442,16 +331,6 @@ bool OMXPlayerAudio::Decode(DemuxPacket *pkt, bool bDropPacket)
   if(bDropPacket)
     m_stalled = false;
 
-  if(m_omxAudio.GetCacheTime() < 0.1 /*&& min(99,m_messageQueue.GetLevel() + MathUtils::round_int(100.0/8.0*GetCacheTime())) > 10*/)
-  {
-    m_stalled = true;
-    if(!m_av_clock->OMXAudioBuffer() && m_av_clock->HasVideo() && m_speed == DVD_PLAYSPEED_NORMAL)
-    {
-      clock_gettime(CLOCK_REALTIME, &m_starttime);
-      m_av_clock->OMXAudioBufferStart();
-    }
-  }
-
   // signal to our parent that we have initialized
   if(m_started == false)
   {
@@ -497,23 +376,13 @@ void OMXPlayerAudio::Process()
       #endif
       if(Decode(pPacket, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0 || bPacketDrop))
       {
-        if (m_stalled && (m_omxAudio.GetCacheTime() > (AUDIO_BUFFER_SECONDS * 0.75f)))
+        // we are not running until something is cached in output device
+        if(m_stalled && m_omxAudio.GetCacheTime() > 0.0)
         {
           CLog::Log(LOGINFO, "COMXPlayerAudio - Switching to normal playback");
           m_stalled = false;
-          if(m_av_clock->HasVideo() && m_av_clock->OMXAudioBuffer())
-            m_av_clock->OMXAudioBufferStop();
         }
       }
-      // hard unlock audio out buffering
-      clock_gettime(CLOCK_REALTIME, &m_endtime);
-      //int iLevel = min(99,m_messageQueue.GetLevel() + MathUtils::round_int(100.0/8.0*GetCacheTime()));
-      if(/*iLevel < 10 &&*/ m_stalled && m_av_clock->OMXAudioBuffer() && (m_endtime.tv_sec - m_starttime.tv_sec) > 1)
-      {
-        m_stalled = false;
-        if(m_av_clock->HasVideo() && m_av_clock->OMXAudioBuffer())
-          m_av_clock->OMXAudioBufferStop();
-      }
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
     {
@@ -526,45 +395,36 @@ void OMXPlayerAudio::Process()
     { //player asked us to set internal clock
       CDVDMsgGeneralResync* pMsgGeneralResync = (CDVDMsgGeneralResync*)pMsg;
 
-      if (pMsgGeneralResync->m_timestamp != DVD_NOPTS_VALUE)
-        m_audioClock = pMsgGeneralResync->m_timestamp;
-
-      if (pMsgGeneralResync->m_clock)
+      if (pMsgGeneralResync->m_clock && pMsgGeneralResync->m_timestamp != DVD_NOPTS_VALUE)
       {
-        CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, 1)", m_audioClock);
-        m_av_clock->Discontinuity(m_audioClock);
-        //m_av_clock->OMXUpdateClock(m_audioClock);
+        CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, %f, 1)", m_audioClock, pMsgGeneralResync->m_timestamp);
+        m_av_clock->Discontinuity(pMsgGeneralResync->m_timestamp);
       }
       else
-        CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, 0)", m_audioClock);
+        CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, 0)", m_audioClock);
+
       m_flush = false;
+      m_audioClock = DVD_NOPTS_VALUE;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_RESET))
     {
       CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_RESET");
       if (m_pAudioCodec)
         m_pAudioCodec->Reset();
-      m_av_clock->Lock();
-      m_av_clock->OMXStop(false);
       m_omxAudio.Flush();
-      m_av_clock->OMXReset(false);
-      m_av_clock->UnLock();
       m_started = false;
+      m_audioClock = DVD_NOPTS_VALUE;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH))
     {
       CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_FLUSH");
-      m_av_clock->Lock();
-      m_av_clock->OMXStop(false);
       m_omxAudio.Flush();
-      m_av_clock->OMXReset(false);
-      m_av_clock->UnLock();
-      m_syncclock = true;
       m_stalled   = true;
       m_started   = false;
 
       if (m_pAudioCodec)
         m_pAudioCodec->Reset();
+      m_audioClock = DVD_NOPTS_VALUE;
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
@@ -579,18 +439,8 @@ void OMXPlayerAudio::Process()
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_DELAY))
     {
-      if (m_speed != DVD_PLAYSPEED_PAUSE)
-      {
-        double timeout = static_cast<CDVDMsgDouble*>(pMsg)->m_value;
-
-        CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_DELAY(%f)", timeout);
-
-        timeout *= (double)DVD_PLAYSPEED_NORMAL / abs(m_speed);
-        timeout += m_av_clock->GetAbsoluteClock();
-
-        while(!m_bStop && m_av_clock->GetAbsoluteClock() < timeout)
-          Sleep(1);
-      }
+      double timeout = static_cast<CDVDMsgDouble*>(pMsg)->m_value;
+      CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_DELAY(%f)", timeout);
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
     {
@@ -599,10 +449,6 @@ void OMXPlayerAudio::Process()
         m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
         CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::PLAYER_SETSPEED %d", m_speed);
       }
-      if (m_speed != DVD_PLAYSPEED_NORMAL)
-      {
-        m_syncclock = true;
-      }
     }
     else if (pMsg->IsType(CDVDMsg::AUDIO_SILENCE))
     {
@@ -615,6 +461,7 @@ void OMXPlayerAudio::Process()
     else if (pMsg->IsType(CDVDMsg::GENERAL_STREAMCHANGE))
     {
       COMXMsgAudioCodecChange* msg(static_cast<COMXMsgAudioCodecChange*>(pMsg));
+      CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_STREAMCHANGE");
       OpenStream(msg->m_hints, msg->m_codec);
       msg->m_codec = NULL;
     }
@@ -657,7 +504,6 @@ AEDataFormat OMXPlayerAudio::GetDataFormat(CDVDStreamInfo hints)
     hdmi_passthrough_ac3 = true;
   if (m_DllBcmHost.vc_tv_hdmi_audio_supported(EDID_AudioFormat_eDTS, 2, EDID_AudioSampleRate_e44KHz, EDID_AudioSampleSize_16bit ) == 0)
     hdmi_passthrough_dts = true;
-  //printf("Audio support AC3=%d, DTS=%d\n", hdmi_passthrough_ac3, hdmi_passthrough_dts);
 
   m_passthrough = false;
   m_hw_decode   = false;
@@ -697,10 +543,10 @@ AEDataFormat OMXPlayerAudio::GetDataFormat(CDVDStreamInfo hints)
   /* software path */
   if(!m_passthrough && !m_hw_decode)
   {
-    /* 6 channel have to be mapped to 8 for PCM */
-    if(m_nChannels > 4)
-      m_nChannels = 8;
-    dataFormat = AE_FMT_S16NE;
+    if (m_pAudioCodec && m_pAudioCodec->GetBitsPerSample() == 16)
+      dataFormat = AE_FMT_S16NE;
+    else
+      dataFormat = AE_FMT_FLOAT;
   }
 
   return dataFormat;
@@ -712,33 +558,25 @@ bool OMXPlayerAudio::OpenDecoder()
   m_passthrough = false;
   m_hw_decode   = false;
 
-  bool bSendParent = false;
-
   if(m_DecoderOpen)
   {
-    WaitCompletion();
     m_omxAudio.Deinitialize();
     m_DecoderOpen = false;
-    bSendParent = true;
   }
 
   /* setup audi format for audio render */
   m_format.m_sampleRate    = m_hints.samplerate;
-  m_format.m_channelLayout = m_pAudioCodec->GetChannelMap(); 
   /* GetDataFormat is setting up evrything */
   m_format.m_dataFormat = GetDataFormat(m_hints);
 
-  std::string device = "";
-  
-  if(g_guiSettings.GetInt("audiooutput.mode") == AUDIO_HDMI)
-    device = "hdmi";
-  else
-    device = "local";
-
-  m_av_clock->Lock();
-  m_av_clock->OMXStop(false);
-
-  bool bAudioRenderOpen = m_omxAudio.Initialize(m_format, device, m_av_clock, m_hints, m_passthrough, m_hw_decode);
+  uint64_t channelMap = 0;
+  if (m_pAudioCodec && !m_passthrough)
+    channelMap = m_pAudioCodec->GetChannelMap();
+  else if (m_passthrough)
+    // we just want to get the channel count right to stop OMXAudio.cpp rejecting stream
+    // the actual layout is not used
+    channelMap = (1<<m_nChannels)-1;
+  bool bAudioRenderOpen = m_omxAudio.Initialize(m_format, m_av_clock, m_hints, channelMap, m_passthrough, m_hw_decode);
 
   m_codec_name = "";
   m_bad_state  = !bAudioRenderOpen;
@@ -754,31 +592,14 @@ bool OMXPlayerAudio::OpenDecoder()
       m_codec_name.c_str(), m_nChannels, m_hints.samplerate, m_hints.bitspersample);
   }
 
-  m_av_clock->OMXStateExecute(false);
-  m_av_clock->HasAudio(bAudioRenderOpen);
-  m_av_clock->OMXReset(false);
-  m_av_clock->UnLock();
-
   m_started = false;
 
-  // TODO : Send FLUSH to parent, only if we had a valid open codec. 
-  // this is just a workaround to get the omx video decoder happy again
-  // This situation happens, for example where we have in the stream an audio codec change
-  if(bSendParent)
-    m_messageParent.Put(new CDVDMsg(CDVDMsg::GENERAL_FLUSH));
-
   return bAudioRenderOpen;
 }
 
 void OMXPlayerAudio::CloseDecoder()
 {
-  m_av_clock->Lock();
-  m_av_clock->OMXStop(false);
   m_omxAudio.Deinitialize();
-  m_av_clock->HasAudio(false);
-  m_av_clock->OMXReset(false);
-  m_av_clock->UnLock();
-
   m_DecoderOpen = false;
 }
 
@@ -792,6 +613,11 @@ double OMXPlayerAudio::GetCacheTime()
   return m_omxAudio.GetCacheTime();
 }
 
+double OMXPlayerAudio::GetCacheTotal()
+{
+  return m_omxAudio.GetCacheTotal();
+}
+
 void OMXPlayerAudio::SubmitEOS()
 {
   if(!m_bad_state)
@@ -824,21 +650,6 @@ void OMXPlayerAudio::WaitCompletion()
   }
 }
 
-void OMXPlayerAudio::RegisterAudioCallback(IAudioCallback *pCallback)
-{
-  m_omxAudio.RegisterAudioCallback(pCallback);
-}
-
-void OMXPlayerAudio::UnRegisterAudioCallback()
-{
-  m_omxAudio.UnRegisterAudioCallback();
-}
-
-void OMXPlayerAudio::SetCurrentVolume(float fVolume)
-{
-  m_omxAudio.SetCurrentVolume(fVolume);
-}
-
 void OMXPlayerAudio::SetSpeed(int speed)
 {
   if(m_messageQueue.IsInited())
diff --git a/xbmc/cores/omxplayer/OMXPlayerAudio.h b/xbmc/cores/omxplayer/OMXPlayerAudio.h
index b3bd1e5..85907ce 100644
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.h
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.h
@@ -55,35 +55,18 @@ class OMXPlayerAudio : public CThread
   bool                      m_use_hw_decode;
   bool                      m_hw_decode;
   AEAudioFormat             m_format;
-  CAEChannelInfo            m_channelLayout;
   COMXAudioCodecOMX         *m_pAudioCodec;
   int                       m_speed;
   bool                      m_silence;
   double                    m_audioClock;
-  double m_error;    //last average error
-
-  int64_t m_errortime; //timestamp of last time we measured
-  int64_t m_freq;
-
-  void   HandleSyncError(double duration);
-  double m_errorbuff; //place to store average errors
-  int    m_errorcount;//number of errors stored
-  bool   m_syncclock;
-
-  double m_integral; //integral correction for resampler
-  int    m_skipdupcount; //counter for skip/duplicate synctype
-  bool   m_prevskipped;
 
   bool                      m_stalled;
   bool                      m_started;
 
   BitstreamStats            m_audioStats;
 
-  struct timespec           m_starttime, m_endtime;
   bool                      m_buffer_empty;
   bool                      m_flush;
-  //SYNC_DISCON, SYNC_SKIPDUP, SYNC_RESAMPLE
-  int                       m_synctype;
   int                       m_nChannels;
   bool                      m_DecoderOpen;
 
@@ -118,12 +101,17 @@ class OMXPlayerAudio : public CThread
   void CloseDecoder();
   double GetDelay();
   double GetCacheTime();
-  double GetCurrentPTS() { return m_audioClock; };
+  double GetCacheTotal();
+  double GetCurrentPts() { return m_audioClock; };
   void WaitCompletion();
   void SubmitEOS();
-  void  RegisterAudioCallback(IAudioCallback* pCallback);
-  void  UnRegisterAudioCallback();
-  void SetCurrentVolume(float fVolume);
+
+  void  RegisterAudioCallback(IAudioCallback* pCallback) { m_omxAudio.RegisterAudioCallback(pCallback); }
+  void  UnRegisterAudioCallback()                        { m_omxAudio.UnRegisterAudioCallback(); }
+  void SetVolume(float fVolume)                          { m_omxAudio.SetVolume(fVolume); }
+  void SetMute(bool bOnOff)                              { m_omxAudio.SetMute(bOnOff); }
+  void SetDynamicRangeCompression(long drc)              { m_omxAudio.SetDynamicRangeCompression(drc); }
+  float GetDynamicRangeAmplification()                   { return m_omxAudio.GetDynamicRangeAmplification(); }
   void SetSpeed(int iSpeed);
   int  GetAudioBitrate();
   std::string GetPlayerInfo();
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index b181cbd..4d51fea 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -44,8 +44,10 @@
 #include "settings/Settings.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 #include "cores/VideoRenderers/RenderFlags.h"
+#include "guilib/GraphicContext.h"
 
 #include "OMXPlayer.h"
+#include "linux/RBP.h"
 
 class COMXMsgVideoCodecChange : public CDVDMsg
 {
@@ -72,7 +74,6 @@ OMXPlayerVideo::OMXPlayerVideo(OMXClock *av_clock,
 {
   m_av_clock              = av_clock;
   m_pOverlayContainer     = pOverlayContainer;
-  m_pTempOverlayPicture   = NULL;
   m_open                  = false;
   m_stream_id             = -1;
   m_fFrameRate            = 25.0f;
@@ -81,20 +82,23 @@ OMXPlayerVideo::OMXPlayerVideo(OMXClock *av_clock,
   m_stalled               = false;
   m_codecname             = "";
   m_iSubtitleDelay        = 0;
-  m_FlipTimeStamp         = 0.0;
   m_bRenderSubs           = false;
   m_flags                 = 0;
   m_bAllowFullscreen      = false;
   m_iCurrentPts           = DVD_NOPTS_VALUE;
   m_iVideoDelay           = 0;
-  m_droptime              = 0.0;
-  m_dropbase              = 0.0;
-  m_autosync              = 1;
   m_fForcedAspectRatio    = 0.0f;
-  m_messageQueue.SetMaxDataSize(10 * 1024 * 1024);
+  bool small_mem = g_RBP.GetArmMem() < 256;
+  m_messageQueue.SetMaxDataSize((small_mem ? 10:40) * 1024 * 1024);
   m_messageQueue.SetMaxTimeSize(8.0);
 
   m_dst_rect.SetRect(0, 0, 0, 0);
+  m_started = false;
+  m_iCurrentPts = DVD_NOPTS_VALUE;
+  m_nextOverlay = DVD_NOPTS_VALUE;
+  m_flush = false;
+  m_view_mode = 0;
+  m_history_valid_pts = 0;
 }
 
 OMXPlayerVideo::~OMXPlayerVideo()
@@ -104,19 +108,12 @@ OMXPlayerVideo::~OMXPlayerVideo()
 
 bool OMXPlayerVideo::OpenStream(CDVDStreamInfo &hints)
 {
-  /*
-  if(IsRunning())
-    CloseStream(false);
-  */
-
   m_hints       = hints;
-  m_Deinterlace = ( g_settings.m_currentVideoSettings.m_DeinterlaceMode == VS_DEINTERLACEMODE_OFF ) ? false : true;
   m_hdmi_clock_sync = (g_guiSettings.GetInt("videoplayer.adjustrefreshrate") != ADJUST_REFRESHRATE_OFF);
   m_started     = false;
   m_flush       = false;
   m_stalled     = m_messageQueue.GetPacketCount(CDVDMsg::DEMUXER_PACKET) == 0;
-  m_autosync    = 1;
-  m_iSleepEndTime = DVD_NOPTS_VALUE;
+  m_nextOverlay = DVD_NOPTS_VALUE;
   // force SetVideoRect to be called initially
   m_dst_rect.SetRect(0, 0, 0, 0);
 
@@ -139,16 +136,9 @@ bool OMXPlayerVideo::OpenStream(CDVDStreamInfo &hints)
     Create();
   }
 
-  /*
-  if(!OpenStream(hints, NULL))
-    return false;
-
-  CLog::Log(LOGNOTICE, "Creating video thread");
-  m_messageQueue.Init();
-  Create();
-  */
-
   m_open        = true;
+  m_iCurrentPts = DVD_NOPTS_VALUE;
+  m_nextOverlay = DVD_NOPTS_VALUE;
 
   return true;
 }
@@ -175,18 +165,7 @@ bool OMXPlayerVideo::CloseStream(bool bWaitForBuffers)
   m_speed         = DVD_PLAYSPEED_NORMAL;
   m_started       = false;
 
-  if (m_pTempOverlayPicture)
-  {
-    CDVDCodecUtils::FreePicture(m_pTempOverlayPicture);
-    m_pTempOverlayPicture = NULL;
-  }
-
-  m_av_clock->Lock();
-  m_av_clock->OMXStop(false);
   m_omxVideo.Close();
-  m_av_clock->HasVideo(false);
-  m_av_clock->OMXReset(false);
-  m_av_clock->UnLock();
 
   if(m_DllBcmHost.IsLoaded())
     m_DllBcmHost.Unload();
@@ -196,8 +175,6 @@ bool OMXPlayerVideo::CloseStream(bool bWaitForBuffers)
 
 void OMXPlayerVideo::OnStartup()
 {
-  m_iCurrentPts = DVD_NOPTS_VALUE;
-  m_FlipTimeStamp = m_av_clock->GetAbsoluteClock();
 }
 
 void OMXPlayerVideo::OnExit()
@@ -205,6 +182,40 @@ void OMXPlayerVideo::OnExit()
   CLog::Log(LOGNOTICE, "thread end: video_thread");
 }
 
+double OMXPlayerVideo::NextOverlay(double pts)
+{
+  double delta_start, delta_stop, min_delta = DVD_NOPTS_VALUE;
+
+  CSingleLock lock(*m_pOverlayContainer);
+  VecOverlays* pVecOverlays = m_pOverlayContainer->GetOverlays();
+  VecOverlaysIter it = pVecOverlays->begin();
+
+  //Find the minimum time before a subtitle is added or removed
+  while (it != pVecOverlays->end())
+  {
+    CDVDOverlay* pOverlay = *it++;
+    if(!pOverlay->bForced && !m_bRenderSubs)
+      continue;
+
+    double pts2 = pOverlay->bForced ? pts : pts - m_iSubtitleDelay;
+
+    delta_start = pOverlay->iPTSStartTime - pts2;
+    delta_stop = pOverlay->iPTSStopTime - pts2;
+
+    // when currently on screen, we periodically update to allow (limited rate) ASS animation
+    if (delta_start <= 0.0 && delta_stop > 0.0 && (min_delta == DVD_NOPTS_VALUE || DVD_MSEC_TO_TIME(100) < min_delta))
+      min_delta = DVD_MSEC_TO_TIME(100);
+
+    else if (delta_start > 0.0 && (min_delta == DVD_NOPTS_VALUE || delta_start < min_delta))
+      min_delta = delta_start;
+
+    else if (delta_stop > 0.0 && (min_delta == DVD_NOPTS_VALUE || delta_stop < min_delta))
+      min_delta = delta_stop;
+  }
+  return min_delta == DVD_NOPTS_VALUE ? pts+DVD_MSEC_TO_TIME(500) : pts+min_delta;
+}
+
+
 void OMXPlayerVideo::ProcessOverlays(int iGroupId, double pts)
 {
   // remove any overlays that are out of time
@@ -251,114 +262,44 @@ void OMXPlayerVideo::ProcessOverlays(int iGroupId, double pts)
 void OMXPlayerVideo::Output(int iGroupId, double pts, bool bDropPacket)
 {
   if (!g_renderManager.IsStarted()) {
-    CLog::Log(LOGERROR, "%s - renderer not started", __FUNCTION__);
+    CLog::Log(LOGINFO, "%s - renderer not started", __FUNCTION__);
     return;
   }
 
-  // calculate the time we need to delay this picture before displaying
-  double iSleepTime, iClockSleep, iFrameSleep, iPlayingClock, iCurrentClock, iFrameDuration;
-
-  iPlayingClock = m_av_clock->GetClock(iCurrentClock, false); // snapshot current clock
-  iClockSleep = pts - iPlayingClock; //sleep calculated by pts to clock comparison
-  iFrameSleep = m_FlipTimeStamp - iCurrentClock; // sleep calculated by duration of frame
-  iFrameDuration = (double)DVD_TIME_BASE / m_fFrameRate; //pPacket->duration;
-
-  // correct sleep times based on speed
-  if(m_speed)
-  {
-    iClockSleep = iClockSleep * DVD_PLAYSPEED_NORMAL / m_speed;
-    iFrameSleep = iFrameSleep * DVD_PLAYSPEED_NORMAL / abs(m_speed);
-    iFrameDuration = iFrameDuration * DVD_PLAYSPEED_NORMAL / abs(m_speed);
-  }
-  else
-  {
-    iClockSleep = 0;
-    iFrameSleep = 0;
-  }
-
-  // dropping to a very low framerate is not correct (it should not happen at all)
-  iClockSleep = min(iClockSleep, DVD_MSEC_TO_TIME(500));
-  iFrameSleep = min(iFrameSleep, DVD_MSEC_TO_TIME(500));
-
-  if( m_stalled )
-    iSleepTime = iFrameSleep;
-  else
-    iSleepTime = iFrameSleep + (iClockSleep - iFrameSleep) / m_autosync;
-
-  // present the current pts of this frame to user, and include the actual
-  // presentation delay, to allow him to adjust for it
-  if( m_stalled )
-    m_iCurrentPts = DVD_NOPTS_VALUE;
-  else
-    m_iCurrentPts = pts - max(0.0, iSleepTime);
-
-  // timestamp when we think next picture should be displayed based on current duration
-  m_FlipTimeStamp  = iCurrentClock;
-  m_FlipTimeStamp += max(0.0, iSleepTime);
-  m_FlipTimeStamp += iFrameDuration;
+  if (CThread::m_bStop)
+    return;
 
-  if( m_speed < 0 )
-  {
-    if( iClockSleep < -DVD_MSEC_TO_TIME(200))
-      return;
-  }
+  // we aim to submit subtitles 100ms early
+  const double preroll = DVD_MSEC_TO_TIME(100);
+  double media_pts = m_av_clock->OMXMediaTime();
 
-  if(bDropPacket)
+  if (m_nextOverlay != DVD_NOPTS_VALUE && media_pts + preroll <= m_nextOverlay)
     return;
 
-#if 0
-  if( m_speed != DVD_PLAYSPEED_NORMAL)
-  {
-    // calculate frame dropping pattern to render at this speed
-    // we do that by deciding if this or next frame is closest
-    // to the flip timestamp
-    double current   = fabs(m_dropbase -  m_droptime);
-    double next      = fabs(m_dropbase - (m_droptime + iFrameDuration));
-    double frametime = (double)DVD_TIME_BASE / m_fFrameRate;
-
-    m_droptime += iFrameDuration;
-#ifndef PROFILE
-    if( next < current /*&& !(pPicture->iFlags & DVP_FLAG_NOSKIP) */)
-      return /*result | EOS_DROPPED*/;
-#endif
+  double subtitle_pts = m_nextOverlay;
+  double time = subtitle_pts != DVD_NOPTS_VALUE ? subtitle_pts - media_pts : 0.0;
 
-    while(!m_bStop && m_dropbase < m_droptime)             m_dropbase += frametime;
-    while(!m_bStop && m_dropbase - frametime > m_droptime) m_dropbase -= frametime;
-  }
-  else
-  {
-    m_droptime = 0.0f;
-    m_dropbase = 0.0f;
-  }
-#else
-  m_droptime = 0.0f;
-  m_dropbase = 0.0f;
-#endif
+  if (m_nextOverlay != DVD_NOPTS_VALUE)
+    media_pts = m_nextOverlay;
 
-  // DVDPlayer sleeps until m_iSleepEndTime here before calling FlipPage.
-  // Video playback in asynchronous in OMXPlayer, so we don't want to do that here, as it prevents the video fifo from being kept full.
-  // So, we keep track of when FlipPage would have been called on DVDPlayer and return early if it is not time.
-  // m_iSleepEndTime == DVD_NOPTS_VALUE means we are not waiting to call FlipPage, otherwise it is the time we want to call FlipPage
-  if (m_iSleepEndTime == DVD_NOPTS_VALUE) {
-    m_iSleepEndTime = iCurrentClock + iSleepTime;
-  }
+  m_nextOverlay = NextOverlay(media_pts);
 
-  if (!CThread::m_bStop && m_av_clock->GetAbsoluteClock(false) < m_iSleepEndTime + DVD_MSEC_TO_TIME(500))
-    return;
+  ProcessOverlays(iGroupId, media_pts);
 
-  double pts_media = m_av_clock->OMXMediaTime(false);
-  ProcessOverlays(iGroupId, pts_media);
-
-  g_renderManager.FlipPage(CThread::m_bStop, m_iSleepEndTime / DVD_TIME_BASE, -1, FS_NONE);
-
-  m_iSleepEndTime = DVD_NOPTS_VALUE;
+  time += m_av_clock->GetAbsoluteClock();
+  g_renderManager.FlipPage(CThread::m_bStop, time/DVD_TIME_BASE);
+}
 
-  //m_av_clock->WaitAbsoluteClock((iCurrentClock + iSleepTime));
+static unsigned count_bits(int32_t value)
+{
+  unsigned bits = 0;
+  for(;value;++bits)
+    value &= value - 1;
+  return bits;
 }
 
 void OMXPlayerVideo::Process()
 {
-  double pts = 0;
   double frametime = (double)DVD_TIME_BASE / m_fFrameRate;
   bool bRequestDrop = false;
 
@@ -399,39 +340,25 @@ void OMXPlayerVideo::Process()
     {
       CDVDMsgGeneralResync* pMsgGeneralResync = (CDVDMsgGeneralResync*)pMsg;
 
-      if(pMsgGeneralResync->m_timestamp != DVD_NOPTS_VALUE)
-        pts = pMsgGeneralResync->m_timestamp;
-
-      double delay = m_FlipTimeStamp - m_av_clock->GetAbsoluteClock();
-      if( delay > frametime ) delay = frametime;
-      else if( delay < 0 )    delay = 0;
+      double delay = 0;
 
-      if(pMsgGeneralResync->m_clock)
+      if(pMsgGeneralResync->m_clock && pMsgGeneralResync->m_timestamp != DVD_NOPTS_VALUE)
       {
-        CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_RESYNC(%f, 1)", pts);
-        m_av_clock->Discontinuity(pts - delay);
-        //m_av_clock->OMXUpdateClock(pts - delay);
+        CLog::Log(LOGDEBUG, "CDVDPlayerVideo - CDVDMsg::GENERAL_RESYNC(%f, %f, 1)", m_iCurrentPts, pMsgGeneralResync->m_timestamp);
+        m_av_clock->Discontinuity(pMsgGeneralResync->m_timestamp - delay);
       }
       else
-        CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_RESYNC(%f, 0)", pts);
+        CLog::Log(LOGDEBUG, "CDVDPlayerVideo - CDVDMsg::GENERAL_RESYNC(%f, 0)", m_iCurrentPts);
 
+      m_nextOverlay = DVD_NOPTS_VALUE;
+      m_iCurrentPts = DVD_NOPTS_VALUE;
       pMsgGeneralResync->Release();
       continue;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_DELAY))
     {
-      if (m_speed != DVD_PLAYSPEED_PAUSE)
-      {
-        double timeout = static_cast<CDVDMsgDouble*>(pMsg)->m_value;
-
-        CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_DELAY(%f)", timeout);
-
-        timeout *= (double)DVD_PLAYSPEED_NORMAL / abs(m_speed);
-        timeout += m_av_clock->GetAbsoluteClock();
-
-        while(!m_bStop && m_av_clock->GetAbsoluteClock() < timeout)
-          Sleep(1);
-      }
+      double timeout = static_cast<CDVDMsgDouble*>(pMsg)->m_value;
+      CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_DELAY(%f)", timeout);
     }
     else if (pMsg->IsType(CDVDMsg::VIDEO_SET_ASPECT))
     {
@@ -441,25 +368,19 @@ void OMXPlayerVideo::Process()
     else if (pMsg->IsType(CDVDMsg::GENERAL_RESET))
     {
       CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_RESET");
-      m_av_clock->Lock();
-      m_av_clock->OMXStop(false);
       m_omxVideo.Reset();
-      m_av_clock->OMXReset(false);
-      m_av_clock->UnLock();
       m_started = false;
-      m_iSleepEndTime = DVD_NOPTS_VALUE;
+      m_nextOverlay = DVD_NOPTS_VALUE;
+      m_iCurrentPts = DVD_NOPTS_VALUE;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH)) // private message sent by (COMXPlayerVideo::Flush())
     {
       CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_FLUSH");
       m_stalled = true;
       m_started = false;
-      m_iSleepEndTime = DVD_NOPTS_VALUE;
-      m_av_clock->Lock();
-      m_av_clock->OMXStop(false);
+      m_nextOverlay = DVD_NOPTS_VALUE;
+      m_iCurrentPts = DVD_NOPTS_VALUE;
       m_omxVideo.Reset();
-      m_av_clock->OMXReset(false);
-      m_av_clock->UnLock();
       m_flush = false;
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
@@ -494,7 +415,7 @@ void OMXPlayerVideo::Process()
 
       #ifdef _DEBUG
       CLog::Log(LOGINFO, "Video: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d\n", pPacket->dts, pPacket->pts, 
-          (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, m_av_clock->OMXLateCount(1));
+          (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, 0);
       #endif
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
@@ -526,32 +447,21 @@ void OMXPlayerVideo::Process()
           m_stalled = false;
         }
 
-        double output_pts = 0;
-        // validate picture timing,
-        // if both dts/pts invalid, use pts calulated from picture.iDuration
-        // if pts invalid use dts, else use picture.pts as passed
-        if (pPacket->dts == DVD_NOPTS_VALUE && pPacket->pts == DVD_NOPTS_VALUE)
-          output_pts = pts;
-        else if (pPacket->pts == DVD_NOPTS_VALUE)
-          output_pts = pts;
-        else
-          output_pts = pPacket->pts;
-
-        if(pPacket->pts != DVD_NOPTS_VALUE)
-          pPacket->pts += m_iVideoDelay;
-
-        if(pPacket->dts != DVD_NOPTS_VALUE)
-          pPacket->dts += m_iVideoDelay;
-
-        if(pPacket->duration == 0)
-          pPacket->duration = frametime;
-
-        if(output_pts != DVD_NOPTS_VALUE)
-          pts = output_pts;
+        // some packed bitstream AVI files set almost all pts values to DVD_NOPTS_VALUE, but have a scattering of real pts values.
+        // the valid pts values match the dts values.
+        // if a stream has had more than 4 valid pts values in the last 16, the use UNKNOWN, otherwise use dts
+        m_history_valid_pts = (m_history_valid_pts << 1) | (pPacket->pts != DVD_NOPTS_VALUE);
+        double pts = pPacket->pts;
+        if(pPacket->pts == DVD_NOPTS_VALUE && count_bits(m_history_valid_pts & 0xffff) < 4)
+          pts = pPacket->dts;
 
-        m_omxVideo.Decode(pPacket->pData, pPacket->iSize, pPacket->dts, pPacket->pts);
+        if (pts != DVD_NOPTS_VALUE)
+          pts += m_iVideoDelay;
 
-        Output(pPacket->iGroupId, output_pts, bRequestDrop);
+        m_omxVideo.Decode(pPacket->pData, pPacket->iSize, pts);
+        Output(pPacket->iGroupId, pts, bRequestDrop);
+        if(pts != DVD_NOPTS_VALUE)
+          m_iCurrentPts = pts;
 
         if(m_started == false)
         {
@@ -560,10 +470,6 @@ void OMXPlayerVideo::Process()
           m_messageParent.Put(new CDVDMsgInt(CDVDMsg::PLAYER_STARTED, DVDPLAYER_VIDEO));
         }
 
-        // guess next frame pts. iDuration is always valid
-        if (m_speed != 0)
-          pts += pPacket->duration * m_speed / abs(m_speed);
-
         break;
       }
 
@@ -598,14 +504,13 @@ bool OMXPlayerVideo::OpenDecoder()
     CLog::Log(LOGINFO, "OMXPlayerVideo::OpenDecoder : Invalid framerate %d, using forced 25fps and just trust timestamps\n", (int)m_fFrameRate);
     m_fFrameRate = 25;
   }
-  // use aspect in stream always
-  m_fForcedAspectRatio = m_hints.aspect;
-
-
-  m_av_clock->Lock();
-  m_av_clock->OMXStop(false);
+  // use aspect in stream if available
+  if (m_hints.forced_aspect)
+    m_fForcedAspectRatio = m_hints.aspect;
+  else
+    m_fForcedAspectRatio = 0.0;
 
-  bool bVideoDecoderOpen = m_omxVideo.Open(m_hints, m_av_clock, m_Deinterlace, m_hdmi_clock_sync);
+  bool bVideoDecoderOpen = m_omxVideo.Open(m_hints, m_av_clock, g_settings.m_currentVideoSettings.m_DeinterlaceMode, m_hdmi_clock_sync);
   m_omxVideo.RegisterResolutionUpdateCallBack((void *)this, ResolutionUpdateCallBack);
 
   if(!bVideoDecoderOpen)
@@ -632,10 +537,8 @@ bool OMXPlayerVideo::OpenDecoder()
       m_av_clock->SetRefreshRate(m_fFrameRate);
   }
 
-  m_av_clock->OMXStateExecute(false);
-  m_av_clock->HasVideo(bVideoDecoderOpen);
-  m_av_clock->OMXReset(false);
-  m_av_clock->UnLock();
+  // start from assuming all recent frames had valid pts
+  m_history_valid_pts = ~0;
 
   return bVideoDecoderOpen;
 }
@@ -750,7 +653,7 @@ void OMXPlayerVideo::RenderUpdateCallBack(const void *ctx, const CRect &SrcRect,
   player->SetVideoRect(SrcRect, DestRect);
 }
 
-void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height)
+void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height, float display_aspect)
 {
   RESOLUTION res  = g_graphicsContext.GetVideoResolution();
   uint32_t video_width   = g_settings.m_ResInfo[res].iScreenWidth;
@@ -788,6 +691,8 @@ void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height)
   /* use forced aspect if any */
   if( m_fForcedAspectRatio != 0.0f )
     iDisplayWidth = (int) (iDisplayHeight * m_fForcedAspectRatio);
+  else if( display_aspect != 0.0f )
+    iDisplayWidth = (int) (iDisplayHeight * display_aspect);
 
   CLog::Log(LOGDEBUG,"%s - change configuration. video:%dx%d. framerate: %4.2f. %dx%d format: BYPASS",
       __FUNCTION__, video_width, video_height, m_fFrameRate, iDisplayWidth, iDisplayHeight);
@@ -803,9 +708,9 @@ void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height)
   g_renderManager.RegisterRenderUpdateCallBack((const void*)this, RenderUpdateCallBack);
 }
 
-void OMXPlayerVideo::ResolutionUpdateCallBack(void *ctx, uint32_t width, uint32_t height)
+void OMXPlayerVideo::ResolutionUpdateCallBack(void *ctx, uint32_t width, uint32_t height, float display_aspect)
 {
   OMXPlayerVideo *player = static_cast<OMXPlayerVideo*>(ctx);
-  player->ResolutionUpdateCallBack(width, height);
+  player->ResolutionUpdateCallBack(width, height, display_aspect);
 }
 
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.h b/xbmc/cores/omxplayer/OMXPlayerVideo.h
index 677d650..46a193e 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.h
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.h
@@ -50,23 +50,17 @@ class OMXPlayerVideo : public CThread
   bool                      m_open;
   CDVDStreamInfo            m_hints;
   double                    m_iCurrentPts;
-  double                    m_iSleepEndTime;
+  double                    m_nextOverlay;
   OMXClock                  *m_av_clock;
   COMXVideo                 m_omxVideo;
   float                     m_fFrameRate;
-  bool                      m_Deinterlace;
   bool                      m_hdmi_clock_sync;
   double                    m_iVideoDelay;
   int                       m_speed;
-  double                    m_FlipTimeStamp; // time stamp of last flippage. used to play at a forced framerate
-  int                       m_audio_count;
   bool                      m_stalled;
   bool                      m_started;
   bool                      m_flush;
   std::string               m_codecname;
-  double                    m_droptime;
-  double                    m_dropbase;
-  unsigned int              m_autosync;
   double                    m_iSubtitleDelay;
   bool                      m_bRenderSubs;
   bool                      m_bAllowFullscreen;
@@ -77,6 +71,7 @@ class OMXPlayerVideo : public CThread
   CRect                     m_dst_rect;
   int                       m_view_mode;
 
+  uint32_t                  m_history_valid_pts;
   DllBcmHost                m_DllBcmHost;
 
   CDVDOverlayContainer  *m_pOverlayContainer;
@@ -84,9 +79,8 @@ class OMXPlayerVideo : public CThread
 
   BitstreamStats m_videoStats;
 
-  DVDVideoPicture* m_pTempOverlayPicture;
-
   void ProcessOverlays(int iGroupId, double pts);
+  double NextOverlay(double pts);
 
   virtual void OnStartup();
   virtual void OnExit();
@@ -111,7 +105,7 @@ class OMXPlayerVideo : public CThread
   bool OpenDecoder();
   int  GetDecoderBufferSize();
   int  GetDecoderFreeSpace();
-  double GetCurrentPTS() { return m_iCurrentPts; };
+  double GetCurrentPts() { return m_iCurrentPts; };
   double GetFPS() { return m_fFrameRate; };
   void  SubmitEOS();
   bool SubmittedEOS();
@@ -131,7 +125,7 @@ class OMXPlayerVideo : public CThread
   int GetFreeSpace();
   void  SetVideoRect(const CRect &SrcRect, const CRect &DestRect);
   static void RenderUpdateCallBack(const void *ctx, const CRect &SrcRect, const CRect &DestRect);
-  void ResolutionUpdateCallBack(uint32_t width, uint32_t height);
-  static void ResolutionUpdateCallBack(void *ctx, uint32_t width, uint32_t height);
+  void ResolutionUpdateCallBack(uint32_t width, uint32_t height, float pixel_aspect);
+  static void ResolutionUpdateCallBack(void *ctx, uint32_t width, uint32_t height, float pixel_aspect);
 };
 #endif
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 489dc8a..b0e6898 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -34,6 +34,7 @@
 #include "settings/Settings.h"
 #include "utils/BitstreamConverter.h"
 
+#include "linux/RBP.h"
 
 #include <sys/time.h>
 #include <inttypes.h>
@@ -43,20 +44,6 @@
 #endif
 #define CLASSNAME "COMXVideo"
 
-#if 0
-// TODO: These are Nvidia Tegra2 dependent, need to dynamiclly find the
-// right codec matched to video format.
-#define OMX_H264BASE_DECODER    "OMX.Nvidia.h264.decode"
-// OMX.Nvidia.h264ext.decode segfaults, not sure why.
-//#define OMX_H264MAIN_DECODER  "OMX.Nvidia.h264ext.decode"
-#define OMX_H264MAIN_DECODER    "OMX.Nvidia.h264.decode"
-#define OMX_H264HIGH_DECODER    "OMX.Nvidia.h264ext.decode"
-#define OMX_MPEG4_DECODER       "OMX.Nvidia.mp4.decode"
-#define OMX_MPEG4EXT_DECODER    "OMX.Nvidia.mp4ext.decode"
-#define OMX_MPEG2V_DECODER      "OMX.Nvidia.mpeg2v.decode"
-#define OMX_VC1_DECODER         "OMX.Nvidia.vc1.decode"
-#endif
-
 #define OMX_VIDEO_DECODER       "OMX.broadcom.video_decode"
 #define OMX_H264BASE_DECODER    OMX_VIDEO_DECODER
 #define OMX_H264MAIN_DECODER    OMX_VIDEO_DECODER
@@ -79,14 +66,16 @@
 COMXVideo::COMXVideo()
 {
   m_is_open           = false;
-  m_Pause             = false;
   m_extradata         = NULL;
   m_extrasize         = 0;
-  m_video_convert     = false;
-  m_video_codec_name  = "";
   m_deinterlace       = false;
+  m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
   m_hdmi_clock_sync   = false;
   m_submitted_eos     = false;
+  m_failed_eos        = false;
+  m_settings_changed  = false;
+  m_setStartTime      = false;
+  m_transform         = OMX_DISPLAY_ROT0;
 }
 
 COMXVideo::~COMXVideo()
@@ -96,6 +85,7 @@ COMXVideo::~COMXVideo()
 
 bool COMXVideo::SendDecoderConfig()
 {
+  CSingleLock lock (m_critSection);
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
 
   /* send decoder config */
@@ -146,13 +136,210 @@ bool COMXVideo::NaluFormatStartCodes(enum CodecID codec, uint8_t *in_extradata,
   return false;    
 }
 
-bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, bool hdmi_clock_sync)
+bool COMXVideo::PortSettingsChanged()
 {
+  CSingleLock lock (m_critSection);
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  if (m_settings_changed)
+  {
+    m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
+  }
+
+  OMX_PARAM_PORTDEFINITIONTYPE port_image;
+  OMX_INIT_STRUCTURE(port_image);
+  port_image.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_image);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+  }
+
+  OMX_CONFIG_POINTTYPE pixel_aspect;
+  OMX_INIT_STRUCTURE(pixel_aspect);
+  pixel_aspect.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio, &pixel_aspect);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+  }
+
+  // let OMXPlayerVideo know about resolution so it can inform RenderManager
+  if (m_res_callback)
+  {
+    float display_aspect = 0.0f;
+    if (pixel_aspect.nX && pixel_aspect.nY)
+      display_aspect = (float)pixel_aspect.nX * port_image.format.video.nFrameWidth /
+        ((float)pixel_aspect.nY * port_image.format.video.nFrameHeight);
+    m_res_callback(m_res_ctx, port_image.format.video.nFrameWidth, port_image.format.video.nFrameHeight, display_aspect);
+  }
+
+  if (m_settings_changed)
+  {
+    m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
+    return true;
+  }
+
+  OMX_CONFIG_INTERLACETYPE interlace;
+  OMX_INIT_STRUCTURE(interlace);
+  interlace.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetConfig(OMX_IndexConfigCommonInterlace, &interlace);
+
+  if(m_deinterlace_request == VS_DEINTERLACEMODE_FORCE)
+    m_deinterlace = true;
+  else if(m_deinterlace_request == VS_DEINTERLACEMODE_OFF)
+    m_deinterlace = false;
+  else
+    m_deinterlace = interlace.eMode != OMX_InterlaceProgressive;
+
+  if(!m_omx_render.Initialize("OMX.broadcom.video_render", OMX_IndexParamVideoInit))
+    return false;
+
+  m_omx_render.ResetEos();
+
+  CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d", CLASSNAME, __func__,
+      port_image.format.video.nFrameWidth, port_image.format.video.nFrameHeight,
+      port_image.format.video.xFramerate / (float)(1<<16), interlace.eMode, m_deinterlace);
+
+  if(!m_omx_sched.Initialize("OMX.broadcom.video_scheduler", OMX_IndexParamVideoInit))
+    return false;
+
+  if(m_deinterlace)
+  {
+    if(!m_omx_image_fx.Initialize("OMX.broadcom.image_fx", OMX_IndexParamImageInit))
+      return false;
+  }
+
+  OMX_CONFIG_DISPLAYREGIONTYPE configDisplay;
+  OMX_INIT_STRUCTURE(configDisplay);
+  configDisplay.nPortIndex = m_omx_render.GetInputPort();
+
+  configDisplay.set = OMX_DISPLAY_SET_TRANSFORM;
+  configDisplay.transform = m_transform;
+  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGWARNING, "%s::%s - could not set transform : %d", CLASSNAME, __func__, m_transform);
+    return false;
+  }
+
+  if(m_hdmi_clock_sync)
+  {
+    OMX_CONFIG_LATENCYTARGETTYPE latencyTarget;
+    OMX_INIT_STRUCTURE(latencyTarget);
+    latencyTarget.nPortIndex = m_omx_render.GetInputPort();
+    latencyTarget.bEnabled = OMX_TRUE;
+    latencyTarget.nFilter = 2;
+    latencyTarget.nTarget = 4000;
+    latencyTarget.nShift = 3;
+    latencyTarget.nSpeedFactor = -135;
+    latencyTarget.nInterFactor = 500;
+    latencyTarget.nAdjCap = 20;
+
+    omx_err = m_omx_render.SetConfig(OMX_IndexConfigLatencyTarget, &latencyTarget);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - OMX_IndexConfigLatencyTarget omx_err(0%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if(m_deinterlace)
+  {
+    OMX_CONFIG_IMAGEFILTERPARAMSTYPE image_filter;
+    OMX_INIT_STRUCTURE(image_filter);
+
+    image_filter.nPortIndex = m_omx_image_fx.GetOutputPort();
+    image_filter.nNumParams = 1;
+    image_filter.nParams[0] = 3;
+    image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
+
+    omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - OMX_IndexConfigCommonImageFilterParameters omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if(m_deinterlace)
+  {
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_image_fx, m_omx_image_fx.GetInputPort());
+    m_omx_tunnel_image_fx.Initialize(&m_omx_image_fx, m_omx_image_fx.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
+  }
+  else
+  {
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
+  }
+  m_omx_tunnel_sched.Initialize(&m_omx_sched, m_omx_sched.GetOutputPort(), &m_omx_render, m_omx_render.GetInputPort());
+
+  m_omx_tunnel_clock.Initialize(m_omx_clock, m_omx_clock->GetInputPort()  + 1, &m_omx_sched, m_omx_sched.GetOutputPort()  + 1);
+
+  omx_err = m_omx_tunnel_clock.Establish();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_clock.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_tunnel_decoder.Establish();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_decoder.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if(m_deinterlace)
+  {
+    omx_err = m_omx_tunnel_image_fx.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_image_fx.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    omx_err = m_omx_image_fx.SetStateForComponent(OMX_StateExecuting);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_image_fx.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  omx_err = m_omx_tunnel_sched.Establish();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_sched.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_sched.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_sched.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_render.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_render.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  m_settings_changed = true;
+  return true;
+}
+
+bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace, bool hdmi_clock_sync)
+{
+  CSingleLock lock (m_critSection);
   bool vflip = false;
   Close();
-
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
   std::string decoder_name;
+  m_settings_changed = false;
+  m_setStartTime = true;
 
   m_res_ctx           = NULL;
   m_res_callback      = NULL;
@@ -165,6 +352,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
 
   m_hdmi_clock_sync = hdmi_clock_sync;
   m_submitted_eos = false;
+  m_failed_eos    = false;
 
   if(!m_decoded_width || !m_decoded_height)
     return false;
@@ -214,24 +402,6 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
           m_video_codec_name = "omx-h264";
           break;
       }
-
-      /* check interlaced */
-      if(m_extrasize > 9 && m_extradata[0] == 1)
-      {
-        CBitstreamConverter converter;
-        converter.Open(hints.codec, (uint8_t *)hints.extradata, hints.extrasize, true);
-
-        int32_t  max_ref_frames = 0;
-        uint8_t  *spc = m_extradata + 6;
-        uint32_t sps_size = BS_RB16(spc);
-        bool     interlaced = true;
-        if (sps_size)
-          converter.parseh264_sps(spc+3, sps_size-1, &interlaced, &max_ref_frames);
-        if(!interlaced && deinterlace)
-          deinterlace = false;
-
-        converter.Close();
-      }
     }
     break;
     case CODEC_ID_MPEG4:
@@ -299,69 +469,14 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
       m_video_codec_name = "omx-vc1";
       break;
     default:
+      CLog::Log(LOGERROR, "COMXVideo::Open : Video codec unknown: %x", hints.codec);
       return false;
     break;
   }
+  m_deinterlace_request = deinterlace;
 
-  /* enable deintelace on SD and 1080i */
-  if(m_decoded_width <= 720 && m_decoded_height <=576 && deinterlace)
-    m_deinterlace = deinterlace;
-  else if(m_decoded_width >= 1920 && m_decoded_height >= 540 && deinterlace)
-    m_deinterlace = deinterlace;
-
-  if(m_deinterlace)
-    CLog::Log(LOGDEBUG, "COMXVideo::Open : enable deinterlace\n");
-
-  std::string componentName = "";
-
-  componentName = decoder_name;
-  if(!m_omx_decoder.Initialize((const std::string)componentName, OMX_IndexParamVideoInit))
-    return false;
-
-  componentName = "OMX.broadcom.video_render";
-  if(!m_omx_render.Initialize((const std::string)componentName, OMX_IndexParamVideoInit))
-    return false;
-
-  m_omx_render.ResetEos();
-
-  componentName = "OMX.broadcom.video_scheduler";
-  if(!m_omx_sched.Initialize((const std::string)componentName, OMX_IndexParamVideoInit))
-    return false;
-
-  if(m_deinterlace)
-  {
-    componentName = "OMX.broadcom.image_fx";
-    if(!m_omx_image_fx.Initialize((const std::string)componentName, OMX_IndexParamImageInit))
-      return false;
-  }
-
-  OMX_VIDEO_PARAM_PORTFORMATTYPE formatType;
-  /*
-  OMX_INIT_STRUCTURE(formatType);
-  formatType.nPortIndex = m_omx_decoder.GetInputPort();
-  OMX_U32 nIndex = 1;
-  bool bFound = false;
-
-  omx_err = OMX_ErrorNone;
-  do
-  {
-    formatType.nIndex = nIndex;
-    omx_err = m_omx_decoder.GetParameter(OMX_IndexParamVideoPortFormat, &formatType);
-    if(formatType.eCompressionFormat == m_codingType)
-    {
-      bFound = true;
-      break;
-    }
-    nIndex++;
-  }
-  while(omx_err == OMX_ErrorNone);
-
-  if(!bFound)
-  {
-    CLog::Log(LOGINFO, "COMXVideo::Open coding : %s not supported\n", m_video_codec_name.c_str());
+  if(!m_omx_decoder.Initialize(decoder_name, OMX_IndexParamVideoInit))
     return false;
-  }
-  */
 
   if(clock == NULL)
     return false;
@@ -376,26 +491,6 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
     return false;
   }
 
-  if(m_deinterlace)
-  {
-    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_image_fx, m_omx_image_fx.GetInputPort());
-    m_omx_tunnel_image_fx.Initialize(&m_omx_image_fx, m_omx_image_fx.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
-  }
-  else
-  {
-    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
-  }
-  m_omx_tunnel_sched.Initialize(&m_omx_sched, m_omx_sched.GetOutputPort(), &m_omx_render, m_omx_render.GetInputPort());
-
-  m_omx_tunnel_clock.Initialize(m_omx_clock, m_omx_clock->GetInputPort()  + 1, &m_omx_sched, m_omx_sched.GetOutputPort()  + 1);
-
-  omx_err = m_omx_tunnel_clock.Establish(false);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open m_omx_tunnel_clock.Establish\n");
-    return false;
-  }
-
   omx_err = m_omx_decoder.SetStateForComponent(OMX_StateIdle);
   if (omx_err != OMX_ErrorNone)
   {
@@ -403,6 +498,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
     return false;
   }
 
+  OMX_VIDEO_PARAM_PORTFORMATTYPE formatType;
   OMX_INIT_STRUCTURE(formatType);
   formatType.nPortIndex = m_omx_decoder.GetInputPort();
   formatType.eCompressionFormat = m_codingType;
@@ -432,8 +528,8 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
   }
 
   portParam.nPortIndex = m_omx_decoder.GetInputPort();
-  portParam.nBufferCountActual = VIDEO_BUFFERS;
-
+  bool small_mem = g_RBP.GetArmMem() < 256;
+  portParam.nBufferCountActual = small_mem ? VIDEO_BUFFERS:2*VIDEO_BUFFERS;
   portParam.format.video.nFrameWidth  = m_decoded_width;
   portParam.format.video.nFrameHeight = m_decoded_height;
 
@@ -444,6 +540,20 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
     return false;
   }
 
+  // request portsettingschanged on aspect ratio change
+  OMX_CONFIG_REQUESTCALLBACKTYPE notifications;
+  OMX_INIT_STRUCTURE(notifications);
+  notifications.nPortIndex = m_omx_decoder.GetOutputPort();
+  notifications.nIndex = OMX_IndexParamBrcmPixelAspectRatio;
+  notifications.bEnable = OMX_TRUE;
+
+  omx_err = m_omx_decoder.SetParameter((OMX_INDEXTYPE)OMX_IndexConfigRequestCallback, &notifications);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXVideo::Open OMX_IndexConfigRequestCallback error (0%08x)\n", omx_err);
+    return false;
+  }
+
   OMX_PARAM_BRCMVIDEODECODEERRORCONCEALMENTTYPE concanParam;
   OMX_INIT_STRUCTURE(concanParam);
   if(g_advancedSettings.m_omxDecodeStartWithValidFrame)
@@ -458,7 +568,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
     return false;
   }
 
-  if (m_deinterlace)
+  if (m_deinterlace_request != VS_DEINTERLACEMODE_OFF)
   {
     // the deinterlace component requires 3 additional video buffers in addition to the DPB (this is normally 2).
     OMX_PARAM_U32TYPE extra_buffers;
@@ -473,6 +583,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
     }
   }
 
+
   // broadcom omx entension:
   // When enabled, the timestamp fifo mode will change the way incoming timestamps are associated with output images.
   // In this mode the incoming timestamps get used without re-ordering on output images.
@@ -505,26 +616,6 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
     }
   }
 
-  if(m_hdmi_clock_sync)
-  {
-    OMX_CONFIG_LATENCYTARGETTYPE latencyTarget;
-    OMX_INIT_STRUCTURE(latencyTarget);
-    latencyTarget.nPortIndex = m_omx_render.GetInputPort();
-    latencyTarget.bEnabled = OMX_TRUE;
-    latencyTarget.nFilter = 2;
-    latencyTarget.nTarget = 4000;
-    latencyTarget.nShift = 3;
-    latencyTarget.nSpeedFactor = -135;
-    latencyTarget.nInterFactor = 500;
-    latencyTarget.nAdjCap = 20;
-
-    omx_err = m_omx_render.SetConfig(OMX_IndexConfigLatencyTarget, &latencyTarget);
-    if (omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXVideo::Open OMX_IndexConfigLatencyTarget error (0%08x)\n", omx_err);
-      return false;
-    }
-  }
 
   // Alloc buffers for the omx intput port.
   omx_err = m_omx_decoder.AllocInputBuffers();
@@ -534,13 +625,6 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
     return false;
   }
 
-  omx_err = m_omx_tunnel_decoder.Establish(false);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open m_omx_tunnel_decoder.Establish\n");
-    return false;
-  }
-
   omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
   if (omx_err != OMX_ErrorNone)
   {
@@ -548,152 +632,29 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
     return false;
   }
 
-  if(m_deinterlace)
-  {
-    OMX_CONFIG_IMAGEFILTERPARAMSTYPE image_filter;
-    OMX_INIT_STRUCTURE(image_filter);
-
-    image_filter.nPortIndex = m_omx_image_fx.GetOutputPort();
-    image_filter.nNumParams = 1;
-    image_filter.nParams[0] = 3;
-    image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
-
-    omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXVideo::Open error OMX_IndexConfigCommonImageFilterParameters omx_err(0x%08x)\n", omx_err);
-      return false;
-    }
-
-    omx_err = m_omx_tunnel_image_fx.Establish(false);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXVideo::Open m_omx_tunnel_image_fx.Establish\n");
-      return false;
-    }
-
-    omx_err = m_omx_image_fx.SetStateForComponent(OMX_StateExecuting);
-    if (omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXVideo::Open error m_omx_image_fx.SetStateForComponent\n");
-      return false;
-    }
-
-    m_omx_image_fx.DisablePort(m_omx_image_fx.GetInputPort(), false);
-    m_omx_image_fx.DisablePort(m_omx_image_fx.GetOutputPort(), false);
-  }
-
-  omx_err = m_omx_tunnel_sched.Establish(false);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open m_omx_tunnel_sched.Establish\n");
-    return false;
-  }
-
-  omx_err = m_omx_sched.SetStateForComponent(OMX_StateExecuting);
-  if (omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open error m_omx_sched.SetStateForComponent\n");
-    return false;
-  }
-
-  omx_err = m_omx_render.SetStateForComponent(OMX_StateExecuting);
-  if (omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open error m_omx_render.SetStateForComponent\n");
-    return false;
-  }
-
   if(!SendDecoderConfig())
     return false;
 
   m_is_open           = true;
   m_drop_state        = false;
 
-  OMX_CONFIG_DISPLAYREGIONTYPE configDisplay;
-  OMX_INIT_STRUCTURE(configDisplay);
-  configDisplay.nPortIndex = m_omx_render.GetInputPort();
-
-  configDisplay.set = OMX_DISPLAY_SET_TRANSFORM;
-
   switch(hints.orientation)
   {
     case 90:
-      configDisplay.transform = OMX_DISPLAY_ROT90;
+      m_transform = OMX_DISPLAY_ROT90;
       break;
     case 180:
-      configDisplay.transform = OMX_DISPLAY_ROT180;
+      m_transform = OMX_DISPLAY_ROT180;
       break;
     case 270:
-      configDisplay.transform = OMX_DISPLAY_ROT270;
+      m_transform = OMX_DISPLAY_ROT270;
       break;
     default:
-      configDisplay.transform = OMX_DISPLAY_ROT0;
+      m_transform = OMX_DISPLAY_ROT0;
       break;
   }
   if (vflip)
-      configDisplay.transform = OMX_DISPLAY_MIRROR_ROT180;
-
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGWARNING, "COMXVideo::Open could not set orientation : %d\n", hints.orientation);
-  }
-
-  /*
-  configDisplay.set     = OMX_DISPLAY_SET_LAYER;
-  configDisplay.layer   = 2;
-
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_DEST_RECT;
-  configDisplay.dest_rect.x_offset  = 100;
-  configDisplay.dest_rect.y_offset  = 100;
-  configDisplay.dest_rect.width     = 640;
-  configDisplay.dest_rect.height    = 480;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_TRANSFORM;
-  configDisplay.transform = OMX_DISPLAY_ROT180;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_FULLSCREEN;
-  configDisplay.fullscreen = OMX_FALSE;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_MODE;
-  configDisplay.mode    = OMX_DISPLAY_MODE_FILL; //OMX_DISPLAY_MODE_LETTERBOX;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_LAYER;
-  configDisplay.layer   = 1;
-
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_ALPHA;
-  configDisplay.alpha   = OMX_FALSE;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  */
+      m_transform = OMX_DISPLAY_MIRROR_ROT180;
 
   if(m_omx_decoder.BadState())
     return false;
@@ -701,22 +662,15 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, b
   CLog::Log(LOGDEBUG,
     "%s::%s - decoder_component(0x%p), input_port(0x%x), output_port(0x%x) deinterlace %d hdmiclocksync %d\n",
     CLASSNAME, __func__, m_omx_decoder.GetComponent(), m_omx_decoder.GetInputPort(), m_omx_decoder.GetOutputPort(),
-    m_deinterlace, m_hdmi_clock_sync);
-
-  // start from assuming all recent frames had valid pts
-  m_history_valid_pts = ~0;
+    m_deinterlace_request, m_hdmi_clock_sync);
 
   return true;
 }
 
+
 void COMXVideo::Close()
 {
-  m_omx_tunnel_decoder.Flush();
-  if(m_deinterlace)
-    m_omx_tunnel_image_fx.Flush();
-  m_omx_tunnel_clock.Flush();
-  m_omx_tunnel_sched.Flush();
-
+  CSingleLock lock (m_critSection);
   m_omx_tunnel_clock.Deestablish();
   m_omx_tunnel_decoder.Deestablish();
   if(m_deinterlace)
@@ -725,11 +679,11 @@ void COMXVideo::Close()
 
   m_omx_decoder.FlushInput();
 
-  m_omx_sched.Deinitialize(true);
-  m_omx_decoder.Deinitialize(true);
+  m_omx_sched.Deinitialize();
+  m_omx_decoder.Deinitialize();
   if(m_deinterlace)
-    m_omx_image_fx.Deinitialize(true);
-  m_omx_render.Deinitialize(true);
+    m_omx_image_fx.Deinitialize();
+  m_omx_render.Deinitialize();
 
   m_is_open       = false;
 
@@ -738,7 +692,6 @@ void COMXVideo::Close()
   m_extradata = NULL;
   m_extrasize = 0;
 
-  m_video_convert     = false;
   m_video_codec_name  = "";
   m_deinterlace       = false;
   m_av_clock          = NULL;
@@ -754,27 +707,22 @@ void COMXVideo::SetDropState(bool bDrop)
 
 unsigned int COMXVideo::GetFreeSpace()
 {
+  CSingleLock lock (m_critSection);
   return m_omx_decoder.GetInputBufferSpace();
 }
 
 unsigned int COMXVideo::GetSize()
 {
+  CSingleLock lock (m_critSection);
   return m_omx_decoder.GetInputBufferSize();
 }
 
-static unsigned count_bits(int32_t value)
-{
-  unsigned bits = 0;
-  for(;value;++bits)
-    value &= value - 1;
-  return bits;
-}
-
-int COMXVideo::Decode(uint8_t *pData, int iSize, double dts, double pts)
+int COMXVideo::Decode(uint8_t *pData, int iSize, double pts)
 {
+  CSingleLock lock (m_critSection);
   OMX_ERRORTYPE omx_err;
 
-  if( m_drop_state )
+  if( m_drop_state || !m_is_open )
     return true;
 
   unsigned int demuxer_bytes = (unsigned int)iSize;
@@ -792,33 +740,14 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double dts, double pts)
         return false;
       }
 
-      /*
-      CLog::Log(DEBUG, "COMXVideo::Video VDec : pts %lld omx_buffer 0x%08x buffer 0x%08x number %d\n", 
-          pts, omx_buffer, omx_buffer->pBuffer, (int)omx_buffer->pAppPrivate);
-      if(pts == DVD_NOPTS_VALUE)
-      {
-        CLog::Log(LOGDEBUG, "VDec : pts %f omx_buffer 0x%08x buffer 0x%08x number %d\n", 
-          (float)pts / AV_TIME_BASE, (int)omx_buffer, (int)omx_buffer->pBuffer, (int)omx_buffer->pAppPrivate);
-      }
-      */
-
       omx_buffer->nFlags = 0;
       omx_buffer->nOffset = 0;
-      // some packed bitstream AVI files set almost all pts values to DVD_NOPTS_VALUE, but have a scattering of real pts values.
-      // the valid pts values match the dts values.
-      // if a stream has had more than 4 valid pts values in the last 16, the use UNKNOWN, otherwise use dts
-      m_history_valid_pts = (m_history_valid_pts << 1) | (pts != DVD_NOPTS_VALUE);
-      if(pts == DVD_NOPTS_VALUE && count_bits(m_history_valid_pts & 0xffff) < 4)
-        pts = dts;
-
-      if(m_av_clock->VideoStart())
+
+      if(m_setStartTime)
       {
-        // only send dts on first frame to get nearly correct starttime
-        if(pts == DVD_NOPTS_VALUE)
-          pts = dts;
         omx_buffer->nFlags |= OMX_BUFFERFLAG_STARTTIME;
         CLog::Log(LOGDEBUG, "OMXVideo::Decode VDec : setStartTime %f\n", (pts == DVD_NOPTS_VALUE ? 0.0 : pts) / DVD_TIME_BASE);
-        m_av_clock->VideoStart(false);
+        m_setStartTime = false;
       }
       if(pts == DVD_NOPTS_VALUE)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
@@ -849,7 +778,7 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double dts, double pts)
         }
         if(nRetry == 5)
         {
-          CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() finaly failed\n", CLASSNAME, __func__);
+          CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() finally failed\n", CLASSNAME, __func__);
           return false;
         }
       }
@@ -857,74 +786,21 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double dts, double pts)
       omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, 0);
       if (omx_err == OMX_ErrorNone)
       {
-        OMX_PARAM_PORTDEFINITIONTYPE port_image;
-        OMX_INIT_STRUCTURE(port_image);
-        port_image.nPortIndex = m_omx_decoder.GetOutputPort();
-        omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_image);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-        }
-        // let OMXPlayerVideo know about resolution so it can inform RenderManager
-        if (m_res_callback)
-          m_res_callback(m_res_ctx, port_image.format.video.nFrameWidth, port_image.format.video.nFrameHeight);
-
-        m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
-        m_omx_sched.DisablePort(m_omx_sched.GetInputPort(), true);
-
-        OMX_CONFIG_INTERLACETYPE interlace;
-        OMX_INIT_STRUCTURE(interlace);
-        interlace.nPortIndex = m_omx_decoder.GetOutputPort();
-        omx_err = m_omx_decoder.GetConfig(OMX_IndexConfigCommonInterlace, &interlace);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetConfig(OMX_IndexConfigCommonInterlace) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-        }
-
-        if (m_deinterlace)
+        if(!PortSettingsChanged())
         {
-          m_omx_image_fx.DisablePort(m_omx_image_fx.GetInputPort(), true);
-          port_image.nPortIndex = m_omx_image_fx.GetInputPort();
-          omx_err = m_omx_image_fx.SetParameter(OMX_IndexParamPortDefinition, &port_image);
-          if(omx_err != OMX_ErrorNone)
-          {
-            CLog::Log(LOGERROR, "%s::%s - error m_omx_image_fx.SetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-          }
-          omx_err = m_omx_image_fx.WaitForEvent(OMX_EventPortSettingsChanged);
-          if(omx_err != OMX_ErrorNone)
-          {
-             CLog::Log(LOGERROR, "%s::%s - error m_omx_image_fx.WaitForEvent(OMX_EventPortSettingsChanged) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-          }
-          port_image.nPortIndex = m_omx_image_fx.GetOutputPort();
-          omx_err = m_omx_image_fx.GetParameter(OMX_IndexParamPortDefinition, &port_image);
-          if(omx_err != OMX_ErrorNone)
-          {
-            CLog::Log(LOGERROR, "%s::%s - error m_omx_image_fx.GetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-          }
-          m_omx_image_fx.EnablePort(m_omx_image_fx.GetInputPort(), true);
-
-          m_omx_image_fx.DisablePort(m_omx_image_fx.GetOutputPort(), true);
-        }
-        port_image.nPortIndex = m_omx_sched.GetInputPort();
-        omx_err = m_omx_sched.SetParameter(OMX_IndexParamPortDefinition, &port_image);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "%s::%s - error m_omx_sched.SetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-        }
-        omx_err = m_omx_sched.WaitForEvent(OMX_EventPortSettingsChanged);
-        if(omx_err != OMX_ErrorNone)
-        {
-           CLog::Log(LOGERROR, "%s::%s - error m_omx_sched.WaitForEvent(OMX_EventPortSettingsChanged) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+          CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+          return false;
         }
-        if (m_deinterlace)
+      }
+      omx_err = m_omx_decoder.WaitForEvent(OMX_EventParamOrConfigChanged, 0);
+      if (omx_err == OMX_ErrorNone)
+      {
+        if(!PortSettingsChanged())
         {
-          m_omx_image_fx.EnablePort(m_omx_image_fx.GetOutputPort(), true);
+          CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged (EventParamOrConfigChanged) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
         }
-        m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
-        m_omx_sched.EnablePort(m_omx_sched.GetInputPort(), true);
       }
     }
-
     return true;
 
   }
@@ -934,78 +810,24 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double dts, double pts)
 
 void COMXVideo::Reset(void)
 {
+  CSingleLock lock (m_critSection);
   if(!m_is_open)
     return;
 
+  m_setStartTime = true;
   m_omx_decoder.FlushInput();
-  m_omx_tunnel_decoder.Flush();
-
-  /*
-  OMX_ERRORTYPE omx_err;
-  OMX_CONFIG_BOOLEANTYPE configBool;
-  OMX_INIT_STRUCTURE(configBool);
-  configBool.bEnabled = OMX_TRUE;
-
-  omx_err = m_omx_decoder.SetConfig(OMX_IndexConfigRefreshCodec, &configBool);
-  if (omx_err != OMX_ErrorNone)
-    CLog::Log(LOGERROR, "%s::%s - error reopen codec omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-
-  SendDecoderConfig();
-
-  */
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-bool COMXVideo::Pause()
-{
-  if(m_omx_render.GetComponent() == NULL)
-    return false;
-
-  if(m_Pause) return true;
-  m_Pause = true;
-
-  m_omx_sched.SetStateForComponent(OMX_StatePause);
-  m_omx_render.SetStateForComponent(OMX_StatePause);
-
-  return true;
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-bool COMXVideo::Resume()
-{
-  if(m_omx_render.GetComponent() == NULL)
-    return false;
-
-  if(!m_Pause) return true;
-  m_Pause = false;
-
-  m_omx_sched.SetStateForComponent(OMX_StateExecuting);
-  m_omx_render.SetStateForComponent(OMX_StateExecuting);
-
-  return true;
+  if(m_deinterlace)
+    m_omx_image_fx.FlushInput();
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////
 void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect)
 {
+  CSingleLock lock (m_critSection);
   if(!m_is_open)
     return;
 
   OMX_CONFIG_DISPLAYREGIONTYPE configDisplay;
-  float sx1 = SrcRect.x1, sy1 = SrcRect.y1, sx2 = SrcRect.x2, sy2 = SrcRect.y2;
-  float dx1 = DestRect.x1, dy1 = DestRect.y1, dx2 = DestRect.x2, dy2 = DestRect.y2;
-  float sw = SrcRect.Width() / DestRect.Width();
-  float sh = SrcRect.Height() / DestRect.Height();
-
-  // doesn't like negative coordinates on dest_rect. So adjust by increasing src_rect
-  if (dx1 < 0.0f) {
-    sx1 -= dx1 * sw;
-    dx1 -= dx1;
-  }
-  if (dy1 < 0.0f) {
-    sy1 -= dy1 * sh;
-    dy1 -= dy1;
-  }
 
   OMX_INIT_STRUCTURE(configDisplay);
   configDisplay.nPortIndex = m_omx_render.GetInputPort();
@@ -1013,15 +835,15 @@ void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect)
   configDisplay.noaspect   = OMX_TRUE;
 
   configDisplay.set                 = (OMX_DISPLAYSETTYPE)(OMX_DISPLAY_SET_DEST_RECT|OMX_DISPLAY_SET_SRC_RECT|OMX_DISPLAY_SET_FULLSCREEN|OMX_DISPLAY_SET_NOASPECT);
-  configDisplay.dest_rect.x_offset  = (int)(dx1+0.5f);
-  configDisplay.dest_rect.y_offset  = (int)(dy1+0.5f);
-  configDisplay.dest_rect.width     = (int)(dx2-dx1+0.5f);
-  configDisplay.dest_rect.height    = (int)(dy2-dy1+0.5f);
+  configDisplay.dest_rect.x_offset  = (int)(DestRect.x1+0.5f);
+  configDisplay.dest_rect.y_offset  = (int)(DestRect.y1+0.5f);
+  configDisplay.dest_rect.width     = (int)(DestRect.Width()+0.5f);
+  configDisplay.dest_rect.height    = (int)(DestRect.Height()+0.5f);
 
-  configDisplay.src_rect.x_offset   = (int)(sx1+0.5f);
-  configDisplay.src_rect.y_offset   = (int)(sy1+0.5f);
-  configDisplay.src_rect.width      = (int)(sx2-sx1+0.5f);
-  configDisplay.src_rect.height     = (int)(sy2-sy1+0.5f);
+  configDisplay.src_rect.x_offset   = (int)(SrcRect.x1+0.5f);
+  configDisplay.src_rect.y_offset   = (int)(SrcRect.y1+0.5f);
+  configDisplay.src_rect.width      = (int)(SrcRect.Width()+0.5f);
+  configDisplay.src_rect.height     = (int)(SrcRect.Height()+0.5f);
 
   m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
 
@@ -1032,22 +854,26 @@ void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect)
 
 int COMXVideo::GetInputBufferSize()
 {
+  CSingleLock lock (m_critSection);
   return m_omx_decoder.GetInputBufferSize();
 }
 
 void COMXVideo::SubmitEOS()
 {
+  CSingleLock lock (m_critSection);
   if(!m_is_open)
     return;
 
   m_submitted_eos = true;
+  m_failed_eos = false;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer();
+  OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(1000);
   
   if(omx_buffer == NULL)
   {
     CLog::Log(LOGERROR, "%s::%s - buffer error 0x%08x", CLASSNAME, __func__, omx_err);
+    m_failed_eos = true;
     return;
   }
   
@@ -1063,11 +889,20 @@ void COMXVideo::SubmitEOS()
     CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)\n", CLASSNAME, __func__, omx_err);
     return;
   }
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
 }
 
 bool COMXVideo::IsEOS()
 {
+  CSingleLock lock (m_critSection);
   if(!m_is_open)
     return true;
-  return m_omx_render.IsEOS();
+  if (!m_failed_eos && !m_omx_render.IsEOS())
+    return false;
+  if (m_submitted_eos)
+  {
+    CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+    m_submitted_eos = false;
+  }
+  return true;
 }
diff --git a/xbmc/cores/omxplayer/OMXVideo.h b/xbmc/cores/omxplayer/OMXVideo.h
index 96ccb34..2cae0c6 100644
--- a/xbmc/cores/omxplayer/OMXVideo.h
+++ b/xbmc/cores/omxplayer/OMXVideo.h
@@ -30,13 +30,15 @@
 
 #include "guilib/Geometry.h"
 #include "DVDDemuxers/DVDDemux.h"
+#include "xbmc/settings/VideoSettings.h"
+#include "threads/CriticalSection.h"
 #include <string>
 
 #define VIDEO_BUFFERS 60
 
 #define CLASSNAME "COMXVideo"
 
-typedef void (*ResolutionUpdateCallBackFn)(void *ctx, uint32_t width, uint32_t height);
+typedef void (*ResolutionUpdateCallBackFn)(void *ctx, uint32_t width, uint32_t height, float display_aspect);
 
 class COMXVideo
 {
@@ -46,16 +48,15 @@ class COMXVideo
 
   // Required overrides
   bool SendDecoderConfig();
-  bool Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace = false, bool hdmi_clock_sync = false);
+  bool Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace = VS_DEINTERLACEMODE_OFF, bool hdmi_clock_sync = false);
+  bool PortSettingsChanged();
   void RegisterResolutionUpdateCallBack(void *ctx, ResolutionUpdateCallBackFn callback) { m_res_ctx = ctx; m_res_callback = callback; }
   void Close(void);
   unsigned int GetFreeSpace();
   unsigned int GetSize();
-  int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  int  Decode(uint8_t *pData, int iSize, double pts);
   void Reset(void);
   void SetDropState(bool bDrop);
-  bool Pause();
-  bool Resume();
   std::string GetDecoderName() { return m_video_codec_name; };
   void SetVideoRect(const CRect& SrcRect, const CRect& DestRect);
   int GetInputBufferSize();
@@ -83,22 +84,24 @@ class COMXVideo
   COMXCoreTunel     m_omx_tunnel_sched;
   COMXCoreTunel     m_omx_tunnel_image_fx;
   bool              m_is_open;
-
-  bool              m_Pause;
+  bool              m_setStartTime;
 
   uint8_t           *m_extradata;
   int               m_extrasize;
 
-  bool              m_video_convert;
   std::string       m_video_codec_name;
 
   bool              m_deinterlace;
+  EDEINTERLACEMODE  m_deinterlace_request;
   bool              m_hdmi_clock_sync;
-  uint32_t          m_history_valid_pts;
   ResolutionUpdateCallBackFn m_res_callback;
   void              *m_res_ctx;
   bool              m_submitted_eos;
+  bool              m_failed_eos;
+  OMX_DISPLAYTRANSFORMTYPE m_transform;
+  bool              m_settings_changed;
   bool NaluFormatStartCodes(enum CodecID codec, uint8_t *in_extradata, int in_extrasize);
+  CCriticalSection m_critSection;
 };
 
 #endif
diff --git a/xbmc/cores/omxplayer/PCMRemap.cpp b/xbmc/cores/omxplayer/PCMRemap.cpp
new file mode 100644
index 0000000..df805c4
--- /dev/null
+++ b/xbmc/cores/omxplayer/PCMRemap.cpp
@@ -0,0 +1,813 @@
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS
+#endif
+
+#include <cstdlib>
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+
+//#include "MathUtils.h"
+#include "PCMRemap.h"
+#include "utils/log.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#ifdef _WIN32
+#include "../win32/PlatformDefs.h"
+#endif
+
+static enum PCMChannels PCMLayoutMap[PCM_MAX_LAYOUT][PCM_MAX_CH + 1] =
+{
+  /* 2.0 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_INVALID},
+  /* 2.1 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_LOW_FREQUENCY, PCM_INVALID},
+  /* 3.0 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_FRONT_CENTER, PCM_INVALID},
+  /* 3.1 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_FRONT_CENTER, PCM_LOW_FREQUENCY, PCM_INVALID},
+  /* 4.0 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_BACK_LEFT, PCM_BACK_RIGHT, PCM_INVALID},
+  /* 4.1 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_BACK_LEFT, PCM_BACK_RIGHT, PCM_LOW_FREQUENCY, PCM_INVALID},
+  /* 5.0 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_FRONT_CENTER, PCM_BACK_LEFT, PCM_BACK_RIGHT, PCM_INVALID},
+  /* 5.1 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_FRONT_CENTER, PCM_BACK_LEFT, PCM_BACK_RIGHT, PCM_LOW_FREQUENCY, PCM_INVALID},
+  /* 7.0 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_FRONT_CENTER, PCM_SIDE_LEFT, PCM_SIDE_RIGHT, PCM_BACK_LEFT, PCM_BACK_RIGHT, PCM_INVALID},
+  /* 7.1 */ {PCM_FRONT_LEFT, PCM_FRONT_RIGHT, PCM_FRONT_CENTER, PCM_SIDE_LEFT, PCM_SIDE_RIGHT, PCM_BACK_LEFT, PCM_BACK_RIGHT, PCM_LOW_FREQUENCY, PCM_INVALID}
+};
+
+/*
+  map missing output into channel @ volume level
+  the order of this table is important, mix tables can not depend on channels that have not been defined yet
+  eg, FC can only be mixed into FL, FR as they are the only channels that have been defined
+*/
+#define PCM_MAX_MIX 3
+static struct PCMMapInfo PCMDownmixTable[PCM_MAX_CH][PCM_MAX_MIX] =
+{
+  /* PCM_FRONT_LEFT */
+  {
+    {PCM_INVALID}
+  },
+  /* PCM_FRONT_RIGHT */
+  {
+    {PCM_INVALID}
+  },
+  /* PCM_FRONT_CENTER */
+  {
+    {PCM_FRONT_LEFT_OF_CENTER , 1.0},
+    {PCM_FRONT_RIGHT_OF_CENTER, 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_LOW_FREQUENCY */
+  {
+    /*
+      A/52B 7.8 paragraph 2 recomends +10db
+      but due to horrible clipping when normalize
+      is disabled we set this to 1.0
+    */
+    {PCM_FRONT_LEFT           , 1.0},//3.5},
+    {PCM_FRONT_RIGHT          , 1.0},//3.5},
+    {PCM_INVALID}
+  },
+  /* PCM_BACK_LEFT */
+  {
+    {PCM_FRONT_LEFT           , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_BACK_RIGHT */
+  {
+    {PCM_FRONT_RIGHT          , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_FRONT_LEFT_OF_CENTER */
+  {
+    {PCM_FRONT_LEFT           , 1.0},
+    {PCM_FRONT_CENTER         , 1.0, true},
+    {PCM_INVALID}
+  },
+  /* PCM_FRONT_RIGHT_OF_CENTER */
+  {
+    {PCM_FRONT_RIGHT          , 1.0},
+    {PCM_FRONT_CENTER         , 1.0, true},
+    {PCM_INVALID}
+  },
+  /* PCM_BACK_CENTER */
+  {
+    {PCM_BACK_LEFT            , 1.0},
+    {PCM_BACK_RIGHT           , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_SIDE_LEFT */
+  {
+    {PCM_FRONT_LEFT           , 1.0},
+    {PCM_BACK_LEFT            , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_SIDE_RIGHT */
+  {
+    {PCM_FRONT_RIGHT          , 1.0},
+    {PCM_BACK_RIGHT           , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_TOP_FRONT_LEFT */
+  {
+    {PCM_FRONT_LEFT           , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_TOP_FRONT_RIGHT */
+  {
+    {PCM_FRONT_RIGHT          , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_TOP_FRONT_CENTER */
+  {
+    {PCM_TOP_FRONT_LEFT       , 1.0},
+    {PCM_TOP_FRONT_RIGHT      , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_TOP_CENTER */
+  {
+    {PCM_TOP_FRONT_LEFT       , 1.0},
+    {PCM_TOP_FRONT_RIGHT      , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_TOP_BACK_LEFT */
+  {
+    {PCM_BACK_LEFT            , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_TOP_BACK_RIGHT */
+  {
+    {PCM_BACK_RIGHT           , 1.0},
+    {PCM_INVALID}
+  },
+  /* PCM_TOP_BACK_CENTER */
+  {
+    {PCM_TOP_BACK_LEFT        , 1.0},
+    {PCM_TOP_BACK_RIGHT       , 1.0},
+    {PCM_INVALID}
+  }
+};
+
+CPCMRemap::CPCMRemap() :
+  m_inSet       (false),
+  m_outSet      (false),
+  m_inChannels  (0),
+  m_outChannels (0),
+  m_inSampleSize(0),
+  m_ignoreLayout(false),
+  m_buf(NULL),
+  m_bufsize(0),
+  m_attenuation (1.0),
+  m_attenuationInc(0.0),
+  m_attenuationMin(1.0),
+  m_sampleRate  (48000.0), //safe default
+  m_holdCounter (0),
+  m_limiterEnabled(false)
+{
+  Dispose();
+}
+
+CPCMRemap::~CPCMRemap()
+{
+  Dispose();
+}
+
+void CPCMRemap::Dispose()
+{
+  free(m_buf);
+  m_buf = NULL;
+  m_bufsize = 0;
+}
+
+/* resolves the channels recursively and returns the new index of tablePtr */
+struct PCMMapInfo* CPCMRemap::ResolveChannel(enum PCMChannels channel, float level, bool ifExists, std::vector<enum PCMChannels> path, struct PCMMapInfo *tablePtr)
+{
+  if (channel == PCM_INVALID) return tablePtr;
+
+  /* if its a 1 to 1 mapping, return */
+  if (m_useable[channel])
+  {
+    tablePtr->channel = channel;
+    tablePtr->level   = level;
+
+    ++tablePtr;
+    tablePtr->channel = PCM_INVALID;
+    return tablePtr;
+  } else
+    if (ifExists)
+      level /= 2;
+
+  struct PCMMapInfo *info;
+  std::vector<enum PCMChannels>::iterator itt;
+
+  for(info = PCMDownmixTable[channel]; info->channel != PCM_INVALID; ++info)
+  {
+    /* make sure we are not about to recurse into ourself */
+    bool found = false;
+    for(itt = path.begin(); itt != path.end(); ++itt)
+      if (*itt == info->channel)
+      {
+        found = true;
+        break;
+      }
+
+    if (found)
+      continue;
+
+    path.push_back(channel);
+    float  l = (info->level * (level / 100)) * 100;
+    tablePtr = ResolveChannel(info->channel, l, info->ifExists, path, tablePtr);
+    path.pop_back();
+  }
+
+  return tablePtr;
+}
+
+/*
+  Builds a lookup table without extra adjustments, useful if we simply
+  want to find out which channels are active.
+  For final adjustments, BuildMap() is used.
+*/
+void CPCMRemap::ResolveChannels()
+{
+  unsigned int in_ch, out_ch;
+  bool hasSide = false;
+  bool hasBack = false;
+
+  memset(m_useable, 0, sizeof(m_useable));
+
+  if (!m_outSet)
+  {
+    /* Output format is not known yet, assume the full configured map.
+     * Note that m_ignoreLayout-using callers normally ignore the result of
+     * this function when !m_outSet, when it is called only for an advice for
+     * the caller of SetInputFormat about the best possible output map, and
+     * they can still set their output format arbitrarily in their call to
+     * SetOutputFormat. */
+    for (enum PCMChannels *chan = PCMLayoutMap[m_channelLayout]; *chan != PCM_INVALID; ++chan)
+         m_useable[*chan] = true;
+  }
+  else if (m_ignoreLayout)
+  {
+    for(out_ch = 0; out_ch < m_outChannels; ++out_ch)
+      m_useable[m_outMap[out_ch]] = true;
+  }
+  else
+  {
+    /* figure out what channels we have and can use */
+    for(enum PCMChannels *chan = PCMLayoutMap[m_channelLayout]; *chan != PCM_INVALID; ++chan)
+    {
+      for(out_ch = 0; out_ch < m_outChannels; ++out_ch)
+        if (m_outMap[out_ch] == *chan)
+        {
+          m_useable[*chan] = true;
+          break;
+        }
+    }
+  }
+
+  /* force mono audio to front left and front right */
+  if (!m_ignoreLayout && m_inChannels == 1 && m_inMap[0] == PCM_FRONT_CENTER
+      && m_useable[PCM_FRONT_LEFT] && m_useable[PCM_FRONT_RIGHT])
+  {
+    CLog::Log(LOGDEBUG, "CPCMRemap: Mapping mono audio to front left and front right");
+    m_useable[PCM_FRONT_CENTER] = false;
+    m_useable[PCM_FRONT_LEFT_OF_CENTER] = false;
+    m_useable[PCM_FRONT_RIGHT_OF_CENTER] = false;
+  }
+
+  /* see if our input has side/back channels */
+  for(in_ch = 0; in_ch < m_inChannels; ++in_ch)
+    switch(m_inMap[in_ch])
+    {
+      case PCM_SIDE_LEFT:
+      case PCM_SIDE_RIGHT:
+        hasSide = true;
+        break;
+
+      case PCM_BACK_LEFT:
+      case PCM_BACK_RIGHT:
+        hasBack = true;
+        break;
+
+      default:;
+    }
+
+  /* if our input has side, and not back channels, and our output doesnt have side channels */
+  if (hasSide && !hasBack && (!m_useable[PCM_SIDE_LEFT] || !m_useable[PCM_SIDE_RIGHT]))
+  {
+    CLog::Log(LOGDEBUG, "CPCMRemap: Forcing side channel map to back channels");
+    for(in_ch = 0; in_ch < m_inChannels; ++in_ch)
+           if (m_inMap[in_ch] == PCM_SIDE_LEFT ) m_inMap[in_ch] = PCM_BACK_LEFT;
+      else if (m_inMap[in_ch] == PCM_SIDE_RIGHT) m_inMap[in_ch] = PCM_BACK_RIGHT;
+  }
+
+  /* resolve all the channels */
+  struct PCMMapInfo table[PCM_MAX_CH + 1], *info, *dst;
+  std::vector<enum PCMChannels> path;
+
+  for (int i = 0; i < PCM_MAX_CH + 1; i++)
+  {
+    for (int j = 0; j < PCM_MAX_CH + 1; j++)
+      m_lookupMap[i][j].channel = PCM_INVALID;
+  }
+
+  memset(m_counts, 0, sizeof(m_counts));
+  for(in_ch = 0; in_ch < m_inChannels; ++in_ch) {
+
+    for (int i = 0; i < PCM_MAX_CH + 1; i++)
+      table[i].channel = PCM_INVALID;
+
+    ResolveChannel(m_inMap[in_ch], 1.0f, false, path, table);
+    for(info = table; info->channel != PCM_INVALID; ++info)
+    {
+      /* find the end of the table */
+      for(dst = m_lookupMap[info->channel]; dst->channel != PCM_INVALID; ++dst);
+
+      /* append it to the table and set its input offset */
+      dst->channel   = m_inMap[in_ch];
+      dst->in_offset = in_ch * 2;
+      dst->level     = info->level;
+      m_counts[dst->channel]++;
+    }
+  }
+}
+
+/*
+  builds a lookup table to convert from the input mapping to the output
+  mapping, this decreases the amount of work per sample to remap it.
+*/
+void CPCMRemap::BuildMap()
+{
+  struct PCMMapInfo *dst;
+  unsigned int out_ch;
+
+  if (!m_inSet || !m_outSet) return;
+
+  m_inStride  = m_inSampleSize * m_inChannels ;
+  m_outStride = m_inSampleSize * m_outChannels;
+
+  /* see if we need to normalize the levels */
+  bool dontnormalize = g_guiSettings.GetBool("audiooutput.normalizelevels");
+  CLog::Log(LOGDEBUG, "CPCMRemap: Downmix normalization is %s", (dontnormalize ? "disabled" : "enabled"));
+
+  ResolveChannels();
+
+  /* convert the levels into RMS values */
+  float loudest    = 0.0;
+  bool  hasLoudest = false;
+
+  for(out_ch = 0; out_ch < m_outChannels; ++out_ch)
+  {
+    float scale = 0;
+    int count = 0;
+    for(dst = m_lookupMap[m_outMap[out_ch]]; dst->channel != PCM_INVALID; ++dst)
+    {
+      dst->copy  = false;
+      dst->level = dst->level / sqrt((float)m_counts[dst->channel]);
+      scale     += dst->level;
+      ++count;
+    }
+
+    /* if there is only 1 channel to mix, and the level is 1.0, then just copy the channel */
+    dst = m_lookupMap[m_outMap[out_ch]];
+    if (count == 1 && dst->level > 0.99 && dst->level < 1.01)
+      dst->copy = true;
+
+    /* normalize the levels if it is turned on */
+    if (!dontnormalize)
+      for(dst = m_lookupMap[m_outMap[out_ch]]; dst->channel != PCM_INVALID; ++dst)
+      {
+        dst->level /= scale;
+        /* find the loudest output level we have that is not 1-1 */
+        if (dst->level < 1.0 && loudest < dst->level)
+        {
+          loudest    = dst->level;
+          hasLoudest = true;
+        }
+      }
+  }
+
+  /* adjust the channels that are too loud */
+  for(out_ch = 0; out_ch < m_outChannels; ++out_ch)
+  {
+    CStdString s = "", f;
+    for(dst = m_lookupMap[m_outMap[out_ch]]; dst->channel != PCM_INVALID; ++dst)
+    {
+      if (hasLoudest && dst->copy)
+      {
+        dst->level = loudest;
+        dst->copy  = false;
+      }
+
+      f.Format("%s(%f%s) ",  PCMChannelStr(dst->channel).c_str(), dst->level, dst->copy ? "*" : "");
+      s += f;
+    }
+    CLog::Log(LOGDEBUG, "CPCMRemap: %s = %s\n", PCMChannelStr(m_outMap[out_ch]).c_str(), s.c_str());
+  }
+}
+
+void CPCMRemap::DumpMap(CStdString info, unsigned int channels, enum PCMChannels *channelMap)
+{
+  if (channelMap == NULL)
+  {
+    CLog::Log(LOGINFO, "CPCMRemap: %s channel map: NULL", info.c_str());
+    return;
+  }
+
+  CStdString mapping;
+  for(unsigned int i = 0; i < channels; ++i)
+    mapping += ((i == 0) ? "" : ",") + PCMChannelStr(channelMap[i]);
+
+  CLog::Log(LOGINFO, "CPCMRemap: %s channel map: %s\n", info.c_str(), mapping.c_str());
+}
+
+void CPCMRemap::Reset()
+{
+  m_inSet  = false;
+  m_outSet = false;
+  Dispose();
+}
+
+/* sets the input format, and returns the requested channel layout */
+enum PCMChannels *CPCMRemap::SetInputFormat(unsigned int channels, enum PCMChannels *channelMap, unsigned int sampleSize, unsigned int sampleRate, PCMLayout layout)
+{
+  m_inChannels   = channels;
+  m_inSampleSize = sampleSize;
+  m_sampleRate   = sampleRate;
+  m_inSet        = channelMap != NULL;
+  if (channelMap)
+    memcpy(m_inMap, channelMap, sizeof(enum PCMChannels) * channels);
+
+  /* get the audio layout, and count the channels in it */
+  m_channelLayout  = layout;
+  if (m_channelLayout >= PCM_MAX_LAYOUT) m_channelLayout = PCM_LAYOUT_2_0;
+
+
+  DumpMap("I", channels, channelMap);
+  BuildMap();
+
+  /* now remove the empty channels from PCMLayoutMap;
+   * we don't perform upmixing so we want the minimum amount of those */
+  if (channelMap) {
+    if (!m_outSet)
+      ResolveChannels(); /* Do basic channel resolving to find out the empty channels;
+                          * If m_outSet == true, this was done already by BuildMap() above */
+    int i = 0;
+    for (enum PCMChannels *chan = PCMLayoutMap[m_channelLayout]; *chan != PCM_INVALID; ++chan)
+      if (m_lookupMap[*chan][0].channel != PCM_INVALID) {
+        /* something is mapped here, so add the channel */
+        m_layoutMap[i++] = *chan;
+      }
+    m_layoutMap[i] = PCM_INVALID;
+  } else
+    memcpy(m_layoutMap, PCMLayoutMap[m_channelLayout], sizeof(PCMLayoutMap[m_channelLayout]));
+
+  m_attenuation = 1.0;
+  m_attenuationInc = 1.0;
+  m_holdCounter = 0;
+
+  return m_layoutMap;
+}
+
+/* sets the output format supported by the audio renderer */
+void CPCMRemap::SetOutputFormat(unsigned int channels, enum PCMChannels *channelMap, bool ignoreLayout/* = false */)
+{
+  m_outChannels   = channels;
+  m_outSet        = channelMap != NULL;
+  m_ignoreLayout  = ignoreLayout;
+  if (channelMap)
+    memcpy(m_outMap, channelMap, sizeof(enum PCMChannels) * channels);
+
+  DumpMap("O", channels, channelMap);
+  BuildMap();
+
+  m_attenuation = 1.0;
+  m_attenuationInc = 1.0;
+  m_holdCounter = 0;
+}
+
+#if 0
+void CPCMRemap::Remap(void *data, void *out, unsigned int samples, long drc)
+{
+  float gain = 1.0f;
+  if (drc > 0)
+    gain = pow(10.0f, (float)drc / 2000.0f);
+
+  Remap(data, out, samples, gain);
+}
+
+/* remap the supplied data into out, which must be pre-allocated */
+void CPCMRemap::Remap(void *data, void *out, unsigned int samples, float gain /*= 1.0f*/)
+{
+  CheckBufferSize(samples * m_outChannels * sizeof(float));
+
+  //set output buffer to 0
+  memset(out, 0, samples * m_outChannels * m_inSampleSize);
+
+  //set intermediate buffer to 0
+  memset(m_buf, 0, m_bufsize);
+
+  ProcessInput(data, out, samples, gain);
+  AddGain(m_buf, samples * m_outChannels, gain);
+  ProcessLimiter(samples, gain);
+  ProcessOutput(out, samples, gain);
+}
+
+void CPCMRemap::CheckBufferSize(int size)
+{
+  if (m_bufsize < size)
+  {
+    m_bufsize = size;
+    m_buf = (float*)realloc(m_buf, m_bufsize);
+  }
+}
+
+void CPCMRemap::ProcessInput(void* data, void* out, unsigned int samples, float gain)
+{
+  for (unsigned int ch = 0; ch < m_outChannels; ch++)
+  {
+    struct PCMMapInfo *info = m_lookupMap[m_outMap[ch]];
+    if (info->channel == PCM_INVALID)
+      continue;
+
+    if (info->copy && gain == 1.0f) //do direct copy
+    {
+      uint8_t* src = (uint8_t*)data + info->in_offset;
+      uint8_t* dst = (uint8_t*)out  + ch * m_inSampleSize;
+      uint8_t* dstend = dst + samples * m_outStride;
+      while (dst != dstend)
+      {
+        *(int16_t*)dst = *(int16_t*)src;
+        src += m_inStride;
+        dst += m_outStride;
+      }
+    }
+    else //needs some volume change or mixing, put into intermediate buffer
+    {
+      for(; info->channel != PCM_INVALID; info++)
+      {
+        uint8_t* src = (uint8_t*)data + info->in_offset;
+        float*   dst = m_buf + ch;
+        float*   dstend = dst + samples * m_outChannels;
+        while (dst != dstend)
+        {
+          *dst += (float)(*(int16_t*)src) * info->level;
+          src += m_inStride;
+          dst += m_outChannels;
+        }
+      }
+    }
+  }
+}
+
+void CPCMRemap::AddGain(float* buf, unsigned int samples, float gain)
+{
+  if (gain != 1.0f) //needs a gain change
+  {
+    float* ptr = m_buf;
+    float* end = m_buf + samples;
+    while (ptr != end)
+      *(ptr++) *= gain;
+  }
+}
+
+void CPCMRemap::ProcessLimiter(unsigned int samples, float gain)
+{
+  //check total gain for each output channel
+  float highestgain = 1.0f;
+  for (unsigned int ch = 0; ch < m_outChannels; ch++)
+  {
+    struct PCMMapInfo *info = m_lookupMap[m_outMap[ch]];
+    if (info->channel == PCM_INVALID)
+      continue;
+
+    float chgain = 0.0f;
+    for(; info->channel != PCM_INVALID; info++)
+      chgain += info->level * gain;
+
+    if (chgain > highestgain)
+      highestgain = chgain;
+  }
+
+  m_attenuationMin = 1.0f;
+
+  //if one of the channels can clip, enable a limiter
+  if (highestgain > 1.0001f)
+  {
+    m_attenuationMin = m_attenuation;
+
+    if (!m_limiterEnabled)
+    {
+      CLog::Log(LOGDEBUG, "CPCMRemap:: max gain: %f, enabling limiter", highestgain);
+      m_limiterEnabled = true;
+    }
+
+    for (unsigned int i = 0; i < samples; i++)
+    {
+      //for each collection of samples, get the highest absolute value
+      float maxAbs = 0.0f;
+      for (unsigned int outch = 0; outch < m_outChannels; outch++)
+      {
+        float absval = fabs(m_buf[i * m_outChannels + outch]) / 32768.0f;
+        if (maxAbs < absval)
+          maxAbs = absval;
+      }
+
+      //if attenuatedAbs is higher than 1.0f, audio is clipping
+      float attenuatedAbs = maxAbs * m_attenuation;
+      if (attenuatedAbs > 1.0f)
+      {
+        //set m_attenuation so that m_attenuation * sample is the maximum output value
+        m_attenuation = 1.0f / maxAbs;
+        if (m_attenuation < m_attenuationMin)
+          m_attenuationMin = m_attenuation;
+        //value to add to m_attenuation to make it 1.0f
+        m_attenuationInc = 1.0f - m_attenuation;
+        //amount of samples to hold m_attenuation
+        m_holdCounter = MathUtils::round_int(m_sampleRate * g_advancedSettings.m_limiterHold);
+      }
+      else if (m_attenuation < 1.0f && attenuatedAbs > 0.95f)
+      {
+        //if we're attenuating and we get within 5% of clipping, hold m_attenuation
+        m_attenuationInc = 1.0f - m_attenuation;
+        m_holdCounter = MathUtils::round_int(m_sampleRate * g_advancedSettings.m_limiterHold);
+      }
+
+      //apply attenuation
+      for (unsigned int outch = 0; outch < m_outChannels; outch++)
+        m_buf[i * m_outChannels + outch] *= m_attenuation;
+
+      if (m_holdCounter)
+      {
+        //hold m_attenuation
+        m_holdCounter--;
+      }
+      else if (m_attenuationInc > 0.0f)
+      {
+        //move m_attenuation to 1.0 in g_advancedSettings.m_limiterRelease seconds
+        m_attenuation += m_attenuationInc / m_sampleRate / g_advancedSettings.m_limiterRelease;
+        if (m_attenuation > 1.0f)
+        {
+          m_attenuation = 1.0f;
+          m_attenuationInc = 0.0f;
+        }
+      }
+    }
+  }
+  else
+  {
+    if (m_limiterEnabled)
+    {
+      CLog::Log(LOGDEBUG, "CPCMRemap:: max gain: %f, disabling limiter", highestgain);
+      m_limiterEnabled = false;
+    }
+
+    //reset the limiter
+    m_attenuation = 1.0f;
+    m_attenuationInc = 0.0f;
+    m_holdCounter = 0;
+  }
+}
+
+void CPCMRemap::ProcessOutput(void* out, unsigned int samples, float gain)
+{
+  //copy from intermediate buffer to output
+  for (unsigned int ch = 0; ch < m_outChannels; ch++)
+  {
+    struct PCMMapInfo *info = m_lookupMap[m_outMap[ch]];
+    if (info->channel == PCM_INVALID)
+      continue;
+
+    if (!info->copy || gain != 1.0f)
+    {
+      float* src = m_buf + ch;
+      uint8_t* dst = (uint8_t*)out + ch * m_inSampleSize;
+      uint8_t* dstend = dst + samples * m_outStride;
+
+      while(dst != dstend)
+      {
+        *(int16_t*)dst = MathUtils::round_int(std::min(std::max(*src, (float)INT16_MIN), (float)INT16_MAX));
+        src += m_outChannels;
+        dst += m_outStride;
+      }
+    }
+  }
+}
+
+bool CPCMRemap::CanRemap()
+{
+  return (m_inSet && m_outSet);
+}
+
+int CPCMRemap::InBytesToFrames(int bytes)
+{
+  return bytes / m_inSampleSize / m_inChannels;
+}
+
+int CPCMRemap::FramesToOutBytes(int frames)
+{
+  return frames * m_inSampleSize * m_outChannels;
+}
+
+int CPCMRemap::FramesToInBytes(int frames)
+{
+  return frames * m_inSampleSize * m_inChannels;
+}
+#endif
+CStdString CPCMRemap::PCMChannelStr(enum PCMChannels ename)
+{
+  const char* PCMChannelName[] =
+  {
+    "FL",
+    "FR",
+    "CE",
+    "LFE",
+    "BL",
+    "BR",
+    "FLOC",
+    "FROC",
+    "BC",
+    "SL",
+    "SR",
+    "TFL",
+    "TFR",
+    "TFC",
+    "TC",
+    "TBL",
+    "TBR",
+    "TBC"
+  };
+
+  int namepos = (int)ename;
+  CStdString namestr;
+
+  if (namepos < 0 || namepos >= (int)(sizeof(PCMChannelName) / sizeof(const char*)))
+    namestr.Format("UNKNOWN CHANNEL:%i", namepos);
+  else
+    namestr = PCMChannelName[namepos];
+
+  return namestr;
+}
+#if 0
+CStdString CPCMRemap::PCMLayoutStr(enum PCMLayout ename)
+{
+  const char* PCMLayoutName[] =
+  {
+    "2.0",
+    "2.1",
+    "3.0",
+    "3.1",
+    "4.0",
+    "4.1",
+    "5.0",
+    "5.1",
+    "7.0",
+    "7.1"
+  };
+
+  int namepos = (int)ename;
+  CStdString namestr;
+
+  if (namepos < 0 || namepos >= (int)(sizeof(PCMLayoutName) / sizeof(const char*)))
+    namestr.Format("UNKNOWN LAYOUT:%i", namepos);
+  else
+    namestr = PCMLayoutName[namepos];
+
+  return namestr;
+}
+#endif
+
+
+void CPCMRemap::GetDownmixMatrix(float *downmix)
+{
+  for (int i=0; i<8*8; i++)
+    downmix[i] = 0.0f;
+
+  for (unsigned int ch = 0; ch < m_outChannels; ch++)
+  {
+    struct PCMMapInfo *info = m_lookupMap[m_outMap[ch]];
+    if (info->channel == PCM_INVALID)
+      continue;
+
+    for(; info->channel != PCM_INVALID; info++)
+      downmix[8*ch + (info->in_offset>>1)] = info->level;
+  }
+}
diff --git a/xbmc/cores/omxplayer/PCMRemap.h b/xbmc/cores/omxplayer/PCMRemap.h
new file mode 100644
index 0000000..d60b04c
--- /dev/null
+++ b/xbmc/cores/omxplayer/PCMRemap.h
@@ -0,0 +1,151 @@
+#ifndef __PCM_REMAP__H__
+#define __PCM_REMAP__H__
+
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <stdint.h>
+#include <vector>
+#include "utils/StdString.h"
+
+#define PCM_MAX_CH 18
+enum PCMChannels
+{
+  PCM_INVALID = -1,
+  PCM_FRONT_LEFT,
+  PCM_FRONT_RIGHT,
+  PCM_FRONT_CENTER,
+  PCM_LOW_FREQUENCY,
+  PCM_BACK_LEFT,
+  PCM_BACK_RIGHT,
+  PCM_FRONT_LEFT_OF_CENTER,
+  PCM_FRONT_RIGHT_OF_CENTER,
+  PCM_BACK_CENTER,
+  PCM_SIDE_LEFT,
+  PCM_SIDE_RIGHT,
+  PCM_TOP_FRONT_LEFT,
+  PCM_TOP_FRONT_RIGHT,
+  PCM_TOP_FRONT_CENTER,
+  PCM_TOP_CENTER,
+  PCM_TOP_BACK_LEFT,
+  PCM_TOP_BACK_RIGHT,
+  PCM_TOP_BACK_CENTER
+};
+
+#define PCM_MAX_LAYOUT 10
+enum PCMLayout
+{
+  PCM_LAYOUT_2_0 = 0,
+  PCM_LAYOUT_2_1,
+  PCM_LAYOUT_3_0,
+  PCM_LAYOUT_3_1,
+  PCM_LAYOUT_4_0,
+  PCM_LAYOUT_4_1,
+  PCM_LAYOUT_5_0,
+  PCM_LAYOUT_5_1,
+  PCM_LAYOUT_7_0,
+  PCM_LAYOUT_7_1
+};
+
+struct PCMMapInfo
+{
+  enum  PCMChannels channel;
+  float level;
+  bool  ifExists;
+  int   in_offset;
+  bool  copy;
+};
+
+//!  Channels remapper class
+/*!
+   The usual set-up process:
+   - user calls SetInputFormat with the input channels information
+   - SetInputFormat responds with a channelmap corresponding to the speaker
+     layout that the user has configured, with empty (according to information
+     calculated from the input channelmap) channels removed
+   - user uses this information to create the desired output channelmap,
+     and calls SetOutputFormat to set it (if the channelmap contains channels
+     that do not exist in the configured speaker layout, they will contain
+     only silence unless ignoreLayout is true)
+ */
+
+class CPCMRemap
+{
+protected:
+  bool               m_inSet, m_outSet;
+  enum PCMLayout     m_channelLayout;
+  unsigned int       m_inChannels, m_outChannels;
+  unsigned int       m_inSampleSize;
+  enum PCMChannels   m_inMap [PCM_MAX_CH];
+  enum PCMChannels   m_outMap[PCM_MAX_CH];
+  enum PCMChannels   m_layoutMap[PCM_MAX_CH + 1];
+
+  bool               m_ignoreLayout;
+  bool               m_useable  [PCM_MAX_CH];
+  int                m_inStride, m_outStride;
+  struct PCMMapInfo  m_lookupMap[PCM_MAX_CH + 1][PCM_MAX_CH + 1];
+  int                m_counts[PCM_MAX_CH];
+
+  float*             m_buf;
+  int                m_bufsize;
+  float              m_attenuation;
+  float              m_attenuationInc;
+  float              m_attenuationMin; //lowest attenuation value during a call of Remap(), used for the codec info
+  float              m_sampleRate;
+  unsigned int       m_holdCounter;
+  bool               m_limiterEnabled;
+  bool               m_dontnormalize;
+
+  struct PCMMapInfo* ResolveChannel(enum PCMChannels channel, float level, bool ifExists, std::vector<enum PCMChannels> path, struct PCMMapInfo *tablePtr);
+  void               ResolveChannels(); //!< Partial BuildMap(), just enough to see which output channels are active
+  void               BuildMap();
+  void               DumpMap(CStdString info, int unsigned channels, enum PCMChannels *channelMap);
+  void               Dispose();
+  CStdString         PCMChannelStr(enum PCMChannels ename);
+  CStdString         PCMLayoutStr(enum PCMLayout ename);
+
+  void               CheckBufferSize(int size);
+  void               ProcessInput(void* data, void* out, unsigned int samples, float gain);
+  void               AddGain(float* buf, unsigned int samples, float gain);
+  void               ProcessLimiter(unsigned int samples, float gain);
+  void               ProcessOutput(void* out, unsigned int samples, float gain);
+
+public:
+
+  CPCMRemap();
+  ~CPCMRemap();
+
+  void Reset();
+  enum PCMChannels *SetInputFormat (unsigned int channels, enum PCMChannels *channelMap, unsigned int sampleSize, unsigned int sampleRate, PCMLayout layout);
+  void SetOutputFormat(unsigned int channels, enum PCMChannels *channelMap, bool ignoreLayout = false);
+#if 0
+  void Remap(void *data, void *out, unsigned int samples, long drc);
+  void Remap(void *data, void *out, unsigned int samples, float gain = 1.0f);
+  bool CanRemap();
+  int  InBytesToFrames (int bytes );
+  int  FramesToOutBytes(int frames);
+  int  FramesToInBytes (int frames);
+#endif
+  float GetCurrentAttenuation() { return m_attenuationMin; }
+  void               GetDownmixMatrix(float *downmix);
+};
+
+#endif
diff --git a/xbmc/guilib/DDSImage.cpp b/xbmc/guilib/DDSImage.cpp
index 4f76c58..99f800a 100644
--- a/xbmc/guilib/DDSImage.cpp
+++ b/xbmc/guilib/DDSImage.cpp
@@ -119,6 +119,8 @@ bool CDDSImage::ReadFile(const std::string &inputFile)
 
 bool CDDSImage::Create(const std::string &outputFile, unsigned int width, unsigned int height, unsigned int pitch, unsigned char const *brga, double maxMSE)
 {
+  if (!brga)
+    return false;
   if (!Compress(width, height, pitch, brga, maxMSE))
   { // use ARGB
     Allocate(width, height, XB_FMT_A8R8G8B8);
diff --git a/xbmc/guilib/JpegIO.cpp b/xbmc/guilib/JpegIO.cpp
index f6f2c44..6c4410c 100644
--- a/xbmc/guilib/JpegIO.cpp
+++ b/xbmc/guilib/JpegIO.cpp
@@ -367,8 +367,9 @@ bool CJpegIO::Read(unsigned char* buffer, unsigned int bufSize, unsigned int min
     m_cinfo.scale_denom = 8;
     m_cinfo.out_color_space = JCS_RGB;
     unsigned int maxtexsize = g_Windowing.GetMaxTextureSize();
-    for (m_cinfo.scale_num = 1; m_cinfo.scale_num <= 8; m_cinfo.scale_num++)
+    for (unsigned int scale = 1; scale <= 8; scale++)
     {
+      m_cinfo.scale_num = scale;
       jpeg_calc_output_dimensions(&m_cinfo);
       if ((m_cinfo.output_width > maxtexsize) || (m_cinfo.output_height > maxtexsize))
       {
diff --git a/xbmc/guilib/Texture.cpp b/xbmc/guilib/Texture.cpp
index 120187f..d96beb3 100644
--- a/xbmc/guilib/Texture.cpp
+++ b/xbmc/guilib/Texture.cpp
@@ -36,10 +36,6 @@
 #include "filesystem/AndroidAppFile.h"
 #endif
 
-#if defined(HAS_OMXPLAYER)
-#include "xbmc/cores/omxplayer/OMXImage.h"
-#endif
-
 /************************************************************************/
 /*                                                                      */
 /************************************************************************/
@@ -97,8 +93,13 @@ void CBaseTexture::Allocate(unsigned int width, unsigned int height, unsigned in
   CLAMP(m_textureHeight, g_Windowing.GetMaxTextureSize());
   CLAMP(m_imageWidth, m_textureWidth);
   CLAMP(m_imageHeight, m_textureHeight);
+
   delete[] m_pixels;
-  m_pixels = new unsigned char[GetPitch() * GetRows()];
+  m_pixels = NULL;
+  if (GetPitch() * GetRows() > 0)
+  {
+    m_pixels = new unsigned char[GetPitch() * GetRows()];
+  }
 }
 
 void CBaseTexture::Update(unsigned int width, unsigned int height, unsigned int pitch, unsigned int format, const unsigned char *pixels, bool loadToGPU)
@@ -170,7 +171,7 @@ void CBaseTexture::ClampToEdge()
   }
 }
 
-CBaseTexture *CBaseTexture::LoadFromFile(const CStdString& texturePath, unsigned int idealWidth, unsigned int idealHeight, bool autoRotate)
+CBaseTexture *CBaseTexture::LoadFromFile(const CStdString& texturePath, unsigned int idealWidth, unsigned int idealHeight, bool autoRotate, bool requirePixels)
 {
 #if defined(TARGET_ANDROID)
   CURL url(texturePath);
@@ -198,7 +199,7 @@ CBaseTexture *CBaseTexture::LoadFromFile(const CStdString& texturePath, unsigned
   }
 #endif
   CTexture *texture = new CTexture();
-  if (texture->LoadFromFileInternal(texturePath, idealWidth, idealHeight, autoRotate))
+  if (texture->LoadFromFileInternal(texturePath, idealWidth, idealHeight, autoRotate, requirePixels))
     return texture;
   delete texture;
   return NULL;
@@ -213,75 +214,8 @@ CBaseTexture *CBaseTexture::LoadFromFileInMemory(unsigned char *buffer, size_t b
   return NULL;
 }
 
-bool CBaseTexture::LoadFromFileInternal(const CStdString& texturePath, unsigned int maxWidth, unsigned int maxHeight, bool autoRotate)
+bool CBaseTexture::LoadFromFileInternal(const CStdString& texturePath, unsigned int maxWidth, unsigned int maxHeight, bool autoRotate, bool requirePixels)
 {
-#if defined(HAS_OMXPLAYER)
-  if (URIUtils::GetExtension(texturePath).Equals(".jpg") || 
-      URIUtils::GetExtension(texturePath).Equals(".tbn") 
-      /*|| URIUtils::GetExtension(texturePath).Equals(".png")*/)
-  {
-    COMXImage omx_image;
-
-    if(omx_image.ReadFile(texturePath))
-    {
-      if(omx_image.Decode(maxWidth, maxHeight))
-      {
-        Allocate(omx_image.GetDecodedWidth(), omx_image.GetDecodedHeight(), XB_FMT_A8R8G8B8);
-
-        if(!m_pixels)
-        {
-          CLog::Log(LOGERROR, "Texture manager (OMX) out of memory");
-          omx_image.Close();
-          return false;
-        }
-
-        m_originalWidth  = omx_image.GetOriginalWidth();
-        m_originalHeight = omx_image.GetOriginalHeight();
-
-        m_hasAlpha = omx_image.IsAlpha();
-
-        if (autoRotate && omx_image.GetOrientation())
-          m_orientation = omx_image.GetOrientation() - 1;
-
-        if(m_textureWidth != omx_image.GetDecodedWidth() || m_textureHeight != omx_image.GetDecodedHeight())
-        {
-          unsigned int imagePitch = GetPitch(m_imageWidth);
-          unsigned int imageRows = GetRows(m_imageHeight);
-          unsigned int texturePitch = GetPitch(m_textureWidth);
-
-          unsigned char *src = omx_image.GetDecodedData();
-          unsigned char *dst = m_pixels;
-          for (unsigned int y = 0; y < imageRows; y++)
-          {
-            memcpy(dst, src, imagePitch);
-            src += imagePitch;
-            dst += texturePitch;
-          }
-        }
-        else
-        {
-          if(omx_image.GetDecodedData())
-          {
-            int size = ( ( GetPitch() * GetRows() ) > omx_image.GetDecodedSize() ) ?
-                             omx_image.GetDecodedSize() : ( GetPitch() * GetRows() );
-
-            memcpy(m_pixels, (unsigned char *)omx_image.GetDecodedData(), size);
-          }
-        }
-
-        omx_image.Close();
-
-        return true;
-      }
-      else
-      {
-        omx_image.Close();
-      }
-    }
-    // this limits the sizes of jpegs we failed to decode
-    omx_image.ClampLimits(maxWidth, maxHeight);
-  }
-#endif
   if (URIUtils::GetExtension(texturePath).Equals(".dds"))
   { // special case for DDS images
     CDDSImage image;
diff --git a/xbmc/guilib/Texture.h b/xbmc/guilib/Texture.h
index 73d37ed..e8cf358 100644
--- a/xbmc/guilib/Texture.h
+++ b/xbmc/guilib/Texture.h
@@ -31,6 +31,7 @@ struct COLOR {unsigned char b,g,r,x;};	// Windows GDI expects 4bytes per color
 
 class CTexture;
 class CGLTexture;
+class CPiTexture;
 class CDXTexture;
 struct ImageInfo;
 
@@ -56,7 +57,7 @@ class CBaseTexture
    \return a CBaseTexture pointer to the created texture - NULL if the texture failed to load.
    */
   static CBaseTexture *LoadFromFile(const CStdString& texturePath, unsigned int idealWidth = 0, unsigned int idealHeight = 0,
-                                    bool autoRotate = false);
+                                    bool autoRotate = false, bool requirePixels = false);
 
   /*! \brief Load a texture from a file in memory
    Loads a texture from a file in memory, restricting in size if needed based on maxHeight and maxWidth.
@@ -110,7 +111,7 @@ class CBaseTexture
 protected:
   bool LoadFromFileInMem(unsigned char* buffer, size_t size, const std::string& mimeType,
                          unsigned int maxWidth, unsigned int maxHeight);
-  bool LoadFromFileInternal(const CStdString& texturePath, unsigned int maxWidth, unsigned int maxHeight, bool autoRotate);
+  bool LoadFromFileInternal(const CStdString& texturePath, unsigned int maxWidth, unsigned int maxHeight, bool autoRotate, bool requirePixels);
   void LoadFromImage(ImageInfo &image, bool autoRotate = false);
   // helpers for computation of texture parameters for compressed textures
   unsigned int GetPitch(unsigned int width) const;
@@ -131,7 +132,10 @@ class CBaseTexture
   bool m_hasAlpha;
 };
 
-#if defined(HAS_GL) || defined(HAS_GLES)
+#if defined(HAS_OMXPLAYER)
+#include "TexturePi.h"
+#define CTexture CPiTexture
+#elif defined(HAS_GL) || defined(HAS_GLES)
 #include "TextureGL.h"
 #define CTexture CGLTexture
 #elif defined(HAS_DX)
diff --git a/xbmc/guilib/TextureGL.cpp b/xbmc/guilib/TextureGL.cpp
index 16a3b12..d27efc3 100644
--- a/xbmc/guilib/TextureGL.cpp
+++ b/xbmc/guilib/TextureGL.cpp
@@ -19,7 +19,7 @@
 */
 
 #include "system.h"
-#include "TextureGL.h"
+#include "Texture.h"
 #include "windowing/WindowingFactory.h"
 #include "utils/log.h"
 #include "utils/GLUtils.h"
diff --git a/xbmc/guilib/TextureGL.h b/xbmc/guilib/TextureGL.h
index a0d6d0e..48b761f 100644
--- a/xbmc/guilib/TextureGL.h
+++ b/xbmc/guilib/TextureGL.h
@@ -40,7 +40,7 @@ class CGLTexture : public CBaseTexture
   void LoadToGPU();
   void BindToUnit(unsigned int unit);
 
-private:
+protected:
   GLuint m_texture;
 };
 
diff --git a/xbmc/guilib/TextureManager.cpp b/xbmc/guilib/TextureManager.cpp
index 26c96dc..c0dc4c8 100644
--- a/xbmc/guilib/TextureManager.cpp
+++ b/xbmc/guilib/TextureManager.cpp
@@ -35,10 +35,6 @@
 #include "URL.h"
 #include <assert.h>
 
-/* PLEX */
-#include "plex/PlexUtils.h"
-/* END PLEX */
-
 using namespace std;
 
 
diff --git a/xbmc/guilib/TexturePi.cpp b/xbmc/guilib/TexturePi.cpp
new file mode 100644
index 0000000..62235cc
--- /dev/null
+++ b/xbmc/guilib/TexturePi.cpp
@@ -0,0 +1,154 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#include "Texture.h"
+#include "windowing/WindowingFactory.h"
+#include "utils/log.h"
+#include "utils/GLUtils.h"
+#include "guilib/TextureManager.h"
+#include "utils/URIUtils.h"
+
+#if defined(HAS_OMXPLAYER)
+#include "cores/omxplayer/OMXImage.h"
+
+using namespace std;
+
+/************************************************************************/
+/*    CPiTexture                                                       */
+/************************************************************************/
+
+CPiTexture::CPiTexture(unsigned int width, unsigned int height, unsigned int format)
+: CGLTexture(width, height, format)
+{
+  m_egl_image = NULL;
+}
+
+CPiTexture::~CPiTexture()
+{
+  if (m_egl_image)
+  {
+    g_OMXImage.DestroyTexture(m_egl_image);
+    m_egl_image = NULL;
+  }
+}
+
+void CPiTexture::Allocate(unsigned int width, unsigned int height, unsigned int format)
+{
+  if (m_egl_image)
+  {
+    m_imageWidth = m_originalWidth = width;
+    m_imageHeight = m_originalHeight = height;
+    m_format = format;
+    m_orientation = 0;
+
+    m_textureWidth = m_imageWidth;
+    m_textureHeight = m_imageHeight;
+    return;
+  }
+  return CGLTexture::Allocate(width, height, format);
+}
+
+void CPiTexture::CreateTextureObject()
+{
+  if (m_egl_image && !m_texture)
+  {
+    g_OMXImage.GetTexture(m_egl_image, &m_texture);
+    return;
+  }
+  CGLTexture::CreateTextureObject();
+}
+
+void CPiTexture::LoadToGPU()
+{
+  if (m_egl_image)
+  {
+    if (m_loadedToGPU)
+    {
+      // nothing to load - probably same image (no change)
+      return;
+    }
+    if (m_texture == 0)
+    {
+      // Have OpenGL generate a texture object handle for us
+      // this happens only one time - the first time the texture is loaded
+      CreateTextureObject();
+    }
+
+    // Bind the texture object
+    glBindTexture(GL_TEXTURE_2D, m_texture);
+
+    m_loadedToGPU = true;
+    return;
+  }
+  CGLTexture::LoadToGPU();
+}
+
+void CPiTexture::Update(unsigned int width, unsigned int height, unsigned int pitch, unsigned int format, const unsigned char *pixels, bool loadToGPU)
+{
+  if (m_egl_image)
+  {
+    if (loadToGPU)
+      LoadToGPU();
+    return;
+  }
+  CGLTexture::Update(width, height, pitch, format, pixels, loadToGPU);
+}
+
+bool CPiTexture::LoadFromFileInternal(const CStdString& texturePath, unsigned int maxWidth, unsigned int maxHeight, bool autoRotate, bool requirePixels)
+{
+  if (URIUtils::GetExtension(texturePath).Equals(".jpg") || URIUtils::GetExtension(texturePath).Equals(".tbn"))
+  {
+    COMXImageFile *file = g_OMXImage.LoadJpeg(texturePath);
+    if (file)
+    {
+      bool okay = false;
+      int orientation = file->GetOrientation();
+      // limit the sizes of jpegs (even if we fail to decode)
+      g_OMXImage.ClampLimits(maxWidth, maxHeight, file->GetWidth(), file->GetHeight(), orientation & 4);
+
+      if (requirePixels)
+      {
+        Allocate(maxWidth, maxHeight, XB_FMT_A8R8G8B8);
+        if (m_pixels && COMXImage::DecodeJpeg(file, maxWidth, GetRows(), GetPitch(), (void *)m_pixels))
+          okay = true;
+      }
+      else
+      {
+        if (g_OMXImage.DecodeJpegToTexture(file, maxWidth, maxHeight, &m_egl_image) && m_egl_image)
+        {
+          Allocate(maxWidth, maxHeight, XB_FMT_A8R8G8B8);
+          okay = true;
+        }
+      }
+      g_OMXImage.CloseJpeg(file);
+      if (okay)
+      {
+        m_hasAlpha = false;
+        if (autoRotate && orientation)
+          m_orientation = orientation - 1;
+        return true;
+      }
+    }
+  }
+  return CGLTexture::LoadFromFileInternal(texturePath, maxWidth, maxHeight, autoRotate, requirePixels);
+}
+
+#endif
diff --git a/xbmc/guilib/TexturePi.h b/xbmc/guilib/TexturePi.h
new file mode 100644
index 0000000..47095b9
--- /dev/null
+++ b/xbmc/guilib/TexturePi.h
@@ -0,0 +1,49 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "TextureGL.h"
+
+#if defined(HAS_OMXPLAYER)
+
+#include "system_gl.h"
+
+/************************************************************************/
+/*    CGLTexture                                                       */
+/************************************************************************/
+class CPiTexture : public CGLTexture
+{
+public:
+  CPiTexture(unsigned int width = 0, unsigned int height = 0, unsigned int format = XB_FMT_A8R8G8B8);
+  virtual ~CPiTexture();
+  void CreateTextureObject();
+  void LoadToGPU();
+  void Update(unsigned int width, unsigned int height, unsigned int pitch, unsigned int format, const unsigned char *pixels, bool loadToGPU);
+  void Allocate(unsigned int width, unsigned int height, unsigned int format);
+  bool LoadFromFileInternal(const CStdString& texturePath, unsigned int maxWidth, unsigned int maxHeight, bool autoRotate, bool requirePixels);
+
+protected:
+
+private:
+  void *m_egl_image;
+};
+
+#endif
diff --git a/xbmc/linux/OMXClock.cpp b/xbmc/linux/OMXClock.cpp
index 199c23d..74607d2 100644
--- a/xbmc/linux/OMXClock.cpp
+++ b/xbmc/linux/OMXClock.cpp
@@ -32,37 +32,19 @@
 #include "OMXClock.h"
 #include "utils/MathUtils.h"
 
-int64_t OMXClock::m_systemOffset;
-int64_t OMXClock::m_systemFrequency;
-bool    OMXClock::m_ismasterclock;
-
-#define OMX_PRE_ROLL 800
+#define OMX_PRE_ROLL 200
+#define TP(speed) ((speed) < 0 || (speed) > 4*DVD_PLAYSPEED_NORMAL)
 
 OMXClock::OMXClock()
 {
-  m_has_video   = false;
-  m_has_audio   = false;
-  m_video_start = false;
-  m_audio_start = false;
   m_pause       = false;
 
-  m_systemOffset = 0;
-  m_systemFrequency = 0;
-  m_startClock = 0;
-
-  CheckSystemClock();
-
-  m_systemUsed = m_systemFrequency;
-  m_pauseClock = 0;
-  m_bReset = true;
-  m_iDisc = 0;
-  m_maxspeedadjust = 0.0;
-  m_speedadjust = false;
-  m_ismasterclock = true;
-  m_ClockOffset = 0;
   m_fps = 25.0f;
   m_omx_speed = DVD_PLAYSPEED_NORMAL;
-  m_audio_buffer = false;
+  m_WaitMask = 0;
+  m_eState = OMX_TIME_ClockStateStopped;
+  m_eClock = OMX_TIME_RefClockNone;
+  m_clock        = NULL;
 
   pthread_mutex_init(&m_lock, NULL);
 }
@@ -83,201 +65,7 @@ void OMXClock::UnLock()
   pthread_mutex_unlock(&m_lock);
 }
 
-double OMXClock::GetAbsoluteClock(bool interpolated /*= true*/)
-{
-  Lock();
-  CheckSystemClock();
-
-  int64_t current;
-  current = g_VideoReferenceClock.GetTime(interpolated);
-
-  UnLock();
-  return SystemToAbsolute(current);
-}
-
-double OMXClock::WaitAbsoluteClock(double target)
-{
-  Lock();
-  CheckSystemClock();
-
-  int64_t systemtarget, freq, offset;
-  freq   = m_systemFrequency;
-  offset = m_systemOffset;
-  UnLock();
-
-  systemtarget = (int64_t)(target / DVD_TIME_BASE * (double)freq);
-  systemtarget += offset;
-  systemtarget = g_VideoReferenceClock.Wait(systemtarget);
-  systemtarget -= offset;
-  return (double)systemtarget / freq * DVD_TIME_BASE;
-}
-
-// Returns the current absolute clock in units of DVD_TIME_BASE (usually microseconds).
-void OMXClock::CheckSystemClock()
-{
-  if(!m_systemFrequency)
-    m_systemFrequency = g_VideoReferenceClock.GetFrequency();
-
-  if(!m_systemOffset)
-    m_systemOffset = g_VideoReferenceClock.GetTime();
-}
-
-double OMXClock::GetClock(bool interpolated /*= true*/)
-{
-  Lock();
-  double clock = SystemToPlaying(g_VideoReferenceClock.GetTime(interpolated));
-  UnLock();
-  return clock;
-}
-
-double OMXClock::GetClock(double& absolute, bool interpolated /*= true*/)
-{
-  int64_t current = g_VideoReferenceClock.GetTime(interpolated);
-
-  Lock();
-  CheckSystemClock();
-  absolute = SystemToAbsolute(current);
-  current = SystemToPlaying(current);
-  UnLock();
-
-  return current;
-}
-
-void OMXClock::SetSpeed(int iSpeed)
-{
-  // this will sometimes be a little bit of due to rounding errors, ie clock might jump abit when changing speed
-  Lock();
-
-  if(iSpeed == DVD_PLAYSPEED_PAUSE)
-  {
-    if(!m_pauseClock)
-      m_pauseClock = g_VideoReferenceClock.GetTime();
-    UnLock();
-    return;
-  }
-
-  int64_t current;
-  int64_t newfreq = m_systemFrequency * DVD_PLAYSPEED_NORMAL / iSpeed;
-
-  current = g_VideoReferenceClock.GetTime();
-  if( m_pauseClock )
-  {
-    m_startClock += current - m_pauseClock;
-    m_pauseClock = 0;
-  }
-
-  m_startClock = current - (int64_t)((double)(current - m_startClock) * newfreq / m_systemUsed);
-  m_systemUsed = newfreq;
-  UnLock();
-}
-
-void OMXClock::Discontinuity(double currentPts)
-{
-  Lock();
-  m_startClock = g_VideoReferenceClock.GetTime();
-  if(m_pauseClock)
-    m_pauseClock = m_startClock;
-  m_iDisc = currentPts;
-  m_bReset = false;
-  UnLock();
-}
-
-void OMXClock::Pause()
-{
-  Lock();
-  if(!m_pauseClock)
-    m_pauseClock = g_VideoReferenceClock.GetTime();
-  UnLock();
-}
-
-void OMXClock::Resume()
-{
-  Lock();
-  if( m_pauseClock )
-  {
-    int64_t current;
-    current = g_VideoReferenceClock.GetTime();
-
-    m_startClock += current - m_pauseClock;
-    m_pauseClock = 0;
-  }
-  UnLock();
-}
-
-bool OMXClock::SetMaxSpeedAdjust(double speed)
-{
-  Lock();
-  m_maxspeedadjust = speed;
-  UnLock();
-  return m_speedadjust;
-}
-
-//returns the refreshrate if the videoreferenceclock is running, -1 otherwise
-int OMXClock::UpdateFramerate(double fps, double* interval /*= NULL*/)
-{
-  //sent with fps of 0 means we are not playing video
-  if(fps == 0.0)
-  {
-    Lock();
-    m_speedadjust = false;
-    UnLock();
-    return -1;
-  }
-
-  //check if the videoreferenceclock is running, will return -1 if not
-  int rate = g_VideoReferenceClock.GetRefreshRate(interval);
-
-  if (rate <= 0)
-    return -1;
-
-  Lock();
-
-  m_speedadjust = true;
-
-  double weight = (double)rate / (double)MathUtils::round_int(fps);
-
-  //set the speed of the videoreferenceclock based on fps, refreshrate and maximum speed adjust set by user
-  if (m_maxspeedadjust > 0.05)
-  {
-    if (weight / MathUtils::round_int(weight) < 1.0 + m_maxspeedadjust / 100.0
-    &&  weight / MathUtils::round_int(weight) > 1.0 - m_maxspeedadjust / 100.0)
-      weight = MathUtils::round_int(weight);
-  }
-  double speed = (double)rate / (fps * weight);
-  UnLock();
-
-  g_VideoReferenceClock.SetSpeed(speed);
-
-  return rate;
-}
-
-double OMXClock::SystemToAbsolute(int64_t system)
-{
-  return DVD_TIME_BASE * (double)(system - m_systemOffset) / m_systemFrequency;
-}
-
-double OMXClock::SystemToPlaying(int64_t system)
-{
-  int64_t current;
-
-  if (m_bReset)
-  {
-    m_startClock = system;
-    m_systemUsed = m_systemFrequency;
-    m_pauseClock = 0;
-    m_iDisc = 0;
-    m_bReset = false;
-  }
-
-  if (m_pauseClock)
-    current = m_pauseClock;
-  else
-    current = system;
-
-  return DVD_TIME_BASE * (double)(current - m_startClock) / m_systemUsed + m_iDisc;
-}
-
-void OMXClock::OMXSetClockPorts(OMX_TIME_CONFIG_CLOCKSTATETYPE *clock)
+void OMXClock::OMXSetClockPorts(OMX_TIME_CONFIG_CLOCKSTATETYPE *clock, bool has_video, bool has_audio)
 {
   if(m_omx_clock.GetComponent() == NULL)
     return;
@@ -287,28 +75,18 @@ void OMXClock::OMXSetClockPorts(OMX_TIME_CONFIG_CLOCKSTATETYPE *clock)
 
   clock->nWaitMask = 0;
 
-  if(m_has_audio)
+  if(has_audio)
   {
-    m_audio_start = true;
     clock->nWaitMask |= OMX_CLOCKPORT0;
   }
-  else
-  {
-    m_audio_start = false;
-  }
 
-  if(m_has_video)
+  if(has_video)
   {
-    m_video_start = true;
     clock->nWaitMask |= OMX_CLOCKPORT1;
   }
-  else
-  {
-    m_video_start = false;
-  }
 }
 
-bool OMXClock::OMXSetReferenceClock(bool lock /* = true */)
+bool OMXClock::OMXSetReferenceClock(bool has_audio, bool lock /* = true */)
 {
   if(lock)
     Lock();
@@ -318,62 +96,41 @@ bool OMXClock::OMXSetReferenceClock(bool lock /* = true */)
   OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE refClock;
   OMX_INIT_STRUCTURE(refClock);
 
-  if(g_guiSettings.GetBool("videoplayer.usedisplayasclock") && m_has_video)
-    refClock.eClock = OMX_TIME_RefClockVideo;
-  else if(m_has_audio)
+  if(has_audio)
     refClock.eClock = OMX_TIME_RefClockAudio;
   else
     refClock.eClock = OMX_TIME_RefClockVideo;
 
-  CLog::Log(LOGNOTICE, "OMXClock using %s as reference\n", refClock.eClock == OMX_TIME_RefClockVideo ? "video" : "audio");
-
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeActiveRefClock, &refClock);
-  if(omx_err != OMX_ErrorNone)
+  if (refClock.eClock != m_eClock)
   {
-    CLog::Log(LOGERROR, "OMXClock::OMXSetReferenceClock error setting OMX_IndexConfigTimeActiveRefClock\n");
-    ret = false;
-  }
+    CLog::Log(LOGNOTICE, "OMXClock using %s as reference", refClock.eClock == OMX_TIME_RefClockVideo ? "video" : "audio");
 
+    omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeActiveRefClock, &refClock);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "OMXClock::OMXSetReferenceClock error setting OMX_IndexConfigTimeActiveRefClock");
+      ret = false;
+    }
+    m_eClock = refClock.eClock;
+  }
   if(lock)
     UnLock();
 
   return ret;
 }
 
-bool OMXClock::OMXInitialize(bool has_video, bool has_audio)
+bool OMXClock::OMXInitialize(CDVDClock *clock)
 {
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   std::string componentName = "";
 
-  m_has_video = has_video;
-  m_has_audio = has_audio;
-
-  m_video_start = false;
-  m_audio_start = false;
   m_pause       = false;
-  m_audio_buffer = false;
+
+  m_clock = clock;
 
   componentName = "OMX.broadcom.clock";
   if(!m_omx_clock.Initialize((const std::string)componentName, OMX_IndexParamOtherInit))
     return false;
 
-  m_omx_clock.DisableAllPorts();
-
-  /*
-  if(!OMXSetReferenceClock(false))
-    return false;
-
-  OMX_TIME_CONFIG_CLOCKSTATETYPE clock;
-  OMX_INIT_STRUCTURE(clock);
-
-  clock.eState    = OMX_TIME_ClockStateWaitingForStartTime;
-  clock.nOffset   = ToOMXTime(-1000LL * OMX_PRE_ROLL);
-
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeClockState, &clock);
-  if(omx_err != OMX_ErrorNone)
-    CLog::Log(LOGWARNING, "OMXClock::OMXInitialize setting OMX_IndexConfigTimeClockState\n");
-  */
-
   return true;
 }
 
@@ -387,33 +144,6 @@ void OMXClock::OMXDeinitialize()
   m_omx_speed = DVD_PLAYSPEED_NORMAL;
 }
 
-bool OMXClock::OMXStatePause(bool lock /* = true */)
-{
-  if(m_omx_clock.GetComponent() == NULL)
-    return false;
-
-  if(lock)
-    Lock();
-
-  if(m_omx_clock.GetState() != OMX_StatePause)
-  {
-    OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-    omx_err = m_omx_clock.SetStateForComponent(OMX_StatePause);
-    if (omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "OMXClock::StatePause m_omx_clock.SetStateForComponent\n");
-      if(lock)
-        UnLock();
-      return false;
-    }
-  }
-
-  if(lock)
-    UnLock();
-
-  return true;
-}
-
 bool OMXClock::OMXStateExecute(bool lock /* = true */)
 {
   if(m_omx_clock.GetComponent() == NULL)
@@ -439,44 +169,6 @@ bool OMXClock::OMXStateExecute(bool lock /* = true */)
     }
   }
 
-  /*
-  if(m_has_audio)
-  {
-    omx_err = m_omx_clock.EnablePort(m_omx_clock.GetInputPort(), true);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "OMXClock::StateExecute - Error enable port %d on component %s omx_err(0x%08x)", 
-            m_omx_clock.GetInputPort(), m_omx_clock.GetName().c_str(), (int)omx_err);
-    }
-  }
-
-  if(m_has_video)
-  {
-    omx_err = m_omx_clock.EnablePort(m_omx_clock.GetInputPort() + 1, true);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "OMXClock::StateExecute - Error enable port %d on component %s omx_err(0x%08x)", 
-            m_omx_clock.GetInputPort(), m_omx_clock.GetName().c_str(), (int)omx_err);
-    }
-  }
-
-  OMX_TIME_CONFIG_CLOCKSTATETYPE clock;
-  OMX_INIT_STRUCTURE(clock);
-
-  clock.eState      = OMX_TIME_ClockStateWaitingForStartTime;
-  clock.nStartTime  = ToOMXTime(0LL);
-  clock.nOffset     = ToOMXTime(-1000LL * OMX_PRE_ROLL);
-  clock.nWaitMask   = 0;
-
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeClockState, &clock);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "OMXClock::OMXStateExecute error setting OMX_IndexConfigTimeClockState\n");
-  }
-  */
-
-  //OMXStart(lock);
-
   if(lock)
     UnLock();
 
@@ -491,9 +183,6 @@ void OMXClock::OMXStateIdle(bool lock /* = true */)
   if(lock)
     Lock();
 
-  if(m_omx_clock.GetState() == OMX_StateExecuting)
-    m_omx_clock.SetStateForComponent(OMX_StatePause);
-
   if(m_omx_clock.GetState() != OMX_StateIdle)
     m_omx_clock.SetStateForComponent(OMX_StateIdle);
 
@@ -506,43 +195,6 @@ COMXCoreComponent *OMXClock::GetOMXClock()
   return &m_omx_clock;
 }
 
-void OMXClock::OMXSaveState(bool lock /* = true */)
-{
-  if(m_omx_clock.GetComponent() == NULL)
-    return;
-
-  if(lock)
-    Lock();
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_INIT_STRUCTURE(m_clock_state);
-
-  omx_err = m_omx_clock.GetConfig(OMX_IndexConfigTimeClockState, &m_clock_state);
-  if(omx_err != OMX_ErrorNone)
-    CLog::Log(LOGERROR, "OMXClock::SaveState error geting OMX_IndexConfigTimeClockState\n");
-
-  if(lock)
-    UnLock();
-}
-
-void OMXClock::OMXRestoreState(bool lock /* = true */)
-{
-  if(m_omx_clock.GetComponent() == NULL)
-    return;
-
-  if(lock)
-    Lock();
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeClockState, &m_clock_state);
-  if(omx_err != OMX_ErrorNone)
-    CLog::Log(LOGERROR, "OMXClock::RestoreState error setting OMX_IndexConfigTimeClockState\n");
-
-  if(lock)
-    UnLock();
-}
-
 bool  OMXClock::OMXStop(bool lock /* = true */)
 {
   if(m_omx_clock.GetComponent() == NULL)
@@ -568,6 +220,7 @@ bool  OMXClock::OMXStop(bool lock /* = true */)
       UnLock();
     return false;
   }
+  m_eState = clock.eState;
 
   if(lock)
     UnLock();
@@ -575,27 +228,25 @@ bool  OMXClock::OMXStop(bool lock /* = true */)
   return true;
 }
 
-bool OMXClock::OMXStart(bool lock /* = true */)
+bool OMXClock::OMXStep(int steps /* = 1 */, bool lock /* = true */)
 {
   if(m_omx_clock.GetComponent() == NULL)
     return false;
-  
+
   if(lock)
     Lock();
 
-  CLog::Log(LOGDEBUG, "OMXClock::OMXStart\n");
-
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_TIME_CONFIG_CLOCKSTATETYPE clock;
-  OMX_INIT_STRUCTURE(clock);
+  OMX_PARAM_U32TYPE param;
+  OMX_INIT_STRUCTURE(param);
 
-  clock.eState      = OMX_TIME_ClockStateRunning;
-  clock.nOffset     = ToOMXTime(-1000LL * OMX_PRE_ROLL);
+  param.nPortIndex = OMX_ALL;
+  param.nU32 = steps;
 
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeClockState, &clock);
+  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigSingleStep, &param);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "OMXClock::Start error setting OMX_IndexConfigTimeClockState\n");
+    CLog::Log(LOGERROR, "OMXClock::Error setting OMX_IndexConfigSingleStep\n");
     if(lock)
       UnLock();
     return false;
@@ -604,24 +255,11 @@ bool OMXClock::OMXStart(bool lock /* = true */)
   if(lock)
     UnLock();
 
+  CLog::Log(LOGDEBUG, "OMXClock::Step (%d)", steps);
   return true;
 }
 
-void OMXClock::VideoStart(bool video_start)
-{ 
-  Lock();
-  m_video_start = video_start; 
-  UnLock();
-};
-
-void OMXClock::AudioStart(bool audio_start) 
-{ 
-  Lock();
-  m_audio_start = audio_start; 
-  UnLock();
-};
-
-bool OMXClock::OMXReset(bool lock /* = true */)
+bool OMXClock::OMXReset(bool has_video, bool has_audio, bool lock /* = true */)
 {
   if(m_omx_clock.GetComponent() == NULL)
     return false;
@@ -629,56 +267,48 @@ bool OMXClock::OMXReset(bool lock /* = true */)
   if(lock)
     Lock();
 
-  m_audio_buffer = false;
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-
-  if(!OMXSetReferenceClock(false))
+  if(!OMXSetReferenceClock(has_audio, false))
   {
     if(lock)
       UnLock();
     return false;
   }
 
-  OMX_TIME_CONFIG_CLOCKSTATETYPE clock;
-  OMX_INIT_STRUCTURE(clock);
-
-  omx_err = m_omx_clock.GetConfig(OMX_IndexConfigTimeClockState, &clock);
-  if(omx_err != OMX_ErrorNone)
+  if (m_eState == OMX_TIME_ClockStateStopped)
   {
-    CLog::Log(LOGERROR, "OMXClock::OMXReset error getting OMX_IndexConfigTimeClockState\n");
-    if(lock)
-      UnLock();
-    return false;
-  }
+    OMX_TIME_CONFIG_CLOCKSTATETYPE clock;
+    OMX_INIT_STRUCTURE(clock);
 
-  clock.eState    = OMX_TIME_ClockStateWaitingForStartTime;
-  clock.nOffset   = ToOMXTime(-1000LL * OMX_PRE_ROLL);
+    clock.eState    = OMX_TIME_ClockStateWaitingForStartTime;
+    clock.nOffset   = ToOMXTime(-1000LL * OMX_PRE_ROLL);
 
-  OMXSetClockPorts(&clock);
+    OMXSetClockPorts(&clock, has_video, has_audio);
 
-  if(clock.nWaitMask)
-  {
-    omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeClockState, &clock);
-    if(omx_err != OMX_ErrorNone)
+    if(clock.nWaitMask)
     {
-      CLog::Log(LOGERROR, "OMXClock::OMXReset error setting OMX_IndexConfigTimeClockState\n");
-      if(lock)
-        UnLock();
-      return false;
+      OMX_ERRORTYPE omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeClockState, &clock);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "OMXClock::OMXReset error setting OMX_IndexConfigTimeClockState\n");
+        if(lock)
+          UnLock();
+        return false;
+      }
+      CLog::Log(LOGDEBUG, "OMXClock::OMXReset audio / video : %d / %d wait mask %d->%d state : %d->%d\n",
+          has_audio, has_video, m_WaitMask, clock.nWaitMask, m_eState, clock.eState);
+      if (m_eState != OMX_TIME_ClockStateStopped)
+        m_WaitMask = clock.nWaitMask;
+      m_eState = clock.eState;
     }
   }
 
-  CLog::Log(LOGDEBUG, "OMXClock::OMXReset audio / video : %d / %d start audio / video : %d / %d wait mask %d\n", 
-      m_has_audio, m_has_video, m_audio_start, m_video_start, clock.nWaitMask);
-
   if(lock)
     UnLock();
 
   return true;
 }
 
-double OMXClock::OMXWallTime(bool lock /* = true */)
+double OMXClock::OMXMediaTime(bool lock /* = true */)
 {
   if(m_omx_clock.GetComponent() == NULL)
     return 0;
@@ -693,10 +323,10 @@ double OMXClock::OMXWallTime(bool lock /* = true */)
   OMX_INIT_STRUCTURE(timeStamp);
   timeStamp.nPortIndex = m_omx_clock.GetInputPort();
 
-  omx_err = m_omx_clock.GetConfig(OMX_IndexConfigTimeCurrentWallTime, &timeStamp);
+  omx_err = m_omx_clock.GetConfig(OMX_IndexConfigTimeCurrentMediaTime, &timeStamp);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "OMXClock::WallTime error getting OMX_IndexConfigTimeCurrentWallTime\n");
+    CLog::Log(LOGERROR, "OMXClock::MediaTime error getting OMX_IndexConfigTimeCurrentMediaTime\n");
     if(lock)
       UnLock();
     return 0;
@@ -710,7 +340,7 @@ double OMXClock::OMXWallTime(bool lock /* = true */)
   return pts;
 }
 
-double OMXClock::OMXMediaTime(bool fixPreroll /* true */ , bool lock /* = true */)
+double OMXClock::OMXClockAdjustment(bool lock /* = true */)
 {
   if(m_omx_clock.GetComponent() == NULL)
     return 0;
@@ -725,29 +355,27 @@ double OMXClock::OMXMediaTime(bool fixPreroll /* true */ , bool lock /* = true *
   OMX_INIT_STRUCTURE(timeStamp);
   timeStamp.nPortIndex = m_omx_clock.GetInputPort();
 
-  omx_err = m_omx_clock.GetConfig(OMX_IndexConfigTimeCurrentMediaTime, &timeStamp);
+  omx_err = m_omx_clock.GetConfig(OMX_IndexConfigClockAdjustment, &timeStamp);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "OMXClock::MediaTime error getting OMX_IndexConfigTimeCurrentMediaTime\n");
+    CLog::Log(LOGERROR, "OMXClock::MediaTime error getting OMX_IndexConfigClockAdjustment\n");
     if(lock)
       UnLock();
     return 0;
   }
 
-  pts = FromOMXTime(timeStamp.nTimestamp);
-
-  if(fixPreroll)
-    pts += (OMX_PRE_ROLL * 1000);
-
+  pts = (double)FromOMXTime(timeStamp.nTimestamp);
+  //CLog::Log(LOGINFO, "OMXClock::ClockAdjustment %.0f %.0f\n", (double)FromOMXTime(timeStamp.nTimestamp), pts);
   if(lock)
     UnLock();
-  
+
   return pts;
 }
 
+
 // Set the media time, so calls to get media time use the updated value,
 // useful after a seek so mediatime is updated immediately (rather than waiting for first decoded packet)
-bool OMXClock::OMXMediaTime(double pts, bool fixPreroll /* = true*/, bool lock /* = true*/)
+bool OMXClock::OMXMediaTime(double pts, bool lock /* = true*/)
 {
   if(m_omx_clock.GetComponent() == NULL)
     return false;
@@ -761,15 +389,11 @@ bool OMXClock::OMXMediaTime(double pts, bool fixPreroll /* = true*/, bool lock /
   OMX_INIT_STRUCTURE(timeStamp);
   timeStamp.nPortIndex = m_omx_clock.GetInputPort();
 
-  if(g_guiSettings.GetBool("videoplayer.usedisplayasclock") && m_has_video)
-    index = OMX_IndexConfigTimeCurrentVideoReference;
-  else if(m_has_audio)
+  if(m_eClock == OMX_TIME_RefClockAudio)
     index = OMX_IndexConfigTimeCurrentAudioReference;
   else
     index = OMX_IndexConfigTimeCurrentVideoReference;
 
-  if(fixPreroll)
-    pts -= (OMX_PRE_ROLL * 1000);
   timeStamp.nTimestamp = ToOMXTime(pts);
 
   omx_err = m_omx_clock.SetConfig(index, &timeStamp);
@@ -791,230 +415,75 @@ bool OMXClock::OMXMediaTime(double pts, bool fixPreroll /* = true*/, bool lock /
   return true;
 }
 
-// gets count of late frames, indicating underrun has occurred
-int OMXClock::OMXLateCount(int port /* true */ , bool lock /* = true */)
-{
-  if(m_omx_clock.GetComponent() == NULL)
-    return 0;
-
-  if(lock)
-    Lock();
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-
-  OMX_PARAM_U32TYPE late;
-  OMX_INIT_STRUCTURE(late);
-  late.nPortIndex = m_omx_clock.GetInputPort()+port;
-
-  omx_err = m_omx_clock.GetConfig(OMX_IndexConfigBrcmClockMissCount, &late);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "OMXClock::OMXLateCount error getting OMX_IndexConfigBrcmClockMissCount(%d)\n", port);
-    if(lock)
-      UnLock();
-    return 0;
-  }
-
-  //CLog::Log(LOGINFO, "OMXClock::OMXLateCount(%d)=%d", port, late.nU32);
-
-  if(lock)
-    UnLock();
-
-  return late.nU32;
-}
-
 bool OMXClock::OMXPause(bool lock /* = true */)
 {
   if(m_omx_clock.GetComponent() == NULL)
     return false;
 
-  if(lock)
-    Lock();
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_TIME_CONFIG_SCALETYPE scaleType;
-  OMX_INIT_STRUCTURE(scaleType);
-
-  scaleType.xScale = 0; // pause
-
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeScale, &scaleType);
-  if(omx_err != OMX_ErrorNone)
+  if(!m_pause)
   {
-    CLog::Log(LOGERROR, "OMXClock::Pause error setting OMX_IndexConfigTimeClockState\n");
     if(lock)
-      UnLock();
-    return false;
-  }
-
-  CLog::Log(LOGDEBUG, "OMXClock::OMXPause\n");
-
-  m_pause = true;
-
-  if(lock)
-    UnLock();
-
-  return true;
-}
-
-bool OMXClock::OMXResume(bool lock /* = true */)
-{
-  if(m_omx_clock.GetComponent() == NULL)
-    return false;
-
-  if(lock)
-    Lock();
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_TIME_CONFIG_SCALETYPE scaleType;
-  OMX_INIT_STRUCTURE(scaleType);
+      Lock();
 
-  scaleType.xScale = ((m_omx_speed / DVD_PLAYSPEED_NORMAL) << 16);
+    if (OMXSetSpeed(0, false, true))
+      m_pause = true;
 
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeScale, &scaleType);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "OMXClock::Resume error setting OMX_IndexConfigTimeClockState\n");
     if(lock)
       UnLock();
-    return false;
   }
-
-  m_pause = false;
-
-  CLog::Log(LOGDEBUG, "OMXClock::OMXResume\n");
-
-  if(lock)
-    UnLock();
-
-  return true;
+  return m_pause == true;
 }
 
-bool OMXClock::OMXUpdateClock(double pts, bool lock /* = true */)
+bool OMXClock::OMXResume(bool lock /* = true */)
 {
   if(m_omx_clock.GetComponent() == NULL)
     return false;
 
-  if(lock)
-    Lock();
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_TIME_CONFIG_TIMESTAMPTYPE ts;
-  OMX_INIT_STRUCTURE(ts);
-
-  ts.nPortIndex = OMX_ALL;
-  ts.nTimestamp = ToOMXTime((uint64_t)pts);
-
-  CLog::Log(LOGDEBUG, "OMXClock::OMXUpdateClock %f", pts / DVD_TIME_BASE);
-
-  if(m_has_audio)
+  if(m_pause)
   {
-    omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeCurrentAudioReference, &ts);
-    if(omx_err != OMX_ErrorNone)
-      CLog::Log(LOGERROR, "OMXClock::OMXUpdateClock error setting OMX_IndexConfigTimeCurrentAudioReference\n");
-  }
-  else
-  {
-    omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeCurrentVideoReference, &ts);
-    if(omx_err != OMX_ErrorNone)
-      CLog::Log(LOGERROR, "OMXClock::OMXUpdateClock error setting OMX_IndexConfigTimeCurrentVideoReference\n");
-  }
-
-  if(lock)
-    UnLock();
-
-  return true;
-}
-
-bool OMXClock::OMXWaitStart(double pts, bool lock /* = true */)
-{
-  if(m_omx_clock.GetComponent() == NULL)
-    return false;
-
-  if(lock)
-    Lock();
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_TIME_CONFIG_CLOCKSTATETYPE clock;
-  OMX_INIT_STRUCTURE(clock);
+    if(lock)
+      Lock();
 
-  clock.eState    = OMX_TIME_ClockStateWaitingForStartTime;
-  clock.nOffset   = ToOMXTime(-1000LL * OMX_PRE_ROLL);
-  OMXSetClockPorts(&clock);
-  clock.nStartTime  = ToOMXTime((uint64_t)pts);
+    if (OMXSetSpeed(m_omx_speed, false, true))
+      m_pause = false;
 
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeClockState, &clock);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "OMXClock::OMXWaitStart error setting OMX_IndexConfigTimeClockState\n");
     if(lock)
       UnLock();
-    return false;
   }
-
-  if(lock)
-    UnLock();
-
-  return true;
+  return m_pause == false;
 }
 
-void OMXClock::OMXHandleBackward(bool lock /* = true */)
+bool OMXClock::OMXSetSpeed(int speed, bool lock /* = true */, bool pause_resume /* = false */)
 {
-  /*
   if(m_omx_clock.GetComponent() == NULL)
-    return;
+    return false;
 
   if(lock)
     Lock();
 
-  if(m_omx_speed < 0)
+  CLog::Log(LOGDEBUG, "OMXClock::OMXSetSpeed(%.2f) pause_resume:%d", (float)speed / (float)DVD_PLAYSPEED_NORMAL, pause_resume);
+
+  if (pause_resume)
   {
     OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-    OMX_TIME_CONFIG_CLOCKSTATETYPE clock;
-    OMX_INIT_STRUCTURE(clock);
-    
-    clock.eState    = OMX_TIME_ClockStateRunning;
-    clock.nOffset   = ToOMXTime(-1000LL * OMX_PRE_ROLL);
-
-    omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeClockState, &clock);
+    OMX_TIME_CONFIG_SCALETYPE scaleType;
+    OMX_INIT_STRUCTURE(scaleType);
+
+    if (TP(speed))
+      scaleType.xScale = 0; // for trickplay we just pause, and single step
+    else
+      scaleType.xScale = (speed << 16) / DVD_PLAYSPEED_NORMAL;
+    omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeScale, &scaleType);
     if(omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "OMXClock::OMXHandleBackward error setting OMX_IndexConfigTimeClockState\n");
+      CLog::Log(LOGERROR, "OMXClock::OMXSetSpeed error setting OMX_IndexConfigTimeClockState\n");
+      if(lock)
+        UnLock();
+      return false;
     }
   }
-
-  if(lock)
-    UnLock();
-  */
-}
-
-bool OMXClock::OMXSetSpeed(int speed, bool lock /* = true */)
-{
-  if(m_omx_clock.GetComponent() == NULL)
-    return false;
-
-  if(lock)
-    Lock();
-
-  m_omx_speed = speed;
-
-  m_audio_buffer = false; 
-
-  CLog::Log(LOGDEBUG, "OMXClock::OMXSetSpeed %d buffering %d", m_omx_speed / DVD_PLAYSPEED_NORMAL, m_audio_buffer);
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_TIME_CONFIG_SCALETYPE scaleType;
-  OMX_INIT_STRUCTURE(scaleType);
-
-  scaleType.xScale = ((m_omx_speed / DVD_PLAYSPEED_NORMAL) << 16);
-
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeScale, &scaleType);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "OMXClock::OMXSetSpeed error setting OMX_IndexConfigTimeClockState\n");
-    if(lock)
-      UnLock();
-    return false;
-  }
+  if (!pause_resume)
+    m_omx_speed = speed;
 
   if(lock)
     UnLock();
@@ -1022,17 +491,6 @@ bool OMXClock::OMXSetSpeed(int speed, bool lock /* = true */)
   return true;
 }
 
-void OMXClock::AddTimespecs(struct timespec &time, long millisecs)
-{
-   time.tv_sec  += millisecs / 1000;
-   time.tv_nsec += (millisecs % 1000) * 1000000;
-   if (time.tv_nsec > 1000000000)
-   {
-      time.tv_sec  += 1;
-      time.tv_nsec -= 1000000000;
-   }
-}
-
 bool OMXClock::HDMIClockSync(bool lock /* = true */)
 {
   if(m_omx_clock.GetComponent() == NULL)
@@ -1081,17 +539,6 @@ int64_t OMXClock::CurrentHostFrequency(void)
   return( (int64_t)1000000000L );
 }
 
-void OMXClock::AddTimeSpecNano(struct timespec &time, uint64_t nanoseconds)
-{
-   time.tv_sec  += nanoseconds / 1000000000;
-   time.tv_nsec += (nanoseconds % 1000000000);
-   if (time.tv_nsec > 1000000000)
-   {
-      time.tv_sec  += 1;
-      time.tv_nsec -= 1000000000;
-   }
-}
-
 int OMXClock::GetRefreshRate(double* interval)
 {
   if(!interval)
@@ -1101,47 +548,6 @@ int OMXClock::GetRefreshRate(double* interval)
   return true;
 }
 
-void OMXClock::OMXAudioBufferStart()
-{
-  Lock();
-
-  m_audio_buffer = true;
-
-  // only buffer when we are in normal playspeed
-  if(m_omx_clock.GetComponent() == NULL || m_omx_speed != DVD_PLAYSPEED_NORMAL)
-  {
-    UnLock();
-    return;
-  }
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_TIME_CONFIG_SCALETYPE scaleType;
-  OMX_INIT_STRUCTURE(scaleType);
-
-  scaleType.xScale = 0;
-
-  CLog::Log(LOGDEBUG, "OMXClock::OMXAudioBufferStart");
-
-  omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeScale, &scaleType);
-  if(omx_err != OMX_ErrorNone)
-    CLog::Log(LOGERROR, "OMXClock::OMXAudioBufferStart error setting OMX_IndexConfigTimeClockState\n");
-
-  UnLock();
-}
-
-void OMXClock::OMXAudioBufferStop()
-{
-  Lock();
-
-  CLog::Log(LOGDEBUG, "OMXClock::OMXAudioBufferStop");
-
-  m_audio_buffer = false;
-
-  OMXSetSpeed(m_omx_speed, false);
-
-  UnLock();
-}
-
 double OMXClock::NormalizeFrameduration(double frameduration)
 {
   //if the duration is within 20 microseconds of a common duration, use that
diff --git a/xbmc/linux/OMXClock.h b/xbmc/linux/OMXClock.h
index b94fb47..24207bc 100644
--- a/xbmc/linux/OMXClock.h
+++ b/xbmc/linux/OMXClock.h
@@ -45,40 +45,17 @@ static inline int64_t FromOMXTime(OMX_TICKS ticks)
 #define ToOMXTime(x) (x)
 #endif
 
-enum {
-  AV_SYNC_AUDIO_MASTER,
-  AV_SYNC_VIDEO_MASTER,
-  AV_SYNC_EXTERNAL_MASTER,
-};
-
 class OMXClock
 {
 protected:
   bool              m_pause;
-  bool              m_has_video;
-  bool              m_has_audio;
-  int               m_play_speed;
   pthread_mutex_t   m_lock;
-  double            SystemToAbsolute(int64_t system);
-  double            SystemToPlaying(int64_t system);
-  int64_t           m_systemUsed;
-  int64_t           m_startClock;
-  int64_t           m_pauseClock;
-  double            m_iDisc;
-  bool              m_bReset;
-  static int64_t    m_systemFrequency;
-  static int64_t    m_systemOffset;
-  int64_t           m_ClockOffset;
-  double            m_maxspeedadjust;
-  bool              m_speedadjust;
-  static bool       m_ismasterclock;
   double            m_fps;
   int               m_omx_speed;
-  bool              m_video_start;
-  bool              m_audio_start;
-  bool              m_audio_buffer;
-  CDVDClock         m_clock;
-  OMX_TIME_CONFIG_CLOCKSTATETYPE m_clock_state;
+  OMX_U32           m_WaitMask;
+  OMX_TIME_CLOCKSTATE   m_eState;
+  OMX_TIME_REFCLOCKTYPE m_eClock;
+  CDVDClock         *m_clock;
 private:
   COMXCoreComponent m_omx_clock;
 public:
@@ -86,67 +63,31 @@ class OMXClock
   ~OMXClock();
   void Lock();
   void UnLock();
-  double  GetAbsoluteClock(bool interpolated = true);
-  double  GetFrequency() { return (double)m_systemFrequency ; }
-  double  WaitAbsoluteClock(double target);
-  double GetClock(bool interpolated = true);
-  double GetClock(double& absolute, bool interpolated = true);
-  void CheckSystemClock();
-  void SetSpeed(int iSpeed);
-  void SetMasterClock(bool ismasterclock) { m_ismasterclock = ismasterclock; }
-  bool IsMasterClock()                    { return m_ismasterclock;          }
-  void Discontinuity(double currentPts = 0LL);
-
-  void Reset() { m_bReset = true; }
-  void Pause();
-  void Resume();
-
-  int UpdateFramerate(double fps, double* interval = NULL);
-  bool   SetMaxSpeedAdjust(double speed);
-
-  void OMXSetClockPorts(OMX_TIME_CONFIG_CLOCKSTATETYPE *clock);
-  bool OMXSetReferenceClock(bool lock = true);
-  bool OMXInitialize(bool has_video, bool has_audio);
+  double GetAbsoluteClock(bool interpolated = true) { return m_clock ? m_clock->GetAbsoluteClock(interpolated):0; }
+  double GetClock(bool interpolated = true) { return m_clock ? m_clock->GetClock(interpolated):0; }
+  double GetClock(double& absolute, bool interpolated = true) { return m_clock ? m_clock->GetClock(absolute, interpolated):0; }
+  void Discontinuity(double currentPts = 0LL) { if (m_clock) m_clock->Discontinuity(currentPts); }
+  void OMXSetClockPorts(OMX_TIME_CONFIG_CLOCKSTATETYPE *clock, bool has_video, bool has_audio);
+  bool OMXSetReferenceClock(bool has_audio, bool lock = true);
+  bool OMXInitialize(CDVDClock *clock);
   void OMXDeinitialize();
   bool OMXIsPaused() { return m_pause; };
-  void OMXSaveState(bool lock = true);
-  void OMXRestoreState(bool lock = true);
   bool OMXStop(bool lock = true);
-  bool OMXStart(bool lock = true);
-  bool OMXReset(bool lock = true);
-  double OMXWallTime(bool lock = true);
-  double OMXMediaTime(bool fixPreroll = true, bool lock = true);
-  bool OMXMediaTime(double pts, bool fixPreroll = true, bool lock = true);
-  int OMXLateCount(int port, bool lock = true);
+  bool OMXStep(int steps = 1, bool lock = true);
+  bool OMXReset(bool has_video, bool has_audio, bool lock = true);
+  double OMXMediaTime(bool lock = true);
+  double OMXClockAdjustment(bool lock = true);
+  bool OMXMediaTime(double pts, bool lock = true);
   bool OMXPause(bool lock = true);
   bool OMXResume(bool lock = true);
-  bool OMXUpdateClock(double pts, bool lock = true);
-  bool OMXWaitStart(double pts, bool lock = true);
-  void OMXHandleBackward(bool lock = true);
-  bool OMXSetSpeed(int speed, bool lock = true);
+  bool OMXSetSpeed(int speed, bool lock = true, bool pause_resume = false);
   int  OMXPlaySpeed() { return m_omx_speed; };
-  int  OMXGetPlaySpeed() { return m_omx_speed; };
   COMXCoreComponent *GetOMXClock();
-  bool OMXStatePause(bool lock = true);
   bool OMXStateExecute(bool lock = true);
   void OMXStateIdle(bool lock = true);
-  static void AddTimespecs(struct timespec &time, long millisecs);
   bool HDMIClockSync(bool lock = true);
   static int64_t CurrentHostCounter(void);
   static int64_t CurrentHostFrequency(void);
-  bool HasVideo() { return m_has_video; };
-  bool HasAudio() { return m_has_audio; };
-  void HasVideo(bool has_video) { m_has_video = has_video; };
-  void HasAudio(bool has_audio) { m_has_audio = has_audio; };
-  bool VideoStart() { return m_video_start; };
-  bool AudioStart() { return m_audio_start; };
-  void VideoStart(bool video_start);
-  void AudioStart(bool audio_start);
-  static void AddTimeSpecNano(struct timespec &time, uint64_t nanoseconds);
-
-  void OMXAudioBufferStart();
-  void OMXAudioBufferStop();
-  bool OMXAudioBuffer() { return m_audio_buffer; };
 
   int     GetRefreshRate(double* interval = NULL);
   void    SetRefreshRate(double fps) { m_fps = fps; };
diff --git a/xbmc/linux/OMXCore.cpp b/xbmc/linux/OMXCore.cpp
index 904c0ef..01eea74 100644
--- a/xbmc/linux/OMXCore.cpp
+++ b/xbmc/linux/OMXCore.cpp
@@ -32,6 +32,7 @@
 #include "utils/log.h"
 
 #include "OMXClock.h"
+#include "xbmc/linux/RBP.h"
 
 #ifdef _LINUX
 #include "XMemUtils.h"
@@ -46,13 +47,13 @@
 
 static void add_timespecs(struct timespec &time, long millisecs)
 {
-   time.tv_sec  += millisecs / 1000;
-   time.tv_nsec += (millisecs % 1000) * 1000000;
-   if (time.tv_nsec > 1000000000)
+   long long nsec = time.tv_nsec + (long long)millisecs * 1000000;
+   while (nsec > 1000000000)
    {
-      time.tv_sec  += 1;
-      time.tv_nsec -= 1000000000;
+      time.tv_sec += 1;
+      nsec -= 1000000000;
    }
+   time.tv_nsec = nsec;
 }
 
 
@@ -62,41 +63,16 @@ COMXCoreTunel::COMXCoreTunel()
   m_dst_component       = NULL;
   m_src_port            = 0;
   m_dst_port            = 0;
-  m_portSettingsChanged = false;
   m_tunnel_set          = false;
-  m_DllOMX              = new DllOMX();
-
-  if(m_DllOMX)
-    m_DllOMXOpen        = m_DllOMX->Load();
-  else
-    m_DllOMXOpen        = false;
-
-  pthread_mutex_init(&m_lock, NULL);
+  m_DllOMX              = g_RBP.GetDllOMX();
 }
 
 COMXCoreTunel::~COMXCoreTunel()
 {
-  if(m_DllOMXOpen)
-    m_DllOMX->Unload();
-  delete m_DllOMX;
-
-  pthread_mutex_destroy(&m_lock);
-}
-
-void COMXCoreTunel::Lock()
-{
-  pthread_mutex_lock(&m_lock);
-}
-
-void COMXCoreTunel::UnLock()
-{
-  pthread_mutex_unlock(&m_lock);
 }
 
 void COMXCoreTunel::Initialize(COMXCoreComponent *src_component, unsigned int src_port, COMXCoreComponent *dst_component, unsigned int dst_port)
 {
-  if(!m_DllOMXOpen)
-    return;
   m_src_component  = src_component;
   m_src_port    = src_port;
   m_dst_component  = dst_component;
@@ -108,86 +84,61 @@ bool COMXCoreTunel::IsInitialized()
   return m_tunnel_set;
 }
 
-OMX_ERRORTYPE COMXCoreTunel::Flush()
+OMX_ERRORTYPE COMXCoreTunel::Deestablish(bool noWait)
 {
-  if(!m_DllOMXOpen || !m_src_component || !m_dst_component || !m_tunnel_set || !IsInitialized())
+  if(!m_src_component || !m_dst_component || !IsInitialized())
     return OMX_ErrorUndefined;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+
   if(m_src_component->GetComponent())
   {
-    omx_err = m_src_component->SendCommand(OMX_CommandFlush, m_src_port, NULL);
-    if(omx_err != OMX_ErrorNone && omx_err != OMX_ErrorSameState)
+    omx_err = m_src_component->DisablePort(m_src_port, false);
+    if(omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "COMXCoreTunel::Flush - Error flush  port %d on component %s omx_err(0x%08x)", 
+      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - Error disable port %d on component %s omx_err(0x%08x)",
           m_src_port, m_src_component->GetName().c_str(), (int)omx_err);
     }
   }
 
   if(m_dst_component->GetComponent())
   {
-    omx_err = m_dst_component->SendCommand(OMX_CommandFlush, m_dst_port, NULL);
-    if(omx_err != OMX_ErrorNone && omx_err != OMX_ErrorSameState)
+    omx_err = m_dst_component->DisablePort(m_dst_port, false);
+    if(omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "COMXCoreTunel::Flush - Error flush port %d on component %s omx_err(0x%08x)", 
+      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - Error disable port %d on component %s omx_err(0x%08x)",
           m_dst_port, m_dst_component->GetName().c_str(), (int)omx_err);
     }
   }
 
   if(m_src_component->GetComponent())
-    omx_err = m_src_component->WaitForCommand(OMX_CommandFlush, m_src_port);
-
-  if(m_dst_component->GetComponent())
-    omx_err = m_dst_component->WaitForCommand(OMX_CommandFlush, m_dst_port);
-
-  UnLock();
-
-  return OMX_ErrorNone;
-}
-
-OMX_ERRORTYPE COMXCoreTunel::Deestablish(bool noWait)
-{
-  if(!m_DllOMXOpen)
-    return OMX_ErrorUndefined;
-
-  if(!m_src_component || !m_dst_component || !IsInitialized())
-    return OMX_ErrorUndefined;
-
-  Lock();
-
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-
-  if(m_src_component->GetComponent() && m_portSettingsChanged && !noWait)
-    omx_err = m_src_component->WaitForEvent(OMX_EventPortSettingsChanged);
-
-  if(m_src_component->GetComponent())
   {
-    omx_err = m_src_component->DisablePort(m_src_port, false);
-    if(omx_err != OMX_ErrorNone && omx_err != OMX_ErrorSameState)
+    omx_err = m_src_component->WaitForCommand(OMX_CommandPortDisable, m_src_port);
+    if(omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - Error disable port %d on component %s omx_err(0x%08x)", 
-          m_src_port, m_src_component->GetName().c_str(), (int)omx_err);
+      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - Error WaitForCommand port %d on component %s omx_err(0x%08x)",
+          m_dst_port, m_src_component->GetName().c_str(), (int)omx_err);
+      return omx_err;
     }
   }
 
   if(m_dst_component->GetComponent())
   {
-    omx_err = m_dst_component->DisablePort(m_dst_port, false);
-    if(omx_err != OMX_ErrorNone && omx_err != OMX_ErrorSameState) 
+    omx_err = m_dst_component->WaitForCommand(OMX_CommandPortDisable, m_dst_port);
+    if(omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - Error disable port %d on component %s omx_err(0x%08x)", 
+      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - Error WaitForCommand port %d on component %s omx_err(0x%08x)",
           m_dst_port, m_dst_component->GetName().c_str(), (int)omx_err);
+      return omx_err;
     }
   }
 
   if(m_src_component->GetComponent())
   {
     omx_err = m_DllOMX->OMX_SetupTunnel(m_src_component->GetComponent(), m_src_port, NULL, 0);
-    if(omx_err != OMX_ErrorNone && omx_err != OMX_ErrorIncorrectStateOperation) 
+    if(omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - could not unset tunnel on comp src %s port %d omx_err(0x%08x)\n", 
+      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - could not unset tunnel on comp src %s port %d omx_err(0x%08x)\n",
           m_src_component->GetName().c_str(), m_src_port, (int)omx_err);
     }
   }
@@ -195,34 +146,26 @@ OMX_ERRORTYPE COMXCoreTunel::Deestablish(bool noWait)
   if(m_dst_component->GetComponent())
   {
     omx_err = m_DllOMX->OMX_SetupTunnel(m_dst_component->GetComponent(), m_dst_port, NULL, 0);
-    if(omx_err != OMX_ErrorNone && omx_err != OMX_ErrorIncorrectStateOperation) 
+    if(omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - could not unset tunnel on comp dst %s port %d omx_err(0x%08x)\n", 
+      CLog::Log(LOGERROR, "COMXCoreTunel::Deestablish - could not unset tunnel on comp dst %s port %d omx_err(0x%08x)\n",
           m_dst_component->GetName().c_str(), m_dst_port, (int)omx_err);
     }
   }
 
   m_tunnel_set = false;
 
-  UnLock();
-
   return OMX_ErrorNone;
 }
 
-OMX_ERRORTYPE COMXCoreTunel::Establish(bool portSettingsChanged, bool enable_ports /* = true */)
+OMX_ERRORTYPE COMXCoreTunel::Establish(bool enable_ports /* = true */, bool disable_ports /* = false */)
 {
-  if(!m_DllOMXOpen)
-    return OMX_ErrorUndefined;
-
-  Lock();
-
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   OMX_PARAM_U32TYPE param;
   OMX_INIT_STRUCTURE(param);
 
   if(!m_src_component || !m_dst_component)
   {
-    UnLock();
     return OMX_ErrorUndefined;
   }
 
@@ -233,37 +176,49 @@ OMX_ERRORTYPE COMXCoreTunel::Establish(bool portSettingsChanged, bool enable_por
     {
       CLog::Log(LOGERROR, "COMXCoreTunel::Establish - Error setting state to idle %s omx_err(0x%08x)", 
           m_src_component->GetName().c_str(), (int)omx_err);
-      UnLock();
       return omx_err;
     }
   }
 
-  if(portSettingsChanged)
+  if(m_src_component->GetComponent() && disable_ports)
   {
-    omx_err = m_src_component->WaitForEvent(OMX_EventPortSettingsChanged);
+    omx_err = m_src_component->DisablePort(m_src_port, false);
     if(omx_err != OMX_ErrorNone)
     {
-      UnLock();
-      return omx_err;
+      CLog::Log(LOGERROR, "COMXCoreTunel::Establish - Error disable port %d on component %s omx_err(0x%08x)",
+          m_src_port, m_src_component->GetName().c_str(), (int)omx_err);
     }
   }
 
-  if(m_src_component->GetComponent())
+  if(m_dst_component->GetComponent() && disable_ports)
   {
-    omx_err = m_src_component->DisablePort(m_src_port, false);
-    if(omx_err != OMX_ErrorNone && omx_err != OMX_ErrorSameState) 
+    omx_err = m_dst_component->DisablePort(m_dst_port, false);
+    if(omx_err != OMX_ErrorNone)
     {
       CLog::Log(LOGERROR, "COMXCoreTunel::Establish - Error disable port %d on component %s omx_err(0x%08x)",
-          m_src_port, m_src_component->GetName().c_str(), (int)omx_err);
+          m_dst_port, m_dst_component->GetName().c_str(), (int)omx_err);
     }
   }
 
-  if(m_dst_component->GetComponent())
+  if(m_src_component->GetComponent() && disable_ports)
   {
-    omx_err = m_dst_component->DisablePort(m_dst_port, false);
-    if(omx_err != OMX_ErrorNone && omx_err != OMX_ErrorSameState) {
-      CLog::Log(LOGERROR, "COMXCoreTunel::Establish - Error disable port %d on component %s omx_err(0x%08x)",
+    omx_err = m_src_component->WaitForCommand(OMX_CommandPortDisable, m_src_port);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "COMXCoreTunel::Establish - Error WaitForCommand port %d on component %s omx_err(0x%08x)",
+          m_dst_port, m_src_component->GetName().c_str(), (int)omx_err);
+      return omx_err;
+    }
+  }
+
+  if(m_dst_component->GetComponent() && disable_ports)
+  {
+    omx_err = m_dst_component->WaitForCommand(OMX_CommandPortDisable, m_dst_port);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "COMXCoreTunel::Establish - Error WaitForCommand port %d on component %s omx_err(0x%08x)",
           m_dst_port, m_dst_component->GetName().c_str(), (int)omx_err);
+      return omx_err;
     }
   }
 
@@ -274,14 +229,12 @@ OMX_ERRORTYPE COMXCoreTunel::Establish(bool portSettingsChanged, bool enable_por
     {
       CLog::Log(LOGERROR, "COMXCoreTunel::Establish - could not setup tunnel src %s port %d dst %s port %d omx_err(0x%08x)\n", 
           m_src_component->GetName().c_str(), m_src_port, m_dst_component->GetName().c_str(), m_dst_port, (int)omx_err);
-      UnLock();
       return omx_err;
     }
   }
   else
   {
     CLog::Log(LOGERROR, "COMXCoreTunel::Establish - could not setup tunnel\n");
-    UnLock();
     return OMX_ErrorUndefined;
   }
 
@@ -294,7 +247,6 @@ OMX_ERRORTYPE COMXCoreTunel::Establish(bool portSettingsChanged, bool enable_por
     {
       CLog::Log(LOGERROR, "COMXCoreTunel::Establish - Error enable port %d on component %s omx_err(0x%08x)", 
           m_src_port, m_src_component->GetName().c_str(), (int)omx_err);
-      UnLock();
       return omx_err;
     }
   }
@@ -306,7 +258,6 @@ OMX_ERRORTYPE COMXCoreTunel::Establish(bool portSettingsChanged, bool enable_por
     {
       CLog::Log(LOGERROR, "COMXCoreTunel::Establish - Error enable port %d on component %s omx_err(0x%08x)", 
           m_dst_port, m_dst_component->GetName().c_str(), (int)omx_err);
-      UnLock();
       return omx_err;
     }
   }
@@ -316,10 +267,9 @@ OMX_ERRORTYPE COMXCoreTunel::Establish(bool portSettingsChanged, bool enable_por
     omx_err = m_dst_component->WaitForCommand(OMX_CommandPortEnable, m_dst_port);
     if(omx_err != OMX_ErrorNone)
     {
-      UnLock();
       return omx_err;
     }
-    
+
     if(m_dst_component->GetState() == OMX_StateLoaded)
     {
       omx_err = m_dst_component->SetStateForComponent(OMX_StateIdle);
@@ -327,7 +277,6 @@ OMX_ERRORTYPE COMXCoreTunel::Establish(bool portSettingsChanged, bool enable_por
       {
         CLog::Log(LOGERROR, "COMXCoreComponent::Establish - Error setting state to idle %s omx_err(0x%08x)", 
             m_src_component->GetName().c_str(), (int)omx_err);
-        UnLock();
         return omx_err;
       }
     }
@@ -338,15 +287,10 @@ OMX_ERRORTYPE COMXCoreTunel::Establish(bool portSettingsChanged, bool enable_por
     omx_err = m_src_component->WaitForCommand(OMX_CommandPortEnable, m_src_port);
     if(omx_err != OMX_ErrorNone)
     {
-      UnLock();
       return omx_err;
     }
   }
 
-  m_portSettingsChanged = portSettingsChanged;
-
-  UnLock();
-
   return OMX_ErrorNone;
 }
 
@@ -373,6 +317,12 @@ COMXCoreComponent::COMXCoreComponent()
 
   m_exit = false;
 
+  m_omx_input_use_buffers  = false;
+  m_omx_output_use_buffers = false;
+
+  m_omx_events.clear();
+  m_ignore_error = OMX_ErrorNone;
+
   pthread_mutex_init(&m_omx_input_mutex, NULL);
   pthread_mutex_init(&m_omx_output_mutex, NULL);
   pthread_mutex_init(&m_omx_event_mutex, NULL);
@@ -381,22 +331,12 @@ COMXCoreComponent::COMXCoreComponent()
   pthread_cond_init(&m_output_buffer_cond, NULL);
   pthread_cond_init(&m_omx_event_cond, NULL);
 
-  m_omx_input_use_buffers  = false;
-  m_omx_output_use_buffers = false;
-
-  m_DllOMX = new DllOMX();
-
-  if(m_DllOMX)
-    m_DllOMXOpen = m_DllOMX->Load();
-  else
-    m_DllOMXOpen = false;
-
-  pthread_mutex_init(&m_lock, NULL);
+  m_DllOMX = g_RBP.GetDllOMX();
 }
 
 COMXCoreComponent::~COMXCoreComponent()
 {
-  Deinitialize(true);
+  Deinitialize();
 
   pthread_mutex_destroy(&m_omx_input_mutex);
   pthread_mutex_destroy(&m_omx_output_mutex);
@@ -405,22 +345,6 @@ COMXCoreComponent::~COMXCoreComponent()
   pthread_cond_destroy(&m_input_buffer_cond);
   pthread_cond_destroy(&m_output_buffer_cond);
   pthread_cond_destroy(&m_omx_event_cond);
-
-  pthread_mutex_destroy(&m_lock);
-
-  if(m_DllOMXOpen)
-    m_DllOMX->Unload();
-  delete m_DllOMX;
-}
-
-void COMXCoreComponent::Lock()
-{
-  pthread_mutex_lock(&m_lock);
-}
-
-void COMXCoreComponent::UnLock()
-{
-  pthread_mutex_unlock(&m_lock);
 }
 
 void COMXCoreComponent::TransitionToStateLoaded()
@@ -428,10 +352,7 @@ void COMXCoreComponent::TransitionToStateLoaded()
   if(!m_handle)
     return;
 
-  if(GetState() == OMX_StateExecuting)
-    SetStateForComponent(OMX_StatePause);
-
-  if(GetState() != OMX_StateIdle)
+  if(GetState() != OMX_StateLoaded && GetState() != OMX_StateIdle)
     SetStateForComponent(OMX_StateIdle);
 
   if(GetState() != OMX_StateLoaded)
@@ -442,6 +363,9 @@ OMX_ERRORTYPE COMXCoreComponent::EmptyThisBuffer(OMX_BUFFERHEADERTYPE *omx_buffe
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
+  #if defined(OMX_DEBUG_EVENTHANDLER)
+  CLog::Log(LOGDEBUG, "COMXCoreComponent::EmptyThisBuffer component(%s) %p\n", m_componentName.c_str(), omx_buffer);
+  #endif
   if(!m_handle || !omx_buffer)
     return OMX_ErrorUndefined;
 
@@ -459,6 +383,9 @@ OMX_ERRORTYPE COMXCoreComponent::FillThisBuffer(OMX_BUFFERHEADERTYPE *omx_buffer
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
+  #if defined(OMX_DEBUG_EVENTHANDLER)
+  CLog::Log(LOGDEBUG, "COMXCoreComponent::FillThisBuffer component(%s) %p\n", m_componentName.c_str(), omx_buffer);
+  #endif
   if(!m_handle || !omx_buffer)
     return OMX_ErrorUndefined;
 
@@ -524,8 +451,6 @@ void COMXCoreComponent::FlushInput()
   if(!m_handle)
     return;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
   omx_err = OMX_SendCommand(m_handle, OMX_CommandFlush, m_input_port, NULL);
@@ -536,8 +461,6 @@ void COMXCoreComponent::FlushInput()
               m_componentName.c_str(), (int)omx_err);
   }
   WaitForCommand(OMX_CommandFlush, m_input_port);
-
-  UnLock();
 }
 
 void COMXCoreComponent::FlushOutput()
@@ -545,8 +468,6 @@ void COMXCoreComponent::FlushOutput()
   if(!m_handle)
     return;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
   omx_err = OMX_SendCommand(m_handle, OMX_CommandFlush, m_output_port, NULL);
@@ -557,12 +478,10 @@ void COMXCoreComponent::FlushOutput()
               m_componentName.c_str(), (int)omx_err);
   }
   WaitForCommand(OMX_CommandFlush, m_output_port);
-
-  UnLock();
 }
 
 // timeout in milliseconds
-OMX_BUFFERHEADERTYPE *COMXCoreComponent::GetInputBuffer(long timeout)
+OMX_BUFFERHEADERTYPE *COMXCoreComponent::GetInputBuffer(long timeout /*=200*/)
 {
   OMX_BUFFERHEADERTYPE *omx_input_buffer = NULL;
 
@@ -573,8 +492,10 @@ OMX_BUFFERHEADERTYPE *COMXCoreComponent::GetInputBuffer(long timeout)
   struct timespec endtime;
   clock_gettime(CLOCK_REALTIME, &endtime);
   add_timespecs(endtime, timeout);
-  while (1 && !m_flush_input)
+  while (!m_flush_input)
   {
+    if (m_resource_error)
+      break;
     if(!m_omx_input_avaliable.empty())
     {
       omx_input_buffer = m_omx_input_avaliable.front();
@@ -584,7 +505,8 @@ OMX_BUFFERHEADERTYPE *COMXCoreComponent::GetInputBuffer(long timeout)
 
     int retcode = pthread_cond_timedwait(&m_input_buffer_cond, &m_omx_input_mutex, &endtime);
     if (retcode != 0) {
-      CLog::Log(LOGERROR, "COMXCoreComponent::GetInputBuffer %s wait event timeout\n", m_componentName.c_str());
+      if (timeout != 0)
+        CLog::Log(LOGERROR, "COMXCoreComponent::GetInputBuffer %s wait event timeout\n", m_componentName.c_str());
       break;
     }
   }
@@ -592,7 +514,7 @@ OMX_BUFFERHEADERTYPE *COMXCoreComponent::GetInputBuffer(long timeout)
   return omx_input_buffer;
 }
 
-OMX_BUFFERHEADERTYPE *COMXCoreComponent::GetOutputBuffer()
+OMX_BUFFERHEADERTYPE *COMXCoreComponent::GetOutputBuffer(long timeout /*=200*/)
 {
   OMX_BUFFERHEADERTYPE *omx_output_buffer = NULL;
 
@@ -600,17 +522,82 @@ OMX_BUFFERHEADERTYPE *COMXCoreComponent::GetOutputBuffer()
     return NULL;
 
   pthread_mutex_lock(&m_omx_output_mutex);
+  struct timespec endtime;
+  clock_gettime(CLOCK_REALTIME, &endtime);
+  add_timespecs(endtime, timeout);
+  while (!m_flush_output)
+  {
+    if (m_resource_error)
+      break;
+    if(!m_omx_output_available.empty())
+    {
+      omx_output_buffer = m_omx_output_available.front();
+      m_omx_output_available.pop();
+      break;
+    }
 
-  if(!m_omx_output_available.empty())
+    int retcode = pthread_cond_timedwait(&m_output_buffer_cond, &m_omx_output_mutex, &endtime);
+    if (retcode != 0) {
+      CLog::Log(LOGERROR, "COMXCoreComponent::GetOutputBuffer %s wait event timeout\n", m_componentName.c_str());
+      break;
+    }
+  }
+  pthread_mutex_unlock(&m_omx_output_mutex);
+
+  return omx_output_buffer;
+}
+
+
+OMX_ERRORTYPE COMXCoreComponent::WaitForInputDone(long timeout /*=200*/)
+{
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+
+  pthread_mutex_lock(&m_omx_input_mutex);
+  struct timespec endtime;
+  clock_gettime(CLOCK_REALTIME, &endtime);
+  add_timespecs(endtime, timeout);
+  while (m_input_buffer_count != m_omx_input_avaliable.size())
   {
-    omx_output_buffer = m_omx_output_available.front();
-    m_omx_output_available.pop();
+    if (m_resource_error)
+      break;
+    int retcode = pthread_cond_timedwait(&m_input_buffer_cond, &m_omx_input_mutex, &endtime);
+    if (retcode != 0) {
+      if (timeout != 0)
+        CLog::Log(LOGERROR, "COMXCoreComponent::WaitForInputDone %s wait event timeout\n", m_componentName.c_str());
+      omx_err = OMX_ErrorTimeout;
+      break;
+    }
   }
+  pthread_mutex_unlock(&m_omx_input_mutex);
+  return omx_err;
+}
+
+
+OMX_ERRORTYPE COMXCoreComponent::WaitForOutputDone(long timeout /*=200*/)
+{
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
+  pthread_mutex_lock(&m_omx_output_mutex);
+  struct timespec endtime;
+  clock_gettime(CLOCK_REALTIME, &endtime);
+  add_timespecs(endtime, timeout);
+  while (m_output_buffer_count != m_omx_output_available.size())
+  {
+    if (m_resource_error)
+      break;
+    int retcode = pthread_cond_timedwait(&m_output_buffer_cond, &m_omx_output_mutex, &endtime);
+    if (retcode != 0) {
+      if (timeout != 0)
+        CLog::Log(LOGERROR, "COMXCoreComponent::WaitForOutputDone %s wait event timeout\n", m_componentName.c_str());
+      omx_err = OMX_ErrorTimeout;
+      break;
+    }
+  }
   pthread_mutex_unlock(&m_omx_output_mutex);
-  return omx_output_buffer;
+  return omx_err;
 }
 
+
 OMX_ERRORTYPE COMXCoreComponent::AllocInputBuffers(bool use_buffers /* = false **/)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
@@ -681,6 +668,11 @@ OMX_ERRORTYPE COMXCoreComponent::AllocInputBuffers(bool use_buffers /* = false *
   }
 
   omx_err = WaitForCommand(OMX_CommandPortEnable, m_input_port);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::AllocInputBuffers WaitForCommand:OMX_CommandPortEnable failed on %s omx_err(0x%08x)\n", m_componentName.c_str(), omx_err);
+    return omx_err;
+  }
 
   m_flush_input = false;
 
@@ -757,6 +749,11 @@ OMX_ERRORTYPE COMXCoreComponent::AllocOutputBuffers(bool use_buffers /* = false
   }
 
   omx_err = WaitForCommand(OMX_CommandPortEnable, m_output_port);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::AllocOutputBuffers WaitForCommand:OMX_CommandPortEnable failed on %s omx_err(0x%08x)\n", m_componentName.c_str(), omx_err);
+    return omx_err;
+  }
 
   m_flush_output = false;
 
@@ -775,11 +772,11 @@ OMX_ERRORTYPE COMXCoreComponent::FreeInputBuffers()
 
   m_flush_input = true;
 
+  omx_err = DisablePort(m_input_port, false);
+
   pthread_mutex_lock(&m_omx_input_mutex);
   pthread_cond_broadcast(&m_input_buffer_cond);
 
-  omx_err = DisablePort(m_input_port, false);
-
   for (size_t i = 0; i < m_omx_input_buffers.size(); i++)
   {
     uint8_t *buf = m_omx_input_buffers[i]->pBuffer;
@@ -794,8 +791,17 @@ OMX_ERRORTYPE COMXCoreComponent::FreeInputBuffers()
       CLog::Log(LOGERROR, "COMXCoreComponent::FreeInputBuffers error deallocate omx input buffer on component %s omx_err(0x%08x)\n", m_componentName.c_str(), omx_err);
     }
   }
+  pthread_mutex_unlock(&m_omx_input_mutex);
 
-  WaitForCommand(OMX_CommandPortDisable, m_input_port);
+  omx_err = WaitForCommand(OMX_CommandPortDisable, m_input_port);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::FreeInputBuffers WaitForCommand:OMX_CommandPortDisable failed on %s omx_err(0x%08x)\n", m_componentName.c_str(), omx_err);
+  }
+
+  WaitForInputDone(1000);
+
+  pthread_mutex_lock(&m_omx_input_mutex);
   assert(m_omx_input_buffers.size() == m_omx_input_avaliable.size());
 
   m_omx_input_buffers.clear();
@@ -824,11 +830,11 @@ OMX_ERRORTYPE COMXCoreComponent::FreeOutputBuffers()
 
   m_flush_output = true;
 
+  omx_err = DisablePort(m_output_port, false);
+
   pthread_mutex_lock(&m_omx_output_mutex);
   pthread_cond_broadcast(&m_output_buffer_cond);
 
-  omx_err = DisablePort(m_output_port, false);
-
   for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
   {
     uint8_t *buf = m_omx_output_buffers[i]->pBuffer;
@@ -843,8 +849,17 @@ OMX_ERRORTYPE COMXCoreComponent::FreeOutputBuffers()
       CLog::Log(LOGERROR, "COMXCoreComponent::FreeOutputBuffers error deallocate omx output buffer on component %s omx_err(0x%08x)\n", m_componentName.c_str(), omx_err);
     }
   }
+  pthread_mutex_unlock(&m_omx_output_mutex);
+
+  omx_err = WaitForCommand(OMX_CommandPortDisable, m_output_port);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::FreeOutputBuffers WaitForCommand:OMX_CommandPortDisable failed on %s omx_err(0x%08x)\n", m_componentName.c_str(), omx_err);
+  }
+
+  WaitForOutputDone(1000);
 
-  WaitForCommand(OMX_CommandPortDisable, m_output_port);
+  pthread_mutex_lock(&m_omx_output_mutex);
   assert(m_omx_output_buffers.size() == m_omx_output_available.size());
 
   m_omx_output_buffers.clear();
@@ -866,8 +881,6 @@ OMX_ERRORTYPE COMXCoreComponent::DisableAllPorts()
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
   OMX_INDEXTYPE idxTypes[] = {
@@ -908,16 +921,11 @@ OMX_ERRORTYPE COMXCoreComponent::DisableAllPorts()
         }
         omx_err = WaitForCommand(OMX_CommandPortDisable, ports.nStartPortNumber+j);
         if(omx_err != OMX_ErrorNone && omx_err != OMX_ErrorSameState)
-        {
-          UnLock();
           return omx_err;
-        }
       }
     }
   }
 
-  UnLock();
-
   return OMX_ErrorNone;
 }
 
@@ -1012,6 +1020,8 @@ OMX_ERRORTYPE COMXCoreComponent::WaitForEvent(OMX_EVENTTYPE eventType, long time
       }
     }
 
+    if (m_resource_error)
+      break;
     int retcode = pthread_cond_timedwait(&m_omx_event_cond, &m_omx_event_mutex, &endtime);
     if (retcode != 0) 
     {
@@ -1019,7 +1029,7 @@ OMX_ERRORTYPE COMXCoreComponent::WaitForEvent(OMX_EVENTTYPE eventType, long time
         CLog::Log(LOGERROR, "COMXCoreComponent::WaitForEvent %s wait event 0x%08x timeout %ld\n",
                           m_componentName.c_str(), (int)eventType, timeout);
       pthread_mutex_unlock(&m_omx_event_mutex);
-      return OMX_ErrorMax;
+      return OMX_ErrorTimeout;
     }
   }
   pthread_mutex_unlock(&m_omx_event_mutex);
@@ -1079,13 +1089,15 @@ OMX_ERRORTYPE COMXCoreComponent::WaitForCommand(OMX_U32 command, OMX_U32 nData2,
       }
     }
 
+    if (m_resource_error)
+      break;
     int retcode = pthread_cond_timedwait(&m_omx_event_cond, &m_omx_event_mutex, &endtime);
     if (retcode != 0) {
       CLog::Log(LOGERROR, "COMXCoreComponent::WaitForCommand %s wait timeout event.eEvent 0x%08x event.command 0x%08x event.nData2 %d\n", 
         m_componentName.c_str(), (int)OMX_EventCmdComplete, (int)command, (int)nData2);
       
       pthread_mutex_unlock(&m_omx_event_mutex);
-      return OMX_ErrorMax;
+      return OMX_ErrorTimeout;
     }
   }
   pthread_mutex_unlock(&m_omx_event_mutex);
@@ -1097,22 +1109,19 @@ OMX_ERRORTYPE COMXCoreComponent::SetStateForComponent(OMX_STATETYPE state)
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
-  
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   OMX_STATETYPE state_actual = OMX_StateMax;
 
   if(state == state_actual)
-  {
-    UnLock();
     return OMX_ErrorNone;
-  }
 
   omx_err = OMX_SendCommand(m_handle, OMX_CommandStateSet, state, 0);
   if (omx_err != OMX_ErrorNone)
   {
     if(omx_err == OMX_ErrorSameState)
     {
+      CLog::Log(LOGERROR, "COMXCoreComponent::SetStateForComponent - %s same state\n",
+        m_componentName.c_str());
       omx_err = OMX_ErrorNone;
     }
     else
@@ -1124,17 +1133,12 @@ OMX_ERRORTYPE COMXCoreComponent::SetStateForComponent(OMX_STATETYPE state)
   else 
   {
     omx_err = WaitForCommand(OMX_CommandStateSet, state);
-    if(omx_err == OMX_ErrorSameState)
+    if (omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "COMXCoreComponent::SetStateForComponent - %s ignore OMX_ErrorSameState\n", 
-        m_componentName.c_str());
-      UnLock();
-      return OMX_ErrorNone;
+      CLog::Log(LOGERROR, "COMXCoreComponent::WaitForCommand - %s failed with omx_err(0x%x)\n",
+        m_componentName.c_str(), omx_err);
     }
   }
-
-  UnLock();
-
   return omx_err;
 }
 
@@ -1143,12 +1147,9 @@ OMX_STATETYPE COMXCoreComponent::GetState()
   if(!m_handle)
     return (OMX_STATETYPE)0;
 
-  Lock();
-
   OMX_STATETYPE state;
 
   OMX_GetState(m_handle, &state);
-  UnLock();
   return state;
 }
 
@@ -1157,8 +1158,6 @@ OMX_ERRORTYPE COMXCoreComponent::SetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err;
 
   omx_err = OMX_SetParameter(m_handle, paramIndex, paramStruct);
@@ -1167,9 +1166,6 @@ OMX_ERRORTYPE COMXCoreComponent::SetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR
     CLog::Log(LOGERROR, "COMXCoreComponent::SetParameter - %s failed with omx_err(0x%x)\n", 
               m_componentName.c_str(), omx_err);
   }
-
-  UnLock();
-
   return omx_err;
 }
 
@@ -1178,8 +1174,6 @@ OMX_ERRORTYPE COMXCoreComponent::GetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err;
 
   omx_err = OMX_GetParameter(m_handle, paramIndex, paramStruct);
@@ -1188,9 +1182,6 @@ OMX_ERRORTYPE COMXCoreComponent::GetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR
     CLog::Log(LOGERROR, "COMXCoreComponent::GetParameter - %s failed with omx_err(0x%x)\n", 
               m_componentName.c_str(), omx_err);
   }
-
-  UnLock();
-
   return omx_err;
 }
 
@@ -1199,8 +1190,6 @@ OMX_ERRORTYPE COMXCoreComponent::SetConfig(OMX_INDEXTYPE configIndex, OMX_PTR co
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err;
 
   omx_err = OMX_SetConfig(m_handle, configIndex, configStruct);
@@ -1209,9 +1198,6 @@ OMX_ERRORTYPE COMXCoreComponent::SetConfig(OMX_INDEXTYPE configIndex, OMX_PTR co
     CLog::Log(LOGERROR, "COMXCoreComponent::SetConfig - %s failed with omx_err(0x%x)\n", 
               m_componentName.c_str(), omx_err);
   }
-
-  UnLock();
-
   return omx_err;
 }
 
@@ -1220,8 +1206,6 @@ OMX_ERRORTYPE COMXCoreComponent::GetConfig(OMX_INDEXTYPE configIndex, OMX_PTR co
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err;
 
   omx_err = OMX_GetConfig(m_handle, configIndex, configStruct);
@@ -1230,9 +1214,6 @@ OMX_ERRORTYPE COMXCoreComponent::GetConfig(OMX_INDEXTYPE configIndex, OMX_PTR co
     CLog::Log(LOGERROR, "COMXCoreComponent::GetConfig - %s failed with omx_err(0x%x)\n", 
               m_componentName.c_str(), omx_err);
   }
-
-  UnLock();
-
   return omx_err;
 }
 
@@ -1241,8 +1222,6 @@ OMX_ERRORTYPE COMXCoreComponent::SendCommand(OMX_COMMANDTYPE cmd, OMX_U32 cmdPar
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err;
 
   omx_err = OMX_SendCommand(m_handle, cmd, cmdParam, cmdParamData);
@@ -1251,9 +1230,6 @@ OMX_ERRORTYPE COMXCoreComponent::SendCommand(OMX_COMMANDTYPE cmd, OMX_U32 cmdPar
     CLog::Log(LOGERROR, "COMXCoreComponent::SendCommand - %s failed with omx_err(0x%x)\n", 
               m_componentName.c_str(), omx_err);
   }
-
-  UnLock();
-
   return omx_err;
 }
 
@@ -1262,8 +1238,6 @@ OMX_ERRORTYPE COMXCoreComponent::EnablePort(unsigned int port,  bool wait)
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
   OMX_PARAM_PORTDEFINITIONTYPE portFormat;
@@ -1284,10 +1258,7 @@ OMX_ERRORTYPE COMXCoreComponent::EnablePort(unsigned int port,  bool wait)
     {
       CLog::Log(LOGERROR, "COMXCoreComponent::EnablePort - Error enable port %d on component %s omx_err(0x%08x)", 
           port, m_componentName.c_str(), (int)omx_err);
-      {
-        UnLock();
         return omx_err;
-      }
     }
     else
     {
@@ -1295,9 +1266,6 @@ OMX_ERRORTYPE COMXCoreComponent::EnablePort(unsigned int port,  bool wait)
         omx_err = WaitForCommand(OMX_CommandPortEnable, port);
     }
   }
-
-  UnLock();
-
   return omx_err;
 }
 
@@ -1306,8 +1274,6 @@ OMX_ERRORTYPE COMXCoreComponent::DisablePort(unsigned int port, bool wait)
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
-
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
   OMX_PARAM_PORTDEFINITIONTYPE portFormat;
@@ -1328,10 +1294,7 @@ OMX_ERRORTYPE COMXCoreComponent::DisablePort(unsigned int port, bool wait)
     {
       CLog::Log(LOGERROR, "COMXCoreComponent::DIsablePort - Error disable port %d on component %s omx_err(0x%08x)", 
           port, m_componentName.c_str(), (int)omx_err);
-      {
-        UnLock();
-        return omx_err;
-      }
+      return omx_err;
     }
     else
     {
@@ -1339,29 +1302,84 @@ OMX_ERRORTYPE COMXCoreComponent::DisablePort(unsigned int port, bool wait)
         omx_err = WaitForCommand(OMX_CommandPortDisable, port);
     }
   }
-
-  UnLock();
-
   return omx_err;
 }
 
 OMX_ERRORTYPE COMXCoreComponent::UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex, OMX_PTR pAppPrivate, void* eglImage)
 {
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+
   if(!m_handle)
     return OMX_ErrorUndefined;
 
-  Lock();
+  m_omx_output_use_buffers = false;
 
-  OMX_ERRORTYPE omx_err;
+  OMX_PARAM_PORTDEFINITIONTYPE portFormat;
+  OMX_INIT_STRUCTURE(portFormat);
+  portFormat.nPortIndex = m_output_port;
 
-  omx_err = OMX_UseEGLImage(m_handle, ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
-  if(omx_err != OMX_ErrorNone) 
+  omx_err = OMX_GetParameter(m_handle, OMX_IndexParamPortDefinition, &portFormat);
+  if(omx_err != OMX_ErrorNone)
+    return omx_err;
+
+  if(GetState() != OMX_StateIdle)
+  {
+    if(GetState() != OMX_StateLoaded)
+      SetStateForComponent(OMX_StateLoaded);
+
+    SetStateForComponent(OMX_StateIdle);
+  }
+
+  omx_err = EnablePort(m_output_port, false);
+  if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "COMXCoreComponent::UseEGLImage - %s failed with omx_err(0x%x)\n", 
+    CLog::Log(LOGERROR, "%s::%s - %s EnablePort failed with omx_err(0x%x)", CLASSNAME, __func__,
               m_componentName.c_str(), omx_err);
+    return omx_err;
+  }
+
+  m_output_alignment     = portFormat.nBufferAlignment;
+  m_output_buffer_count  = portFormat.nBufferCountActual;
+  m_output_buffer_size   = portFormat.nBufferSize;
+
+  if (portFormat.nBufferCountActual != 1)
+  {
+    CLog::Log(LOGERROR, "%s::%s - %s nBufferCountActual unexpected %d", CLASSNAME, __func__,
+              m_componentName.c_str(), portFormat.nBufferCountActual);
+    return omx_err;
+  }
+
+  CLog::Log(LOGDEBUG, "%s::%s component(%s) - port(%d), nBufferCountMin(%u), nBufferCountActual(%u), nBufferSize(%u) nBufferAlignmen(%u)\n",
+            CLASSNAME, __func__, m_componentName.c_str(), m_output_port, portFormat.nBufferCountMin,
+            portFormat.nBufferCountActual, portFormat.nBufferSize, portFormat.nBufferAlignment);
+
+  for (size_t i = 0; i < portFormat.nBufferCountActual; i++)
+  {
+    omx_err = OMX_UseEGLImage(m_handle, ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - %s failed with omx_err(0x%x)\n",
+                CLASSNAME, __func__, m_componentName.c_str(), omx_err);
+      return omx_err;
+    }
+
+    OMX_BUFFERHEADERTYPE *buffer = *ppBufferHdr;
+    buffer->nOutputPortIndex = m_output_port;
+    buffer->nFilledLen       = 0;
+    buffer->nOffset          = 0;
+    buffer->pAppPrivate      = (void*)i;
+    m_omx_output_buffers.push_back(buffer);
+    m_omx_output_available.push(buffer);
   }
 
-  UnLock();
+  omx_err = WaitForCommand(OMX_CommandPortEnable, m_output_port);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, " %s::%s - %s EnablePort failed with omx_err(0x%x)\n",
+              CLASSNAME, __func__, m_componentName.c_str(), omx_err);
+      return omx_err;
+  }
+  m_flush_output = false;
 
   return omx_err;
 }
@@ -1370,10 +1388,31 @@ bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEX
 {
   OMX_ERRORTYPE omx_err;
 
-  if(!m_DllOMXOpen)
-    return false;
+  m_input_port  = 0;
+  m_output_port = 0;
+  m_handle      = NULL;
+
+  m_input_alignment     = 0;
+  m_input_buffer_size  = 0;
+  m_input_buffer_count  = 0;
+
+  m_output_alignment    = 0;
+  m_output_buffer_size  = 0;
+  m_output_buffer_count = 0;
+  m_flush_input         = false;
+  m_flush_output        = false;
+  m_resource_error      = false;
+
+  m_eos                 = false;
+
+  m_exit = false;
+
+  m_omx_input_use_buffers  = false;
+  m_omx_output_use_buffers = false;
+
+  m_omx_events.clear();
+  m_ignore_error = OMX_ErrorNone;
 
-  m_resource_error = false;
   m_componentName = component_name;
   
   m_callbacks.EventHandler    = &COMXCoreComponent::DecoderEventHandlerCallback;
@@ -1388,12 +1427,9 @@ bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEX
     {
       CLog::Log(LOGERROR, "COMXCoreComponent::Initialize - could not get component handle for %s omx_err(0x%08x)\n",
           component_name.c_str(), (int)omx_err);
-      Deinitialize(true);
+      Deinitialize();
       return false;
     }
-
-    CLog::Log(LOGDEBUG, "COMXCoreComponent::Initialize : %s handle %p dllopen : %d\n", 
-          m_componentName.c_str(), m_handle, m_DllOMXOpen);
   }
 
   OMX_PORT_PARAM_TYPE port_param;
@@ -1409,7 +1445,7 @@ bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEX
   omx_err = DisableAllPorts();
   if (omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "COMXCoreComponent::Initialize - error disable ports on component %s omx_err(0x%08x)\n", 
+    CLog::Log(LOGERROR, "COMXCoreComponent::Initialize - error disable ports on component %s omx_err(0x%08x)\n",
         component_name.c_str(), (int)omx_err);
   }
 
@@ -1425,8 +1461,8 @@ bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEX
   if (m_output_port > port_param.nStartPortNumber+port_param.nPorts-1)
     m_output_port = port_param.nStartPortNumber+port_param.nPorts-1;
 
-  CLog::Log(LOGDEBUG, "COMXCoreComponent::Initialize %s input port %d output port %d\n",
-      m_componentName.c_str(), m_input_port, m_output_port);
+  CLog::Log(LOGDEBUG, "COMXCoreComponent::Initialize %s input port %d output port %d m_handle %p\n",
+      m_componentName.c_str(), m_input_port, m_output_port, m_handle);
 
   m_exit = false;
   m_flush_input   = false;
@@ -1447,7 +1483,7 @@ void COMXCoreComponent::ResetEos()
   pthread_mutex_unlock(&m_omx_eos_mutex);
 }
 
-bool COMXCoreComponent::Deinitialize(bool free_component /* = false */)
+bool COMXCoreComponent::Deinitialize()
 {
   OMX_ERRORTYPE omx_err;
 
@@ -1456,7 +1492,7 @@ bool COMXCoreComponent::Deinitialize(bool free_component /* = false */)
   m_flush_input   = true;
   m_flush_output  = true;
 
-  if(m_handle && m_DllOMXOpen)
+  if(m_handle)
   {
     FlushAll();
 
@@ -1465,23 +1501,20 @@ bool COMXCoreComponent::Deinitialize(bool free_component /* = false */)
 
     TransitionToStateLoaded();
 
-    if(free_component)
+    CLog::Log(LOGDEBUG, "COMXCoreComponent::Deinitialize : %s handle %p\n",
+        m_componentName.c_str(), m_handle);
+    omx_err = m_DllOMX->OMX_FreeHandle(m_handle);
+    if (omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGDEBUG, "COMXCoreComponent::Deinitialize : %s handle %p dllopen : %d\n", 
-          m_componentName.c_str(), m_handle, m_DllOMXOpen);
-      omx_err = m_DllOMX->OMX_FreeHandle(m_handle);
-      if (omx_err != OMX_ErrorNone)
-      {
-        CLog::Log(LOGERROR, "COMXCoreComponent::Deinitialize - failed to free handle for component %s omx_err(0x%08x)",
-            m_componentName.c_str(), omx_err);
-      }  
-      m_handle = NULL;
-
-      m_input_port      = 0;
-      m_output_port     = 0;
-      m_componentName   = "";
-      m_resource_error  = false;
+      CLog::Log(LOGERROR, "COMXCoreComponent::Deinitialize - failed to free handle for component %s omx_err(0x%08x)",
+          m_componentName.c_str(), omx_err);
     }
+    m_handle = NULL;
+
+    m_input_port      = 0;
+    m_output_port     = 0;
+    m_componentName   = "";
+    m_resource_error  = false;
   }
 
   return true;
@@ -1501,7 +1534,7 @@ OMX_ERRORTYPE COMXCoreComponent::DecoderEventHandlerCallback(
     return OMX_ErrorNone;
 
   COMXCoreComponent *ctx = static_cast<COMXCoreComponent*>(pAppData);
-  return ctx->DecoderEventHandler(hComponent, pAppData, eEvent, nData1, nData2, pEventData);
+  return ctx->DecoderEventHandler(hComponent, eEvent, nData1, nData2, pEventData);
 }
 
 // DecoderEmptyBufferDone -- OMXCore input buffer has been emptied
@@ -1514,7 +1547,7 @@ OMX_ERRORTYPE COMXCoreComponent::DecoderEmptyBufferDoneCallback(
     return OMX_ErrorNone;
 
   COMXCoreComponent *ctx = static_cast<COMXCoreComponent*>(pAppData);
-  return ctx->DecoderEmptyBufferDone( hComponent, pAppData, pBuffer);
+  return ctx->DecoderEmptyBufferDone( hComponent, pBuffer);
 }
 
 // DecoderFillBufferDone -- OMXCore output buffer has been filled
@@ -1527,41 +1560,43 @@ OMX_ERRORTYPE COMXCoreComponent::DecoderFillBufferDoneCallback(
     return OMX_ErrorNone;
 
   COMXCoreComponent *ctx = static_cast<COMXCoreComponent*>(pAppData);
-  return ctx->DecoderFillBufferDone(hComponent, pAppData, pBuffer);
+  return ctx->DecoderFillBufferDone(hComponent, pBuffer);
 }
 
-OMX_ERRORTYPE COMXCoreComponent::DecoderEmptyBufferDone(OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer)
+OMX_ERRORTYPE COMXCoreComponent::DecoderEmptyBufferDone(OMX_HANDLETYPE hComponent, OMX_BUFFERHEADERTYPE* pBuffer)
 {
-  if(!pAppData || m_exit)
+  if(m_exit)
     return OMX_ErrorNone;
 
-  COMXCoreComponent *ctx = static_cast<COMXCoreComponent*>(pAppData);
-
-  pthread_mutex_lock(&ctx->m_omx_input_mutex);
-  ctx->m_omx_input_avaliable.push(pBuffer);
+  #if defined(OMX_DEBUG_EVENTHANDLER)
+  CLog::Log(LOGDEBUG, "COMXCoreComponent::DecoderEmptyBufferDone component(%s) %p %d/%d\n", m_componentName.c_str(), pBuffer, m_omx_input_avaliable.size(), m_input_buffer_count);
+  #endif
+  pthread_mutex_lock(&m_omx_input_mutex);
+  m_omx_input_avaliable.push(pBuffer);
 
   // this allows (all) blocked tasks to be awoken
-  pthread_cond_broadcast(&ctx->m_input_buffer_cond);
+  pthread_cond_broadcast(&m_input_buffer_cond);
 
-  pthread_mutex_unlock(&ctx->m_omx_input_mutex);
+  pthread_mutex_unlock(&m_omx_input_mutex);
 
   return OMX_ErrorNone;
 }
 
-OMX_ERRORTYPE COMXCoreComponent::DecoderFillBufferDone(OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer)
+OMX_ERRORTYPE COMXCoreComponent::DecoderFillBufferDone(OMX_HANDLETYPE hComponent, OMX_BUFFERHEADERTYPE* pBuffer)
 {
-  if(!pAppData || m_exit)
+  if(m_exit)
     return OMX_ErrorNone;
 
-  COMXCoreComponent *ctx = static_cast<COMXCoreComponent*>(pAppData);
-
-  pthread_mutex_lock(&ctx->m_omx_output_mutex);
-  ctx->m_omx_output_available.push(pBuffer);
+  #if defined(OMX_DEBUG_EVENTHANDLER)
+  CLog::Log(LOGDEBUG, "COMXCoreComponent::DecoderFillBufferDone component(%s) %p %d/%d\n", m_componentName.c_str(), pBuffer, m_omx_output_available.size(), m_output_buffer_count);
+  #endif
+  pthread_mutex_lock(&m_omx_output_mutex);
+  m_omx_output_available.push(pBuffer);
 
   // this allows (all) blocked tasks to be awoken
-  pthread_cond_broadcast(&ctx->m_output_buffer_cond);
+  pthread_cond_broadcast(&m_output_buffer_cond);
 
-  pthread_mutex_unlock(&ctx->m_omx_output_mutex);
+  pthread_mutex_unlock(&m_omx_output_mutex);
 
   return OMX_ErrorNone;
 }
@@ -1571,20 +1606,26 @@ OMX_ERRORTYPE COMXCoreComponent::DecoderFillBufferDone(OMX_HANDLETYPE hComponent
 // Component event handler -- OMX event callback
 OMX_ERRORTYPE COMXCoreComponent::DecoderEventHandler(
   OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
   OMX_EVENTTYPE eEvent,
   OMX_U32 nData1,
   OMX_U32 nData2,
   OMX_PTR pEventData)
 {
-  COMXCoreComponent *ctx = static_cast<COMXCoreComponent*>(pAppData);
-
 #ifdef OMX_DEBUG_EVENTS
   CLog::Log(LOGDEBUG,
-    "COMXCore::%s - %s eEvent(0x%x), nData1(0x%lx), nData2(0x%lx), pEventData(0x%p)\n",
-    __func__, (char *)ctx->GetName().c_str(), eEvent, nData1, nData2, pEventData);
+    "COMXCoreComponent::%s - %s eEvent(0x%x), nData1(0x%x), nData2(0x%x), pEventData(0x%p)\n",
+    __func__, GetName().c_str(), eEvent, nData1, nData2, pEventData);
 #endif
 
+  // if the error is expected, then we can skip it
+  if (eEvent == OMX_EventError && (OMX_S32)nData1 == m_ignore_error)
+  {
+    CLog::Log(LOGDEBUG,
+      "COMXCoreComponent::%s - %s Ignoring expected event: eEvent(0x%x), nData1(0x%x), nData2(0x%x), pEventData(0x%p)\n",
+      __func__, GetName().c_str(), eEvent, nData1, nData2, pEventData);
+    m_ignore_error = OMX_ErrorNone;
+    return OMX_ErrorNone;
+  }
   AddEvent(eEvent, nData1, nData2);
 
   switch (eEvent)
@@ -1598,86 +1639,91 @@ OMX_ERRORTYPE COMXCoreComponent::DecoderEventHandler(
           {
             case OMX_StateInvalid:
             #if defined(OMX_DEBUG_EVENTHANDLER)
-              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateInvalid\n", CLASSNAME, __func__, ctx->GetName().c_str());
+              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateInvalid\n", CLASSNAME, __func__, GetName().c_str());
             #endif
             break;
             case OMX_StateLoaded:
             #if defined(OMX_DEBUG_EVENTHANDLER)
-              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateLoaded\n", CLASSNAME, __func__, ctx->GetName().c_str());
+              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateLoaded\n", CLASSNAME, __func__, GetName().c_str());
             #endif
             break;
             case OMX_StateIdle:
             #if defined(OMX_DEBUG_EVENTHANDLER)
-              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateIdle\n", CLASSNAME, __func__, ctx->GetName().c_str());
+              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateIdle\n", CLASSNAME, __func__, GetName().c_str());
             #endif
             break;
             case OMX_StateExecuting:
             #if defined(OMX_DEBUG_EVENTHANDLER)
-              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateExecuting\n", CLASSNAME, __func__, ctx->GetName().c_str());
+              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateExecuting\n", CLASSNAME, __func__, GetName().c_str());
             #endif
             break;
             case OMX_StatePause:
             #if defined(OMX_DEBUG_EVENTHANDLER)
-              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StatePause\n", CLASSNAME, __func__, ctx->GetName().c_str());
+              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StatePause\n", CLASSNAME, __func__, GetName().c_str());
             #endif
             break;
             case OMX_StateWaitForResources:
             #if defined(OMX_DEBUG_EVENTHANDLER)
-              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateWaitForResources\n", CLASSNAME, __func__, ctx->GetName().c_str());
+              CLog::Log(LOGDEBUG, "%s::%s %s - OMX_StateWaitForResources\n", CLASSNAME, __func__, GetName().c_str());
             #endif
             break;
             default:
             #if defined(OMX_DEBUG_EVENTHANDLER)
               CLog::Log(LOGDEBUG,
-                "%s::%s %s - Unknown OMX_Statexxxxx, state(%d)\n", CLASSNAME, __func__, ctx->GetName().c_str(), (int)nData2);
+                "%s::%s %s - Unknown OMX_Statexxxxx, state(%d)\n", CLASSNAME, __func__, GetName().c_str(), (int)nData2);
             #endif
             break;
           }
         break;
         case OMX_CommandFlush:
           #if defined(OMX_DEBUG_EVENTHANDLER)
-          CLog::Log(LOGDEBUG, "%s::%s %s - OMX_CommandFlush, port %d\n", CLASSNAME, __func__, ctx->GetName().c_str(), (int)nData2);
+          CLog::Log(LOGDEBUG, "%s::%s %s - OMX_CommandFlush, port %d\n", CLASSNAME, __func__, GetName().c_str(), (int)nData2);
           #endif
         break;
         case OMX_CommandPortDisable:
           #if defined(OMX_DEBUG_EVENTHANDLER)
-          CLog::Log(LOGDEBUG, "%s::%s %s - OMX_CommandPortDisable, nData1(0x%lx), port %d\n", CLASSNAME, __func__, ctx->GetName().c_str(), nData1, (int)nData2);
+          CLog::Log(LOGDEBUG, "%s::%s %s - OMX_CommandPortDisable, nData1(0x%x), port %d\n", CLASSNAME, __func__, GetName().c_str(), nData1, (int)nData2);
           #endif
         break;
         case OMX_CommandPortEnable:
           #if defined(OMX_DEBUG_EVENTHANDLER)
-          CLog::Log(LOGDEBUG, "%s::%s %s - OMX_CommandPortEnable, nData1(0x%lx), port %d\n", CLASSNAME, __func__, ctx->GetName().c_str(), nData1, (int)nData2);
+          CLog::Log(LOGDEBUG, "%s::%s %s - OMX_CommandPortEnable, nData1(0x%x), port %d\n", CLASSNAME, __func__, GetName().c_str(), nData1, (int)nData2);
           #endif
         break;
         #if defined(OMX_DEBUG_EVENTHANDLER)
         case OMX_CommandMarkBuffer:
-          CLog::Log(LOGDEBUG, "%s::%s %s - OMX_CommandMarkBuffer, nData1(0x%lx), port %d\n", CLASSNAME, __func__, ctx->GetName().c_str(), nData1, (int)nData2);
+          CLog::Log(LOGDEBUG, "%s::%s %s - OMX_CommandMarkBuffer, nData1(0x%x), port %d\n", CLASSNAME, __func__, GetName().c_str(), nData1, (int)nData2);
         break;
         #endif
       }
     break;
     case OMX_EventBufferFlag:
       #if defined(OMX_DEBUG_EVENTHANDLER)
-      CLog::Log(LOGDEBUG, "%s::%s %s - OMX_EventBufferFlag(input)\n", CLASSNAME, __func__, ctx->GetName().c_str());
+      CLog::Log(LOGDEBUG, "%s::%s %s - OMX_EventBufferFlag(input)\n", CLASSNAME, __func__, GetName().c_str());
       #endif
       if(nData2 & OMX_BUFFERFLAG_EOS)
       {
-        pthread_mutex_lock(&ctx->m_omx_eos_mutex);
-        ctx->m_eos = true;
-        pthread_mutex_unlock(&ctx->m_omx_eos_mutex);
+        pthread_mutex_lock(&m_omx_eos_mutex);
+        m_eos = true;
+        pthread_mutex_unlock(&m_omx_eos_mutex);
       }
     break;
     case OMX_EventPortSettingsChanged:
       #if defined(OMX_DEBUG_EVENTHANDLER)
-      CLog::Log(LOGDEBUG, "%s::%s %s - OMX_EventPortSettingsChanged(output)\n", CLASSNAME, __func__, ctx->GetName().c_str());
+      CLog::Log(LOGDEBUG, "%s::%s %s - OMX_EventPortSettingsChanged(output)\n", CLASSNAME, __func__, GetName().c_str());
+      #endif
+    break;
+    case OMX_EventParamOrConfigChanged:
+      #if defined(OMX_DEBUG_EVENTHANDLER)
+      CLog::Log(LOGDEBUG, "%s::%s %s - OMX_EventParamOrConfigChanged(output)\n", CLASSNAME, __func__, GetName().c_str());
       #endif
     break;
     #if defined(OMX_DEBUG_EVENTHANDLER)
     case OMX_EventMark:
-      CLog::Log(LOGDEBUG, "%s::%s %s - OMX_EventMark\n", CLASSNAME, __func__, ctx->GetName().c_str());
+      CLog::Log(LOGDEBUG, "%s::%s %s - OMX_EventMark\n", CLASSNAME, __func__, GetName().c_str());
     break;
     case OMX_EventResourcesAcquired:
-      CLog::Log(LOGDEBUG, "%s::%s %s- OMX_EventResourcesAcquired\n", CLASSNAME, __func__, ctx->GetName().c_str());
+      CLog::Log(LOGDEBUG, "%s::%s %s- OMX_EventResourcesAcquired\n", CLASSNAME, __func__, GetName().c_str());
     break;
     #endif
     case OMX_EventError:
@@ -1685,32 +1731,40 @@ OMX_ERRORTYPE COMXCoreComponent::DecoderEventHandler(
       {
         case OMX_ErrorSameState:
           //#if defined(OMX_DEBUG_EVENTHANDLER)
-          //CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorSameState, same state\n", CLASSNAME, __func__, ctx->GetName().c_str());
+          //CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorSameState, same state\n", CLASSNAME, __func__, GetName().c_str());
           //#endif
         break;
         case OMX_ErrorInsufficientResources:
-          CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorInsufficientResources, insufficient resources\n", CLASSNAME, __func__, ctx->GetName().c_str());
-          ctx->m_resource_error = true;
+          CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorInsufficientResources, insufficient resources\n", CLASSNAME, __func__, GetName().c_str());
+          m_resource_error = true;
         break;
         case OMX_ErrorFormatNotDetected:
-          CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorFormatNotDetected, cannot parse input stream\n", CLASSNAME, __func__, ctx->GetName().c_str());
+          CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorFormatNotDetected, cannot parse input stream\n", CLASSNAME, __func__, GetName().c_str());
         break;
         case OMX_ErrorPortUnpopulated:
-          CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorPortUnpopulated port %d, cannot parse input stream\n", CLASSNAME, __func__, ctx->GetName().c_str(), (int)nData2);
+        CLog::Log(LOGWARNING, "%s::%s %s - OMX_ErrorPortUnpopulated port %d\n", CLASSNAME, __func__, GetName().c_str(), (int)nData2);
         break;
         case OMX_ErrorStreamCorrupt:
-          CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorStreamCorrupt, Bitstream corrupt\n", CLASSNAME, __func__, ctx->GetName().c_str());
+          CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorStreamCorrupt, Bitstream corrupt\n", CLASSNAME, __func__, GetName().c_str());
+          m_resource_error = true;
         break;
         case OMX_ErrorUnsupportedSetting:
-          CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorUnsupportedSetting, unsupported setting\n", CLASSNAME, __func__, ctx->GetName().c_str());
+          CLog::Log(LOGERROR, "%s::%s %s - OMX_ErrorUnsupportedSetting, unsupported setting\n", CLASSNAME, __func__, GetName().c_str());
         break;
         default:
-          CLog::Log(LOGERROR, "%s::%s %s - OMX_EventError detected, nData1(0x%x), port %d\n",  CLASSNAME, __func__, ctx->GetName().c_str(), nData1, (int)nData2);
+          CLog::Log(LOGERROR, "%s::%s %s - OMX_EventError detected, nData1(0x%x), port %d\n",  CLASSNAME, __func__, GetName().c_str(), nData1, (int)nData2);
         break;
       }
+      // wake things up
+      if (m_resource_error)
+      {
+        pthread_cond_broadcast(&m_output_buffer_cond);
+        pthread_cond_broadcast(&m_input_buffer_cond);
+        pthread_cond_broadcast(&m_omx_event_cond);
+      }
     break;
     default:
-      CLog::Log(LOGWARNING, "%s::%s %s - Unknown eEvent(0x%x), nData1(0x%x), port %d\n", CLASSNAME, __func__, ctx->GetName().c_str(), eEvent, nData1, (int)nData2);
+      CLog::Log(LOGWARNING, "%s::%s %s - Unknown eEvent(0x%x), nData1(0x%x), port %d\n", CLASSNAME, __func__, GetName().c_str(), eEvent, nData1, (int)nData2);
     break;
   }
 
diff --git a/xbmc/linux/OMXCore.h b/xbmc/linux/OMXCore.h
index 2ce7cde..f345c7b 100644
--- a/xbmc/linux/OMXCore.h
+++ b/xbmc/linux/OMXCore.h
@@ -58,7 +58,6 @@ typedef struct omx_event {
   OMX_U32 nData2;
 } omx_event;
 
-class DllLibOMXCore;
 class COMXCore;
 class COMXCoreComponent;
 class COMXCoreTunel;
@@ -72,20 +71,14 @@ class COMXCoreTunel
 
   void Initialize(COMXCoreComponent *src_component, unsigned int src_port, COMXCoreComponent *dst_component, unsigned int dst_port);
   bool IsInitialized();
-  OMX_ERRORTYPE Flush();
   OMX_ERRORTYPE Deestablish(bool noWait = false);
-  OMX_ERRORTYPE Establish(bool portSettingsChanged, bool enable_ports = true);
+  OMX_ERRORTYPE Establish(bool enable_ports = true, bool disable_ports = false);
 private:
-  pthread_mutex_t   m_lock;
-  bool              m_portSettingsChanged;
   COMXCoreComponent *m_src_component;
   COMXCoreComponent *m_dst_component;
   unsigned int      m_src_port;
   unsigned int      m_dst_port;
   DllOMX            *m_DllOMX;
-  bool              m_DllOMXOpen;
-  void              Lock();
-  void              UnLock();
   bool              m_tunnel_set;
 };
 
@@ -118,7 +111,7 @@ class COMXCoreComponent
 
   bool          Initialize( const std::string &component_name, OMX_INDEXTYPE index);
   bool          IsInitialized();
-  bool          Deinitialize(bool free_component = false);
+  bool          Deinitialize();
 
   // OMXCore Decoder delegate callback routines.
   static OMX_ERRORTYPE DecoderEventHandlerCallback(OMX_HANDLETYPE hComponent, OMX_PTR pAppData,
@@ -129,12 +122,12 @@ class COMXCoreComponent
     OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBufferHeader);
 
   // OMXCore decoder callback routines.
-  OMX_ERRORTYPE DecoderEventHandler(OMX_HANDLETYPE hComponent, OMX_PTR pAppData,
+  OMX_ERRORTYPE DecoderEventHandler(OMX_HANDLETYPE hComponent,
     OMX_EVENTTYPE eEvent, OMX_U32 nData1, OMX_U32 nData2, OMX_PTR pEventData);
   OMX_ERRORTYPE DecoderEmptyBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer);
+    OMX_HANDLETYPE hComponent, OMX_BUFFERHEADERTYPE* pBuffer);
   OMX_ERRORTYPE DecoderFillBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer);
+    OMX_HANDLETYPE hComponent, OMX_BUFFERHEADERTYPE* pBuffer);
 
   void TransitionToStateLoaded();
 
@@ -153,7 +146,7 @@ class COMXCoreComponent
   void FlushOutput();
 
   OMX_BUFFERHEADERTYPE *GetInputBuffer(long timeout=200);
-  OMX_BUFFERHEADERTYPE *GetOutputBuffer();
+  OMX_BUFFERHEADERTYPE *GetOutputBuffer(long timeout=200);
 
   OMX_ERRORTYPE AllocInputBuffers(bool use_buffers = false);
   OMX_ERRORTYPE AllocOutputBuffers(bool use_buffers = false);
@@ -161,9 +154,13 @@ class COMXCoreComponent
   OMX_ERRORTYPE FreeInputBuffers();
   OMX_ERRORTYPE FreeOutputBuffers();
 
+  OMX_ERRORTYPE WaitForInputDone(long timeout=200);
+  OMX_ERRORTYPE WaitForOutputDone(long timeout=200);
+
   bool IsEOS() { return m_eos; };
   bool BadState() { return m_resource_error; };
   void ResetEos();
+  void IgnoreNextError(OMX_S32 error) { m_ignore_error = error; }
 
 private:
   OMX_HANDLETYPE m_handle;
@@ -172,8 +169,8 @@ class COMXCoreComponent
   std::string    m_componentName;
   pthread_mutex_t   m_omx_event_mutex;
   pthread_mutex_t   m_omx_eos_mutex;
-  pthread_mutex_t   m_lock;
   std::vector<omx_event> m_omx_events;
+  OMX_S32 m_ignore_error;
 
   OMX_CALLBACKTYPE  m_callbacks;
 
@@ -197,7 +194,6 @@ class COMXCoreComponent
 
   bool          m_exit;
   DllOMX        *m_DllOMX;
-  bool          m_DllOMXOpen;
   pthread_cond_t    m_input_buffer_cond;
   pthread_cond_t    m_output_buffer_cond;
   pthread_cond_t    m_omx_event_cond;
@@ -205,8 +201,6 @@ class COMXCoreComponent
   bool          m_flush_input;
   bool          m_flush_output;
   bool          m_resource_error;
-  void              Lock();
-  void              UnLock();
 };
 
 class COMXCore
@@ -218,10 +212,10 @@ class COMXCore
   // initialize OMXCore and get decoder component
   bool Initialize();
   void Deinitialize();
+  DllOMX *GetDll() { return m_DllOMX; }
 
 protected:
   bool              m_is_open;
-  bool              m_Initialized;
   DllOMX            *m_DllOMX;
 };
 
diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index ad384db..8958ba0 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -22,6 +22,9 @@
 #if defined(TARGET_RASPBERRY_PI)
 
 #include "utils/log.h"
+#include "settings/AdvancedSettings.h"
+
+#include "cores/omxplayer/OMXImage.h"
 
 CRBP::CRBP()
 {
@@ -50,18 +53,92 @@ bool CRBP::Initialize()
   if(!m_omx_initialized)
     return false;
 
+  char response[80] = "";
+  m_arm_mem = 0;
+  m_gpu_mem = 0;
+  if (vc_gencmd(response, sizeof response, "get_mem arm") == 0)
+    vc_gencmd_number_property(response, "arm", &m_arm_mem);
+  if (vc_gencmd(response, sizeof response, "get_mem gpu") == 0)
+    vc_gencmd_number_property(response, "gpu", &m_gpu_mem);
+
+  if (g_advancedSettings.m_streamSilence)
+    vc_gencmd(response, sizeof response, "force_audio hdmi 1");
+
+  g_OMXImage.Initialize();
+  m_omx_image_init = true;
   return true;
 }
 
 void CRBP::LogFirmwareVerison()
 {
-  char  response[80];
+  char  response[160];
   m_DllBcmHost->vc_gencmd(response, sizeof response, "version");
-  CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s\n", response);
+  response[sizeof(response) - 1] = '\0';
+  CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s", response);
+  CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB", m_arm_mem, m_gpu_mem);
+}
+
+void CRBP::GetDisplaySize(int &width, int &height)
+{
+  DISPMANX_DISPLAY_HANDLE_T display;
+  DISPMANX_MODEINFO_T info;
+
+  display = vc_dispmanx_display_open( 0 /*screen*/ );
+  if (vc_dispmanx_display_get_info(display, &info) == 0)
+  {
+    width = info.width;
+    height = info.height;
+  }
+  else
+  {
+    width = 0;
+    height = 0;
+  }
+  vc_dispmanx_display_close(display );
+}
+
+unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool swap_red_blue, bool video_only)
+{
+  DISPMANX_DISPLAY_HANDLE_T display;
+  DISPMANX_RESOURCE_HANDLE_T resource;
+  VC_RECT_T rect;
+  unsigned char *image = NULL;
+  uint32_t vc_image_ptr;
+  int stride;
+  uint32_t flags = 0;
+
+  if (video_only)
+    flags |= DISPMANX_SNAPSHOT_NO_RGB|DISPMANX_SNAPSHOT_FILL;
+  if (swap_red_blue)
+    flags |= DISPMANX_SNAPSHOT_SWAP_RED_BLUE;
+  if (!pstride)
+    flags |= DISPMANX_SNAPSHOT_PACK;
+
+  display = vc_dispmanx_display_open( 0 /*screen*/ );
+  stride = ((width + 15) & ~15) * 4;
+  image = new unsigned char [height * stride];
+
+  if (image)
+  {
+    resource = vc_dispmanx_resource_create( VC_IMAGE_RGBA32, width, height, &vc_image_ptr );
+
+    vc_dispmanx_snapshot(display, resource, (DISPMANX_TRANSFORM_T)flags);
+
+    vc_dispmanx_rect_set(&rect, 0, 0, width, height);
+    vc_dispmanx_resource_read_data(resource, &rect, image, stride);
+    vc_dispmanx_resource_delete( resource );
+    vc_dispmanx_display_close(display );
+  }
+  if (pstride)
+    *pstride = stride;
+  return image;
 }
 
 void CRBP::Deinitialize()
 {
+  if (m_omx_image_init)
+    g_OMXImage.Deinitialize();
+
   if(m_omx_initialized)
     m_OMX->Deinitialize();
 
@@ -70,6 +147,7 @@ void CRBP::Deinitialize()
   if(m_initialized)
     m_DllBcmHost->Unload();
 
+  m_omx_image_init  = false;
   m_initialized     = false;
   m_omx_initialized = false;
 }
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index 6ef678a..5246f1f 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -47,12 +47,22 @@ class CRBP
   bool Initialize();
   void LogFirmwareVerison();
   void Deinitialize();
+  int GetArmMem() { return m_arm_mem; }
+  int GetGpuMem() { return m_gpu_mem; }
+  void GetDisplaySize(int &width, int &height);
+  // stride can be null for packed output
+  unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
+  DllOMX *GetDllOMX() { return m_OMX ? m_OMX->GetDll() : NULL; }
 
 private:
   DllBcmHost *m_DllBcmHost;
   bool       m_initialized;
   bool       m_omx_initialized;
+  bool       m_omx_image_init;
+  int        m_arm_mem;
+  int        m_gpu_mem;
   COMXCore   *m_OMX;
+  class DllLibOMXCore;
 };
 
 extern CRBP g_RBP;
diff --git a/xbmc/music/tags/MusicInfoTag.cpp b/xbmc/music/tags/MusicInfoTag.cpp
index a63240f..2c242a6 100644
--- a/xbmc/music/tags/MusicInfoTag.cpp
+++ b/xbmc/music/tags/MusicInfoTag.cpp
@@ -593,22 +593,26 @@ void CMusicInfoTag::Serialize(CVariant& value) const
   value["albumid"] = m_iAlbumId;
 }
 
-void CMusicInfoTag::ToSortable(SortItem& sortable)
-{
-  sortable[FieldTitle] = m_strTitle;
-  sortable[FieldArtist] = m_artist;
-  sortable[FieldAlbum] = m_strAlbum;
-  sortable[FieldAlbumArtist] = FieldAlbumArtist;
-  sortable[FieldGenre] = m_genre;
-  sortable[FieldTime] = m_iDuration;
-  sortable[FieldTrackNumber] = m_iTrack;
-  sortable[FieldYear] = m_dwReleaseDate.wYear;
-  sortable[FieldComment] = m_strComment;
-  sortable[FieldRating] = (float)(m_rating - '0');
-  sortable[FieldPlaycount] = m_iTimesPlayed;
-  sortable[FieldLastPlayed] = m_lastPlayed.IsValid() ? m_lastPlayed.GetAsDBDateTime() : StringUtils::EmptyString;
-  sortable[FieldListeners] = m_listeners;
-  sortable[FieldId] = (int64_t)m_iDbId;
+void CMusicInfoTag::ToSortable(SortItem& sortable, Field field) const
+{
+  switch (field)
+  {
+  case FieldTitle:       sortable[FieldTitle] = m_strTitle; break;
+  case FieldArtist:      sortable[FieldArtist] = m_artist; break;
+  case FieldAlbum:       sortable[FieldAlbum] = m_strAlbum; break;
+  case FieldAlbumArtist: sortable[FieldAlbumArtist] = FieldAlbumArtist; break;
+  case FieldGenre:       sortable[FieldGenre] = m_genre; break;
+  case FieldTime:        sortable[FieldTime] = m_iDuration; break;
+  case FieldTrackNumber: sortable[FieldTrackNumber] = m_iTrack; break;
+  case FieldYear:        sortable[FieldYear] = m_dwReleaseDate.wYear; break;
+  case FieldComment:     sortable[FieldComment] = m_strComment; break;
+  case FieldRating:      sortable[FieldRating] = (float)(m_rating - '0'); break;
+  case FieldPlaycount:   sortable[FieldPlaycount] = m_iTimesPlayed; break;
+  case FieldLastPlayed:  sortable[FieldLastPlayed] = m_lastPlayed.IsValid() ? m_lastPlayed.GetAsDBDateTime() : StringUtils::EmptyString; break;
+  case FieldListeners:   sortable[FieldListeners] = m_listeners; break;
+  case FieldId:          sortable[FieldId] = (int64_t)m_iDbId; break;
+  default: break;
+  }
 }
 
 void CMusicInfoTag::Archive(CArchive& ar)
diff --git a/xbmc/music/tags/MusicInfoTag.h b/xbmc/music/tags/MusicInfoTag.h
index d8e1724..15eafa6 100644
--- a/xbmc/music/tags/MusicInfoTag.h
+++ b/xbmc/music/tags/MusicInfoTag.h
@@ -167,7 +167,7 @@ class CMusicInfoTag : public IArchivable, public ISerializable, public ISortable
 
   virtual void Archive(CArchive& ar);
   virtual void Serialize(CVariant& ar) const;
-  virtual void ToSortable(SortItem& sortable);
+  virtual void ToSortable(SortItem& sortable, Field field) const;
 
   void Clear();
 protected:
diff --git a/xbmc/network/AirPlayServer.cpp b/xbmc/network/AirPlayServer.cpp
index 5d857ce..46c8116 100644
--- a/xbmc/network/AirPlayServer.cpp
+++ b/xbmc/network/AirPlayServer.cpp
@@ -121,9 +121,9 @@ const char *eventStrings[] = {"playing", "paused", "loading", "stopped"};
 "<key>deviceid</key>\r\n"\
 "<string>%s</string>\r\n"\
 "<key>features</key>\r\n"\
-"<integer>119</integer>\r\n"\
+"<integer>4294969855</integer>\r\n"\
 "<key>model</key>\r\n"\
-"<string>Xbmc,1</string>\r\n"\
+"<string>AppleTV3,2</string>\r\n"\
 "<key>protovers</key>\r\n"\
 "<string>1.0</string>\r\n"\
 "<key>srcvers</key>\r\n"\
diff --git a/xbmc/network/AirPlayServer.h b/xbmc/network/AirPlayServer.h
index 43e00fe..7b9cf80 100644
--- a/xbmc/network/AirPlayServer.h
+++ b/xbmc/network/AirPlayServer.h
@@ -35,7 +35,7 @@
 
 class DllLibPlist;
 
-#define AIRPLAY_SERVER_VERSION_STR "101.28"
+#define AIRPLAY_SERVER_VERSION_STR "160.10"
 
 class CAirPlayServer : public CThread, public ANNOUNCEMENT::IAnnouncer
 {
diff --git a/xbmc/network/AirTunesServer.cpp b/xbmc/network/AirTunesServer.cpp
index 9908326..d8ac723 100644
--- a/xbmc/network/AirTunesServer.cpp
+++ b/xbmc/network/AirTunesServer.cpp
@@ -521,9 +521,9 @@ bool CAirTunesServer::StartServer(int port, bool nonlocal, bool usePassword, con
     txt.push_back(std::make_pair("pw",  usePassword?"true":"false"));
     txt.push_back(std::make_pair("vn",  "3"));
     txt.push_back(std::make_pair("da",  "true"));
-    txt.push_back(std::make_pair("vs",  "130.14"));
+    txt.push_back(std::make_pair("vs",  "160.10"));
     txt.push_back(std::make_pair("md",  "0,1,2"));
-    txt.push_back(std::make_pair("am",  "Xbmc,1"));
+    txt.push_back(std::make_pair("am",  "AppleTV3,1"));
 
     CZeroconf::GetInstance()->PublishService("servers.airtunes", "_raop._tcp", appName, port, txt);
   }
diff --git a/xbmc/pictures/Picture.cpp b/xbmc/pictures/Picture.cpp
index 957d1e6..7144ae6 100644
--- a/xbmc/pictures/Picture.cpp
+++ b/xbmc/pictures/Picture.cpp
@@ -53,13 +53,8 @@ bool CPicture::CreateThumbnailFromSurface(const unsigned char *buffer, int width
   if (URIUtils::GetExtension(thumbFile).Equals(".jpg"))
   {
 #if defined(HAS_OMXPLAYER)
-    COMXImage *omxImage = new COMXImage();
-    if (omxImage && omxImage->CreateThumbnailFromSurface((BYTE *)buffer, width, height, XB_FMT_A8R8G8B8, stride, thumbFile.c_str()))
-    {
-      delete omxImage;
+    if (COMXImage::CreateThumbnailFromSurface((BYTE *)buffer, width, height, XB_FMT_A8R8G8B8, stride, thumbFile.c_str()))
       return true;
-    }
-    delete omxImage;
 #endif
     CJpegIO jpegImage;
     if (jpegImage.CreateThumbnailFromSurface((BYTE *)buffer, width, height, XB_FMT_A8R8G8B8, stride, thumbFile.c_str()))
@@ -158,7 +153,6 @@ bool CPicture::CreateTiledThumb(const std::vector<std::string> &files, const std
 {
   if (!files.size())
     return false;
-
   unsigned int num_across = (unsigned int)ceil(sqrt((float)files.size()));
   unsigned int num_down = (files.size() + num_across - 1) / num_across;
 
@@ -175,7 +169,8 @@ bool CPicture::CreateTiledThumb(const std::vector<std::string> &files, const std
     int y = i / num_across;
     // load in the image
     unsigned int width = tile_width - 2*tile_gap, height = tile_height - 2*tile_gap;
-    CBaseTexture *texture = CTexture::LoadFromFile(files[i], width, height, g_guiSettings.GetBool("pictures.useexifrotation"));
+    CBaseTexture *texture = CTexture::LoadFromFile(files[i], width, height, g_guiSettings.GetBool("pictures.useexifrotation"), true);
+
     if (texture && texture->GetWidth() && texture->GetHeight())
     {
       GetScale(texture->GetWidth(), texture->GetHeight(), width, height);
diff --git a/xbmc/pictures/PictureInfoTag.cpp b/xbmc/pictures/PictureInfoTag.cpp
index 7fcb5ee..3643616 100644
--- a/xbmc/pictures/PictureInfoTag.cpp
+++ b/xbmc/pictures/PictureInfoTag.cpp
@@ -254,9 +254,9 @@ void CPictureInfoTag::Serialize(CVariant& value) const
   value["transmissionreference"] = CStdString(m_iptcInfo.TransmissionReference);
 }
 
-void CPictureInfoTag::ToSortable(SortItem& sortable)
+void CPictureInfoTag::ToSortable(SortItem& sortable, Field field) const
 {
-  
+
 }
 
 void CPictureInfoTag::GetStringFromArchive(CArchive &ar, char *string, size_t length)
diff --git a/xbmc/pictures/PictureInfoTag.h b/xbmc/pictures/PictureInfoTag.h
index 68760cb..68f6755 100644
--- a/xbmc/pictures/PictureInfoTag.h
+++ b/xbmc/pictures/PictureInfoTag.h
@@ -90,7 +90,7 @@ class CPictureInfoTag : public IArchivable, public ISerializable, public ISortab
   void Reset();
   virtual void Archive(CArchive& ar);
   virtual void Serialize(CVariant& value) const;
-  virtual void ToSortable(SortItem& sortable);
+  virtual void ToSortable(SortItem& sortable, Field field) const;
   const CPictureInfoTag& operator=(const CPictureInfoTag& item);
   const CStdString GetInfo(int info) const;
 
diff --git a/xbmc/pvr/channels/PVRChannel.cpp b/xbmc/pvr/channels/PVRChannel.cpp
index 3e5deb3..e612d23 100644
--- a/xbmc/pvr/channels/PVRChannel.cpp
+++ b/xbmc/pvr/channels/PVRChannel.cpp
@@ -707,10 +707,13 @@ void CPVRChannel::SetCachedChannelNumber(unsigned int iChannelNumber)
   m_iCachedChannelNumber = iChannelNumber;
 }
 
-void CPVRChannel::ToSortable(SortItem& sortable) const
+void CPVRChannel::ToSortable(SortItem& sortable, Field field) const
 {
-  CSingleLock lock(m_critSection);
-  sortable[FieldChannelName] = m_strChannelName;
+  if (field == FieldChannelName)
+  {
+    CSingleLock lock(m_critSection);
+    sortable[FieldChannelName] = m_strChannelName;
+  }
 }
 
 int CPVRChannel::ChannelID(void) const
diff --git a/xbmc/pvr/channels/PVRChannel.h b/xbmc/pvr/channels/PVRChannel.h
index d0abbec..89e9654 100644
--- a/xbmc/pvr/channels/PVRChannel.h
+++ b/xbmc/pvr/channels/PVRChannel.h
@@ -43,7 +43,7 @@ namespace PVR
   typedef boost::shared_ptr<PVR::CPVRChannel> CPVRChannelPtr;
 
   /** PVR Channel class */
-  class CPVRChannel : public Observable, public ISerializable
+  class CPVRChannel : public Observable, public ISerializable, public ISortable
   {
     friend class CPVRDatabase;
     friend class CPVRChannelGroupInternal;
@@ -320,7 +320,7 @@ namespace PVR
      */
     CStdString Path(void) const;
 
-    void ToSortable(SortItem& sortable) const;
+    virtual void ToSortable(SortItem& sortable, Field field) const;
 
     /*!
      * @brief Update the path after the channel number in the internal group changed.
diff --git a/xbmc/rendering/gles/RenderSystemGLES.cpp b/xbmc/rendering/gles/RenderSystemGLES.cpp
index 79dff7d..cdcbc00 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.cpp
+++ b/xbmc/rendering/gles/RenderSystemGLES.cpp
@@ -372,9 +372,7 @@ void CRenderSystemGLES::ApplyStateBlock()
   glActiveTexture(GL_TEXTURE0);
   glEnable(GL_BLEND);
   glEnable(GL_SCISSOR_TEST);  
-#ifndef __PLEX__
   glClear(GL_DEPTH_BUFFER_BIT);
-#endif
 }
 
 void CRenderSystemGLES::SetCameraPosition(const CPoint &camera, int screenWidth, int screenHeight)
@@ -386,22 +384,18 @@ void CRenderSystemGLES::SetCameraPosition(const CPoint &camera, int screenWidth,
   
   CPoint offset = camera - CPoint(screenWidth*0.5f, screenHeight*0.5f);
   
-  GLint viewport[4];
-  glGetIntegerv(GL_VIEWPORT, viewport);
-
-  float w = (float)viewport[2]*0.5f;
-  float h = (float)viewport[3]*0.5f;
+  float w = (float)m_viewPort[2]*0.5f;
+  float h = (float)m_viewPort[3]*0.5f;
 
   g_matrices.MatrixMode(MM_MODELVIEW);
   g_matrices.LoadIdentity();
-  g_matrices.Translatef(-(viewport[0] + w + offset.x), +(viewport[1] + h + offset.y), 0);
+  g_matrices.Translatef(-(m_viewPort[0] + w + offset.x), +(m_viewPort[1] + h + offset.y), 0);
   g_matrices.LookAt(0.0, 0.0, -2.0*h, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0);
   g_matrices.MatrixMode(MM_PROJECTION);
   g_matrices.LoadIdentity();
   g_matrices.Frustum( (-w - offset.x)*0.5f, (w - offset.x)*0.5f, (-h + offset.y)*0.5f, (h + offset.y)*0.5f, h, 100*h);
   g_matrices.MatrixMode(MM_MODELVIEW);
 
-  glGetIntegerv(GL_VIEWPORT, m_viewPort);
   GLfloat* matx;
   matx = g_matrices.GetMatrix(MM_MODELVIEW);
   memcpy(m_view, matx, 16 * sizeof(GLfloat));
@@ -511,14 +505,11 @@ void CRenderSystemGLES::GetViewPort(CRect& viewPort)
 {
   if (!m_bRenderCreated)
     return;
-  
-  GLint glvp[4];
-  glGetIntegerv(GL_VIEWPORT, glvp);
-  
-  viewPort.x1 = glvp[0];
-  viewPort.y1 = m_height - glvp[1] - glvp[3];
-  viewPort.x2 = glvp[0] + glvp[2];
-  viewPort.y2 = viewPort.y1 + glvp[3];
+
+  viewPort.x1 = m_viewPort[0];
+  viewPort.y1 = m_height - m_viewPort[1] - m_viewPort[3];
+  viewPort.x2 = m_viewPort[0] + m_viewPort[2];
+  viewPort.y2 = viewPort.y1 + m_viewPort[3];
 }
 
 // FIXME make me const so that I can accept temporary objects
@@ -529,6 +520,10 @@ void CRenderSystemGLES::SetViewPort(CRect& viewPort)
 
   glScissor((GLint) viewPort.x1, (GLint) (m_height - viewPort.y1 - viewPort.Height()), (GLsizei) viewPort.Width(), (GLsizei) viewPort.Height());
   glViewport((GLint) viewPort.x1, (GLint) (m_height - viewPort.y1 - viewPort.Height()), (GLsizei) viewPort.Width(), (GLsizei) viewPort.Height());
+  m_viewPort[0] = viewPort.x1;
+  m_viewPort[1] = m_height - viewPort.y1 - viewPort.Height();
+  m_viewPort[2] = viewPort.Width();
+  m_viewPort[3] = viewPort.Height();
 }
 
 void CRenderSystemGLES::SetScissors(const CRect &rect)
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 3a55a93..ebd99ee 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -985,8 +985,9 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
   XMLUtils::GetFloat(pRootElement, "controllerdeadzone", m_controllerDeadzone, 0.0f, 1.0f);
   XMLUtils::GetUInt(pRootElement, "fanartres", m_fanartRes, 0, 1080);
   XMLUtils::GetUInt(pRootElement, "imageres", m_imageRes, 0, 1080);
+#if !defined(TARGET_RASPBERRY_PI)
   XMLUtils::GetBoolean(pRootElement, "useddsfanart", m_useDDSFanart);
-
+#endif
   XMLUtils::GetBoolean(pRootElement, "playlistasfolders", m_playlistAsFolders);
   XMLUtils::GetBoolean(pRootElement, "detectasudf", m_detectAsUdf);
 
diff --git a/xbmc/settings/GUISettings.cpp b/xbmc/settings/GUISettings.cpp
index 76ec0cc..d2ba878 100644
--- a/xbmc/settings/GUISettings.cpp
+++ b/xbmc/settings/GUISettings.cpp
@@ -474,6 +474,10 @@ void CGUISettings::Initialize()
   AddBool(ao, "audiooutput.normalizelevels", 346, true);
   AddBool(ao, "audiooutput.stereoupmix", 252, false);
 
+#if defined(TARGET_RASPBERRY_PI)
+  AddBool(ao, "audiooutput.dualaudio", 36042, false);
+  AddBool(ao, "audiooutput.boostcentre", 36043, false);
+#endif
 #if defined(TARGET_DARWIN_IOS)
   CSettingsCategory* aocat = g_sysinfo.IsAppleTV2() ? ao : NULL;
 #else
diff --git a/xbmc/utils/ISortable.h b/xbmc/utils/ISortable.h
index dba4f7d..bdf6935 100644
--- a/xbmc/utils/ISortable.h
+++ b/xbmc/utils/ISortable.h
@@ -27,5 +27,5 @@ class ISortable
 {
 public:
   virtual ~ISortable() { }
-  virtual void ToSortable(SortItem& sortable) = 0;
+  virtual void ToSortable(SortItem& sortable, Field field) const = 0;
 };
diff --git a/xbmc/utils/JobManager.cpp b/xbmc/utils/JobManager.cpp
index 203378d..c387de0 100644
--- a/xbmc/utils/JobManager.cpp
+++ b/xbmc/utils/JobManager.cpp
@@ -430,10 +430,6 @@ void CJobManager::RemoveWorker(const CJobWorker *worker)
 
 unsigned int CJobManager::GetMaxWorkers(CJob::PRIORITY priority) const
 {
-#ifndef __PLEX__
   static const unsigned int max_workers = 5;
-#else
-  static const unsigned int max_workers = 10;
-#endif
   return max_workers - (CJob::PRIORITY_HIGH - priority);
 }
diff --git a/xbmc/utils/Screenshot.cpp b/xbmc/utils/Screenshot.cpp
index a9150cc..0f23f2a 100644
--- a/xbmc/utils/Screenshot.cpp
+++ b/xbmc/utils/Screenshot.cpp
@@ -29,6 +29,10 @@
 #include "windowing/WindowingFactory.h"
 #include "pictures/Picture.h"
 
+#ifdef TARGET_RASPBERRY_PI
+#include "xbmc/linux/RBP.h"
+#endif
+
 #ifdef HAS_VIDEO_PLAYBACK
 #include "cores/VideoRenderers/RenderManager.h"
 #endif
@@ -54,8 +58,12 @@ CScreenshotSurface::CScreenshotSurface()
 
 bool CScreenshotSurface::capture()
 {
-
-#ifdef HAS_DX
+#if defined(TARGET_RASPBERRY_PI)
+  g_RBP.GetDisplaySize(m_width, m_height);
+  m_buffer = g_RBP.CaptureDisplay(m_width, m_height, &m_stride, true, false);
+  if (!m_buffer)
+    return false;
+#elif defined(HAS_DX)
   LPDIRECT3DSURFACE9 lpSurface = NULL, lpBackbuffer = NULL;
   g_graphicsContext.Lock();
   if (g_application.IsPlayingVideo())
diff --git a/xbmc/utils/SortUtils.cpp b/xbmc/utils/SortUtils.cpp
index 1269ba2..2ba49ec 100644
--- a/xbmc/utils/SortUtils.cpp
+++ b/xbmc/utils/SortUtils.cpp
@@ -517,6 +517,26 @@ bool SorterIgnoreFoldersDescending(const SortItem &left, const SortItem &right)
   return StringUtils::AlphaNumericCompare(labelLeft.c_str(), labelRight.c_str()) > 0;
 }
 
+bool SorterIndirectAscending(const SortItemPtr &left, const SortItemPtr &right)
+{
+  return SorterAscending(*left, *right);
+}
+
+bool SorterIndirectDescending(const SortItemPtr &left, const SortItemPtr &right)
+{
+  return SorterDescending(*left, *right);
+}
+
+bool SorterIndirectIgnoreFoldersAscending(const SortItemPtr &left, const SortItemPtr &right)
+{
+  return SorterIgnoreFoldersAscending(*left, *right);
+}
+
+bool SorterIndirectIgnoreFoldersDescending(const SortItemPtr &left, const SortItemPtr &right)
+{
+  return SorterIgnoreFoldersDescending(*left, *right);
+}
+
 map<SortBy, SortUtils::SortPreparator> fillPreparators()
 {
   map<SortBy, SortUtils::SortPreparator> preparators;
@@ -611,6 +631,7 @@ map<SortBy, Fields> fillSortingFields()
   sortingFields[SortByEpisodeNumber].insert(FieldTitle);
   sortingFields[SortByEpisodeNumber].insert(FieldSortTitle);
   sortingFields[SortBySeason].insert(FieldSeason);
+  sortingFields[SortBySeason].insert(FieldSeasonSpecialSort);
   sortingFields[SortByNumberOfEpisodes].insert(FieldNumberOfEpisodes);
   sortingFields[SortByNumberOfWatchedEpisodes].insert(FieldNumberOfWatchedEpisodes);
   sortingFields[SortByTvShowStatus].insert(FieldTvShowStatus);
@@ -642,7 +663,7 @@ map<SortBy, Fields> fillSortingFields()
 map<SortBy, SortUtils::SortPreparator> SortUtils::m_preparators = fillPreparators();
 map<SortBy, Fields> SortUtils::m_sortingFields = fillSortingFields();
 
-void SortUtils::Sort(SortBy sortBy, SortOrder sortOrder, SortAttribute attributes, SortItems& items, int limitEnd /* = -1 */, int limitStart /* = 0 */)
+void SortUtils::Sort(SortBy sortBy, SortOrder sortOrder, SortAttribute attributes, DatabaseResults& items, int limitEnd /* = -1 */, int limitStart /* = 0 */)
 {
   if (sortBy != SortByNone)
   {
@@ -653,7 +674,7 @@ void SortUtils::Sort(SortBy sortBy, SortOrder sortOrder, SortAttribute attribute
       Fields sortingFields = GetFieldsForSorting(sortBy);
 
       // Prepare the string used for sorting and store it under FieldSort
-      for (SortItems::iterator item = items.begin(); item != items.end(); item++)
+      for (DatabaseResults::iterator item = items.begin(); item != items.end(); item++)
       {
         // add all fields to the item that are required for sorting if they are currently missing
         for (Fields::const_iterator field = sortingFields.begin(); field != sortingFields.end(); field++)
@@ -681,6 +702,50 @@ void SortUtils::Sort(SortBy sortBy, SortOrder sortOrder, SortAttribute attribute
     items.erase(items.begin() + limitEnd, items.end());
 }
 
+void SortUtils::Sort(SortBy sortBy, SortOrder sortOrder, SortAttribute attributes, SortItems& items, int limitEnd /* = -1 */, int limitStart /* = 0 */)
+{
+  if (sortBy != SortByNone)
+  {
+    // get the matching SortPreparator
+    SortPreparator preparator = getPreparator(sortBy);
+    if (preparator != NULL)
+    {
+      Fields sortingFields = GetFieldsForSorting(sortBy);
+
+      // Prepare the string used for sorting and store it under FieldSort
+      for (SortItems::iterator item = items.begin(); item != items.end(); item++)
+      {
+        // add all fields to the item that are required for sorting if they are currently missing
+        for (Fields::const_iterator field = sortingFields.begin(); field != sortingFields.end(); field++)
+        {
+          if ((*item)->find(*field) == (*item)->end())
+            (*item)->insert(pair<Field, CVariant>(*field, CVariant::ConstNullVariant));
+        }
+
+        CStdStringW sortLabel;
+        g_charsetConverter.utf8ToW(preparator(attributes, **item), sortLabel, false);
+        (*item)->insert(pair<Field, CVariant>(FieldSort, CVariant(sortLabel)));
+      }
+
+      // Do the sorting
+      std::stable_sort(items.begin(), items.end(), getSorterIndirect(sortOrder, attributes));
+    }
+  }
+
+  if (limitStart > 0 && (size_t)limitStart < items.size())
+  {
+    items.erase(items.begin(), items.begin() + limitStart);
+    limitEnd -= limitStart;
+  }
+  if (limitEnd > 0 && (size_t)limitEnd < items.size())
+    items.erase(items.begin() + limitEnd, items.end());
+}
+
+void SortUtils::Sort(const SortDescription &sortDescription, DatabaseResults& items)
+{
+  Sort(sortDescription.sortBy, sortDescription.sortOrder, sortDescription.sortAttributes, items, sortDescription.limitEnd, sortDescription.limitStart);
+}
+
 void SortUtils::Sort(const SortDescription &sortDescription, SortItems& items)
 {
   Sort(sortDescription.sortBy, sortDescription.sortOrder, sortDescription.sortAttributes, items, sortDescription.limitEnd, sortDescription.limitStart);
@@ -724,6 +789,14 @@ SortUtils::Sorter SortUtils::getSorter(SortOrder sortOrder, SortAttribute attrib
   return sortOrder == SortOrderDescending ? SorterDescending : SorterAscending;
 }
 
+SortUtils::SorterIndirect SortUtils::getSorterIndirect(SortOrder sortOrder, SortAttribute attributes)
+{
+  if (attributes & SortAttributeIgnoreFolders)
+    return sortOrder == SortOrderDescending ? SorterIndirectIgnoreFoldersDescending : SorterIndirectIgnoreFoldersAscending;
+
+  return sortOrder == SortOrderDescending ? SorterIndirectDescending : SorterIndirectAscending;
+}
+
 const Fields& SortUtils::GetFieldsForSorting(SortBy sortBy)
 {
   map<SortBy, Fields>::const_iterator it = m_sortingFields.find(sortBy);
diff --git a/xbmc/utils/SortUtils.h b/xbmc/utils/SortUtils.h
index a096f32..74c91f0 100644
--- a/xbmc/utils/SortUtils.h
+++ b/xbmc/utils/SortUtils.h
@@ -21,6 +21,7 @@
 
 #include <map>
 #include <string>
+#include "boost/shared_ptr.hpp"
 
 #include "DatabaseUtils.h"
 #include "SortFileItem.h"
@@ -105,7 +106,8 @@ typedef struct SortDescription {
 } SortDescription;
 
 typedef DatabaseResult SortItem;
-typedef DatabaseResults SortItems;
+typedef boost::shared_ptr<SortItem> SortItemPtr;
+typedef std::vector<SortItemPtr> SortItems;
 
 class SortUtils
 {
@@ -119,7 +121,9 @@ class SortUtils
    */
   static int GetSortLabel(SortBy sortBy);
 
+  static void Sort(SortBy sortBy, SortOrder sortOrder, SortAttribute attributes, DatabaseResults& items, int limitEnd = -1, int limitStart = 0);
   static void Sort(SortBy sortBy, SortOrder sortOrder, SortAttribute attributes, SortItems& items, int limitEnd = -1, int limitStart = 0);
+  static void Sort(const SortDescription &sortDescription, DatabaseResults& items);
   static void Sort(const SortDescription &sortDescription, SortItems& items);
   static bool SortFromDataset(const SortDescription &sortDescription, MediaType mediaType, const std::auto_ptr<dbiplus::Dataset> &dataset, DatabaseResults &results);
   
@@ -127,11 +131,13 @@ class SortUtils
   static std::string RemoveArticles(const std::string &label);
   
   typedef std::string (*SortPreparator) (SortAttribute, const SortItem&);
-  typedef bool (*Sorter) (const SortItem&, const SortItem&);
+  typedef bool (*Sorter) (const DatabaseResult &, const DatabaseResult &);
+  typedef bool (*SorterIndirect) (const SortItemPtr &, const SortItemPtr &);
   
 private:
   static const SortPreparator& getPreparator(SortBy sortBy);
   static Sorter getSorter(SortOrder sortOrder, SortAttribute attributes);
+  static SorterIndirect getSorterIndirect(SortOrder sortOrder, SortAttribute attributes);
 
   static std::map<SortBy, SortPreparator> m_preparators;
   static std::map<SortBy, Fields> m_sortingFields;
diff --git a/xbmc/video/VideoInfoTag.cpp b/xbmc/video/VideoInfoTag.cpp
index 606f417..62beea8 100644
--- a/xbmc/video/VideoInfoTag.cpp
+++ b/xbmc/video/VideoInfoTag.cpp
@@ -348,9 +348,7 @@ void CVideoInfoTag::Archive(CArchive& ar)
     ar >> m_strPlot;
     ar >> m_strPictureURL.m_spoof;
     ar >> m_strPictureURL.m_xml;
-    m_strPictureURL.Parse();
     ar >> m_fanart.m_xml;
-    m_fanart.Unpack();
     ar >> m_strTitle;
     ar >> m_strSortTitle;
     ar >> m_strVotes;
@@ -358,6 +356,7 @@ void CVideoInfoTag::Archive(CArchive& ar)
     ar >> m_strTrailer;
     int iCastSize;
     ar >> iCastSize;
+    m_cast.reserve(iCastSize);
     for (int i=0;i<iCastSize;++i)
     {
       SActorInfo info;
@@ -486,57 +485,61 @@ void CVideoInfoTag::Serialize(CVariant& value) const
   value["seasonid"] = m_iIdSeason;
 }
 
-void CVideoInfoTag::ToSortable(SortItem& sortable)
+void CVideoInfoTag::ToSortable(SortItem& sortable, Field field) const
 {
-  sortable[FieldDirector] = m_director;
-  sortable[FieldWriter] = m_writingCredits;
-  sortable[FieldGenre] = m_genre;
-  sortable[FieldCountry] = m_country;
-  sortable[FieldTagline] = m_strTagLine;
-  sortable[FieldPlotOutline] = m_strPlotOutline;
-  sortable[FieldPlot] = m_strPlot;
-  sortable[FieldTitle] = m_strTitle;
-  sortable[FieldVotes] = m_strVotes;
-  sortable[FieldStudio] = m_studio;
-  sortable[FieldTrailer] = m_strTrailer;
-  sortable[FieldSet] = m_strSet;
-  sortable[FieldTime] = GetDuration();
-  sortable[FieldFilename] = m_strFile;
-  sortable[FieldMPAA] = m_strMPAARating;
-  sortable[FieldPath] = m_strFileNameAndPath;
-  sortable[FieldSortTitle] = m_strSortTitle;
-  sortable[FieldTvShowStatus] = m_strStatus;
-  sortable[FieldProductionCode] = m_strProductionCode;
-  sortable[FieldAirDate] = m_firstAired.IsValid() ? m_firstAired.GetAsDBDate() : (m_premiered.IsValid() ? m_premiered.GetAsDBDate() : StringUtils::EmptyString);
-  sortable[FieldTvShowTitle] = m_strShowTitle;
-  sortable[FieldAlbum] = m_strAlbum;
-  sortable[FieldArtist] = m_artist;
-  sortable[FieldPlaycount] = m_playCount;
-  sortable[FieldLastPlayed] = m_lastPlayed.IsValid() ? m_lastPlayed.GetAsDBDateTime() : StringUtils::EmptyString;
-  sortable[FieldTop250] = m_iTop250;
-  sortable[FieldYear] = m_iYear;
-  sortable[FieldSeason] = m_iSeason;
-  sortable[FieldEpisodeNumber] = m_iEpisode;
-  sortable[FieldEpisodeNumberSpecialSort] = m_iSpecialSortEpisode;
-  sortable[FieldSeasonSpecialSort] = m_iSpecialSortSeason;
-  sortable[FieldRating] = m_fRating;
-  sortable[FieldId] = m_iDbId;
-  sortable[FieldTrackNumber] = m_iTrack;
-  sortable[FieldTag] = m_tags;
-
-  sortable[FieldVideoResolution] = m_streamDetails.GetVideoHeight();
-  sortable[FieldVideoAspectRatio] = m_streamDetails.GetVideoAspect();
-  sortable[FieldVideoCodec] = m_streamDetails.GetVideoCodec();
-  
-  sortable[FieldAudioChannels] = m_streamDetails.GetAudioChannels();
-  sortable[FieldAudioCodec] = m_streamDetails.GetAudioCodec();
-  sortable[FieldAudioLanguage] = m_streamDetails.GetAudioLanguage();
-  
-  sortable[FieldSubtitleLanguage] = m_streamDetails.GetSubtitleLanguage();
-
-  sortable[FieldInProgress] = m_resumePoint.IsPartWay();
-  sortable[FieldDateAdded] = m_dateAdded.IsValid() ? m_dateAdded.GetAsDBDateTime() : StringUtils::EmptyString;
-  sortable[FieldMediaType] = DatabaseUtils::MediaTypeFromString(m_type);
+  switch (field)
+  {
+  case FieldDirector:                 sortable[FieldDirector] = m_director; break;
+  case FieldWriter:                   sortable[FieldWriter] = m_writingCredits; break;
+  case FieldGenre:                    sortable[FieldGenre] = m_genre; break;
+  case FieldCountry:                  sortable[FieldCountry] = m_country; break;
+  case FieldTagline:                  sortable[FieldTagline] = m_strTagLine; break;
+  case FieldPlotOutline:              sortable[FieldPlotOutline] = m_strPlotOutline; break;
+  case FieldPlot:                     sortable[FieldPlot] = m_strPlot; break;
+  case FieldTitle:                    sortable[FieldTitle] = m_strTitle; break;
+  case FieldVotes:                    sortable[FieldVotes] = m_strVotes; break;
+  case FieldStudio:                   sortable[FieldStudio] = m_studio; break;
+  case FieldTrailer:                  sortable[FieldTrailer] = m_strTrailer; break;
+  case FieldSet:                      sortable[FieldSet] = m_strSet; break;
+  case FieldTime:                     sortable[FieldTime] = GetDuration(); break;
+  case FieldFilename:                 sortable[FieldFilename] = m_strFile; break;
+  case FieldMPAA:                     sortable[FieldMPAA] = m_strMPAARating; break;
+  case FieldPath:                     sortable[FieldPath] = m_strFileNameAndPath; break;
+  case FieldSortTitle:                sortable[FieldSortTitle] = m_strSortTitle; break;
+  case FieldTvShowStatus:             sortable[FieldTvShowStatus] = m_strStatus; break;
+  case FieldProductionCode:           sortable[FieldProductionCode] = m_strProductionCode; break;
+  case FieldAirDate:                  sortable[FieldAirDate] = m_firstAired.IsValid() ? m_firstAired.GetAsDBDate() : (m_premiered.IsValid() ? m_premiered.GetAsDBDate() : StringUtils::EmptyString); break;
+  case FieldTvShowTitle:              sortable[FieldTvShowTitle] = m_strShowTitle; break;
+  case FieldAlbum:                    sortable[FieldAlbum] = m_strAlbum; break;
+  case FieldArtist:                   sortable[FieldArtist] = m_artist; break;
+  case FieldPlaycount:                sortable[FieldPlaycount] = m_playCount; break;
+  case FieldLastPlayed:               sortable[FieldLastPlayed] = m_lastPlayed.IsValid() ? m_lastPlayed.GetAsDBDateTime() : StringUtils::EmptyString; break;
+  case FieldTop250:                   sortable[FieldTop250] = m_iTop250; break;
+  case FieldYear:                     sortable[FieldYear] = m_iYear; break;
+  case FieldSeason:                   sortable[FieldSeason] = m_iSeason; break;
+  case FieldEpisodeNumber:            sortable[FieldEpisodeNumber] = m_iEpisode; break;
+  case FieldEpisodeNumberSpecialSort: sortable[FieldEpisodeNumberSpecialSort] = m_iSpecialSortEpisode; break;
+  case FieldSeasonSpecialSort:        sortable[FieldSeasonSpecialSort] = m_iSpecialSortSeason; break;
+  case FieldRating:                   sortable[FieldRating] = m_fRating; break;
+  case FieldId:                       sortable[FieldId] = m_iDbId; break;
+  case FieldTrackNumber:              sortable[FieldTrackNumber] = m_iTrack; break;
+  case FieldTag:                      sortable[FieldTag] = m_tags; break;
+
+  case FieldVideoResolution:          sortable[FieldVideoResolution] = m_streamDetails.GetVideoHeight(); break;
+  case FieldVideoAspectRatio:         sortable[FieldVideoAspectRatio] = m_streamDetails.GetVideoAspect(); break;
+  case FieldVideoCodec:               sortable[FieldVideoCodec] = m_streamDetails.GetVideoCodec(); break;
+
+  case FieldAudioChannels:            sortable[FieldAudioChannels] = m_streamDetails.GetAudioChannels(); break;
+  case FieldAudioCodec:               sortable[FieldAudioCodec] = m_streamDetails.GetAudioCodec(); break;
+  case FieldAudioLanguage:            sortable[FieldAudioLanguage] = m_streamDetails.GetAudioLanguage(); break;
+
+  case FieldSubtitleLanguage:         sortable[FieldSubtitleLanguage] = m_streamDetails.GetSubtitleLanguage(); break;
+
+  case FieldInProgress:               sortable[FieldInProgress] = m_resumePoint.IsPartWay(); break;
+  case FieldDateAdded:                sortable[FieldDateAdded] = m_dateAdded.IsValid() ? m_dateAdded.GetAsDBDateTime() : StringUtils::EmptyString; break;
+  case FieldMediaType:                sortable[FieldMediaType] = DatabaseUtils::MediaTypeFromString(m_type); break;
+  default: break;
+  }
 }
 
 const CStdString CVideoInfoTag::GetCast(bool bIncludeRole /*= false*/) const
diff --git a/xbmc/video/VideoInfoTag.h b/xbmc/video/VideoInfoTag.h
index d97cc15..122ef21 100644
--- a/xbmc/video/VideoInfoTag.h
+++ b/xbmc/video/VideoInfoTag.h
@@ -65,7 +65,7 @@ class CVideoInfoTag : public IArchivable, public ISerializable, public ISortable
   bool Save(TiXmlNode *node, const CStdString &tag, bool savePathInfo = true, const TiXmlElement *additionalNode = NULL);
   virtual void Archive(CArchive& ar);
   virtual void Serialize(CVariant& value) const;
-  virtual void ToSortable(SortItem& sortable);
+  virtual void ToSortable(SortItem& sortable, Field field) const;
   const CStdString GetCast(bool bIncludeRole = false) const;
   bool HasStreamDetails() const;
   bool IsEmpty() const;
diff --git a/xbmc/video/windows/GUIWindowFullScreen.cpp b/xbmc/video/windows/GUIWindowFullScreen.cpp
index e51764f..9f97843 100644
--- a/xbmc/video/windows/GUIWindowFullScreen.cpp
+++ b/xbmc/video/windows/GUIWindowFullScreen.cpp
@@ -123,6 +123,7 @@ CGUIWindowFullScreen::CGUIWindowFullScreen(void)
   // subtitles
   //  - delay
   //  - language
+
 }
 
 CGUIWindowFullScreen::~CGUIWindowFullScreen(void)
@@ -165,12 +166,11 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
 
   case ACTION_PLAYER_PLAY:
   case ACTION_PAUSE:
-      if (m_timeCodePosition > 0)
-      {
-        SeekToTimeCodeStamp(SEEK_ABSOLUTE);
-        return true;
-      }
-//      return true;
+    if (m_timeCodePosition > 0)
+    {
+      SeekToTimeCodeStamp(SEEK_ABSOLUTE);
+      return true;
+    }
     break;
 
   case ACTION_STEP_BACK:
diff --git a/xbmc/windowing/egl/WinSystemEGL.h b/xbmc/windowing/egl/WinSystemEGL.h
index fae528c..aec1ff3 100644
--- a/xbmc/windowing/egl/WinSystemEGL.h
+++ b/xbmc/windowing/egl/WinSystemEGL.h
@@ -58,13 +58,15 @@ class CWinSystemEGL : public CWinSystemBase, public CRenderSystemGLES
   virtual bool  Support3D(int width, int height, uint32_t mode)     const;
   virtual bool  ClampToGUIDisplayLimits(int &width, int &height);
 
+  EGLConfig     GetEGLConfig();
+
+  EGLDisplay    GetEGLDisplay();
+  EGLContext    GetEGLContext();
 protected:
   virtual bool  PresentRenderImpl(const CDirtyRegionList &dirty);
   virtual void  SetVSyncImpl(bool enable);
 
   bool          CreateWindow(RESOLUTION_INFO &res);
-  EGLDisplay    GetEGLDisplay();
-  EGLContext    GetEGLContext();
 
   int                   m_displayWidth;
   int                   m_displayHeight;

From ee62ade259a761ee8f933be6b65c9705dc8015b5 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 11:23:14 +0100
Subject: [PATCH 18/38] Use omximage for jpeg textures

---
 plex/Utility/PlexJobs.cpp         | 16 ++++++++++++++++
 xbmc/cores/omxplayer/OMXImage.cpp |  4 ++--
 2 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/plex/Utility/PlexJobs.cpp b/plex/Utility/PlexJobs.cpp
index 7ffaebe..e745f82 100644
--- a/plex/Utility/PlexJobs.cpp
+++ b/plex/Utility/PlexJobs.cpp
@@ -19,6 +19,9 @@
 #include "Stopwatch.h"
 #include "PlexUtils.h"
 #include "xbmc/Util.h"
+#if defined(HAS_OMXPLAYER)
+#include "cores/omxplayer/OMXImage.h"
+#endif
 
 ////////////////////////////////////////////////////////////////////////////////
 bool CPlexHTTPFetchJob::DoWork()
@@ -233,6 +236,19 @@ bool CPlexTextureCacheJob::CacheTexture(CBaseTexture **texture)
   else if (m_details.hash == m_oldHash)
     return true;
 
+#if defined(HAS_OMXPLAYER)
+  if (COMXImage::CreateThumb(image, width, height, additional_info, CTextureCache::GetCachedPath(m_cachePath + ".jpg")))
+  {
+    m_details.width = width;
+    m_details.height = height;
+    m_details.file = m_cachePath + ".jpg";
+    if (texture)
+      *texture = CTextureCacheJob::LoadImage(CTextureCache::GetCachedPath(m_details.file), width, height, additional_info);
+    CLog::Log(LOGDEBUG, "Fast %s image '%s' to '%s': %p", m_oldHash.IsEmpty() ? "Caching" : "Recaching", image.c_str(), m_details.file.c_str(), texture);
+    return true;
+  }
+#endif
+
   int bytesRead, bufferSize = 131072;
   unsigned char buffer[131072];
   bool outputFileOpenned = false;
diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index 44d08af..e6d1c50 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -180,7 +180,7 @@ bool COMXImage::CreateThumb(const CStdString& srcFile, unsigned int maxHeight, u
   COMXImageReEnc reenc;
   void *pDestBuffer;
   unsigned int nDestSize;
-  if ((URIUtils::GetExtension(srcFile).Equals(".jpg") || URIUtils::GetExtension(srcFile).Equals(".tbn")) &&
+  if ((srcFile.substr(0, 13) == "plexserver://" || URIUtils::GetExtension(srcFile).Equals(".jpg") || URIUtils::GetExtension(srcFile).Equals(".tbn")) &&
       file.ReadFile(srcFile) && reenc.ReEncode(file, maxWidth, maxHeight, pDestBuffer, nDestSize))
   {
     XFILE::CFile outfile;
@@ -836,7 +836,7 @@ bool COMXImageFile::ReadFile(const CStdString& inputFile)
 {
   XFILE::CFile      m_pFile;
   m_filename = inputFile.c_str();
-  if(!m_pFile.Open(inputFile, 0))
+  if(!m_pFile.Open(inputFile, READ_NO_CACHE))
   {
     CLog::Log(LOGERROR, "%s::%s %s not found\n", CLASSNAME, __func__, inputFile.c_str());
     return false;

From d3c4ed8658c6390c054a7156413d227b87d980c5 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 11:28:02 +0100
Subject: [PATCH 19/38] Run blocking jobs in high priority

---
 plex/Utility/PlexBusyIndicator.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/plex/Utility/PlexBusyIndicator.cpp b/plex/Utility/PlexBusyIndicator.cpp
index 0d573c1..3e4ba75 100644
--- a/plex/Utility/PlexBusyIndicator.cpp
+++ b/plex/Utility/PlexBusyIndicator.cpp
@@ -17,7 +17,7 @@ bool CPlexBusyIndicator::blockWaitingForJob(CJob* job, IJobCallback* callback, C
 {
   CSingleLock lk(m_section);
   m_blockEvent.Reset();
-  int id = CJobManager::GetInstance().AddJob(job, this);
+  int id = CJobManager::GetInstance().AddJob(job, this, CJob::PRIORITY_HIGH);
 
   m_callbackMap[id] = callback;
   m_resultMap[id] = result;

From f3659a2082384bbd3c61691157b2ff8f195aa0a8 Mon Sep 17 00:00:00 2001
From: Karlson2k <k2k@narod.ru>
Date: Sun, 18 Aug 2013 00:40:37 +0400
Subject: [PATCH 20/38] CurlFile: don't set 'keep-alive' as cURL do this
 internally Some web servers can't properly handle duplicated header value.

---
 xbmc/filesystem/CurlFile.cpp | 2 --
 1 file changed, 2 deletions(-)

diff --git a/xbmc/filesystem/CurlFile.cpp b/xbmc/filesystem/CurlFile.cpp
index 348efc4..799bd79 100644
--- a/xbmc/filesystem/CurlFile.cpp
+++ b/xbmc/filesystem/CurlFile.cpp
@@ -586,8 +586,6 @@ void CCurlFile::SetCommonOptions(CReadState* state)
 
   if (m_useOldHttpVersion)
     g_curlInterface.easy_setopt(h, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);
-  else
-    SetRequestHeader("Connection", "keep-alive");
 
   if (g_advancedSettings.m_curlDisableIPV6)
     g_curlInterface.easy_setopt(h, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);

From e6625a1981a5df38fc5c97baa95428807aeda445 Mon Sep 17 00:00:00 2001
From: Karlson2k <k2k@narod.ru>
Date: Sun, 18 Aug 2013 16:55:52 +0400
Subject: [PATCH 21/38] CurlFile: request UTF-8 as preferable charset

---
 xbmc/filesystem/CurlFile.cpp | 6 ++++++
 xbmc/filesystem/CurlFile.h   | 2 ++
 2 files changed, 8 insertions(+)

diff --git a/xbmc/filesystem/CurlFile.cpp b/xbmc/filesystem/CurlFile.cpp
index 799bd79..093afe9 100644
--- a/xbmc/filesystem/CurlFile.cpp
+++ b/xbmc/filesystem/CurlFile.cpp
@@ -385,6 +385,7 @@ CCurlFile::CCurlFile()
   m_state = new CReadState();
   m_skipshout = false;
   m_httpresponse = -1;
+  m_acceptCharset = "UTF-8,*;q=0.8"; /* prefer UTF-8 if available */
 
   /* PLEX */
   m_clearCookies = false;
@@ -579,6 +580,9 @@ void CCurlFile::SetCommonOptions(CReadState* state)
   if( m_contentencoding.length() > 0 )
     g_curlInterface.easy_setopt(h, CURLOPT_ENCODING, m_contentencoding.c_str());
 
+  if (!m_useOldHttpVersion && !m_acceptCharset.empty())
+    SetRequestHeader("Accept-Charset", m_acceptCharset);
+
   if (m_userAgent.length() > 0)
     g_curlInterface.easy_setopt(h, CURLOPT_USERAGENT, m_userAgent.c_str());
   else /* set some default agent as shoutcast doesn't return proper stuff otherwise */
@@ -819,6 +823,8 @@ void CCurlFile::ParseAndCorrectUrl(CURL &url2)
           SetContentEncoding(value);
         else if (name.Equals("noshout") && value.Equals("true"))
           m_skipshout = true;
+        else if (name.Equals("Accept-Charset"))
+          SetAcceptCharset(value);
         else
           SetRequestHeader(name, value);
       }
diff --git a/xbmc/filesystem/CurlFile.h b/xbmc/filesystem/CurlFile.h
index 31522fa..e70b637 100644
--- a/xbmc/filesystem/CurlFile.h
+++ b/xbmc/filesystem/CurlFile.h
@@ -69,6 +69,7 @@ namespace XFILE
       void SetCustomRequest(CStdString &request)                 { m_customrequest = request; }
       void UseOldHttpVersion(bool bUse)                          { m_useOldHttpVersion = bUse; }
       void SetContentEncoding(CStdString encoding)               { m_contentencoding = encoding; }
+      void SetAcceptCharset(const std::string& charset)          { m_acceptCharset = charset; }
       void SetTimeout(int connecttimeout)                        { m_connecttimeout = connecttimeout; }
       void SetLowSpeedTime(int lowspeedtime)                     { m_lowspeedtime = lowspeedtime; }
       void SetPostData(CStdString postdata)                      { m_postdata = postdata; }
@@ -170,6 +171,7 @@ namespace XFILE
       CStdString      m_proxyuserpass;
       CStdString      m_customrequest;
       CStdString      m_contentencoding;
+      std::string     m_acceptCharset;
       CStdString      m_ftpauth;
       CStdString      m_ftpport;
       CStdString      m_binary;

From 7cd791154bb55eda14d88441c76e4f23c1f6b9f5 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 9 Nov 2014 13:53:34 +0000
Subject: [PATCH 22/38] Avoid busy spinning when socket timeout is too low

This is an RFC as I don't know this code well, but my investigation may provoke a better fix.
See: http://forum.kodi.tv/showthread.php?tid=201797&pid=1771808#pid1771808

Summary: when streaming audio through http the cpu usage starts low and creeps higher and higher.

For first minute, the CPU usage of FileCache thread is a few percent.
As time goes by the cpu usage for this thread increases until it hits about 60% and we start stuttering.

Disabling the filecache (buffermode=3) avoids the high cpu issue.

I've tracked down where the cpu is occurring.
CCurlFile::CReadState::FillBuffer is called with want=1.
After a while, g_curlInterface.multi_timeout returns smaller and smaller timeouts,
until it it just returning 0 and 1 for timeout. This results in busy spinning in this function.
The small timeouts mean small amounts of data are read and so FillBuffer gets called more often.

My fix just ensures the timeout is never less than 200ms.
Now stream plays for a long time without stuttering and FileCache thread remains at about 1% CPU.
---
 xbmc/filesystem/CurlFile.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/filesystem/CurlFile.cpp b/xbmc/filesystem/CurlFile.cpp
index 093afe9..c67ce00 100644
--- a/xbmc/filesystem/CurlFile.cpp
+++ b/xbmc/filesystem/CurlFile.cpp
@@ -1496,7 +1496,7 @@ bool CCurlFile::CReadState::FillBuffer(unsigned int want)
         g_curlInterface.multi_fdset(m_multiHandle, &fdread, &fdwrite, &fdexcep, &maxfd);
 
         long timeout = 0;
-        if (CURLM_OK != g_curlInterface.multi_timeout(m_multiHandle, &timeout) || timeout == -1)
+        if (CURLM_OK != g_curlInterface.multi_timeout(m_multiHandle, &timeout) || timeout == -1 || timeout < 200)
           timeout = 200;
 
         struct timeval t = { timeout / 1000, (timeout % 1000) * 1000 };

From 61209314f2a3ce2adf6e51c91846eafa955ae3fc Mon Sep 17 00:00:00 2001
From: davilla <davilla@4pi.com>
Date: Wed, 27 Feb 2013 11:08:45 -0500
Subject: [PATCH 23/38] fix compiler warning

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index f2532d1..1ea4fac 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -1360,7 +1360,7 @@ bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
   // OpenGLES returns in RGBA order but CRenderCapture needs BGRA order
   // XOR Swap RGBA -> BGRA
   unsigned char* pixels = (unsigned char*)capture->GetRenderBuffer();
-  for (int i = 0; i < capture->GetWidth() * capture->GetHeight(); i++, pixels+=4)
+  for (unsigned int i = 0; i < capture->GetWidth() * capture->GetHeight(); i++, pixels+=4)
   {
     std::swap(pixels[0], pixels[2]);
   }

From 83cd15add2eec6a645c56460448324da7fbb6791 Mon Sep 17 00:00:00 2001
From: davilla <davilla@4pi.com>
Date: Wed, 27 Feb 2013 11:10:16 -0500
Subject: [PATCH 24/38] fixed, m_iVSyncMode var in two places with different
 type, opps. pick one, please

---
 xbmc/windowing/egl/WinSystemEGL.cpp | 9 ++++++---
 xbmc/windowing/egl/WinSystemEGL.h   | 1 -
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/xbmc/windowing/egl/WinSystemEGL.cpp b/xbmc/windowing/egl/WinSystemEGL.cpp
index 481a2a5..60adab5 100644
--- a/xbmc/windowing/egl/WinSystemEGL.cpp
+++ b/xbmc/windowing/egl/WinSystemEGL.cpp
@@ -45,7 +45,7 @@ CWinSystemEGL::CWinSystemEGL() : CWinSystemBase()
   m_config            = NULL;
 
   m_egl               = NULL;
-  m_iVSyncMode        = false;
+  m_iVSyncMode        = 0;
 }
 
 CWinSystemEGL::~CWinSystemEGL()
@@ -400,9 +400,12 @@ bool CWinSystemEGL::PresentRenderImpl(const CDirtyRegionList &dirty)
 
 void CWinSystemEGL::SetVSyncImpl(bool enable)
 {
-  m_iVSyncMode = enable;
-  if (!m_egl->SetVSync(m_display, m_iVSyncMode))
+  m_iVSyncMode = enable ? 10:0;
+  if (!m_egl->SetVSync(m_display, enable))
+  {
+    m_iVSyncMode = 0;
     CLog::Log(LOGERROR, "%s,Could not set egl vsync", __FUNCTION__);
+  }
 }
 
 void CWinSystemEGL::ShowOSMouse(bool show)
diff --git a/xbmc/windowing/egl/WinSystemEGL.h b/xbmc/windowing/egl/WinSystemEGL.h
index aec1ff3..beacf3e 100644
--- a/xbmc/windowing/egl/WinSystemEGL.h
+++ b/xbmc/windowing/egl/WinSystemEGL.h
@@ -77,7 +77,6 @@ class CWinSystemEGL : public CWinSystemBase, public CRenderSystemGLES
   EGLConfig             m_config;
 
   CEGLWrapper           *m_egl;
-  bool                  m_iVSyncMode;
   std::string           m_extensions;
 };
 

From b403836f876285ba901d48f17e98615239bca102 Mon Sep 17 00:00:00 2001
From: Lars Op den Kamp <lars@opdenkamp.eu>
Date: Mon, 11 Mar 2013 00:55:45 +0100
Subject: [PATCH 25/38] removed dupe methods. if we really need that Sleep(),
 do it in CPeripherals instead

---
 xbmc/peripherals/Peripherals.cpp                  |  6 ++---
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 29 +----------------------
 xbmc/peripherals/devices/PeripheralCecAdapter.h   |  5 +---
 3 files changed, 5 insertions(+), 35 deletions(-)

diff --git a/xbmc/peripherals/Peripherals.cpp b/xbmc/peripherals/Peripherals.cpp
index c5fadd9..d246bc4 100644
--- a/xbmc/peripherals/Peripherals.cpp
+++ b/xbmc/peripherals/Peripherals.cpp
@@ -606,9 +606,9 @@ bool CPeripherals::OnAction(const CAction &action)
         if (cecDevice && cecDevice->HasConnectedAudioSystem())
         {
           if (action.GetID() == ACTION_VOLUME_UP)
-            cecDevice->ScheduleVolumeUp();
+            cecDevice->VolumeUp();
           else
-            cecDevice->ScheduleVolumeDown();
+            cecDevice->VolumeDown();
           return true;
         }
       }
@@ -644,7 +644,7 @@ bool CPeripherals::ToggleMute(void)
       CPeripheralCecAdapter *cecDevice = (CPeripheralCecAdapter *) peripherals.at(iPeripheralPtr);
       if (cecDevice && cecDevice->HasConnectedAudioSystem())
       {
-        cecDevice->ScheduleMute();
+        cecDevice->ToggleMute();
         return true;
       }
     }
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 23c56c4..7dd6316 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -449,33 +449,6 @@ void CPeripheralCecAdapter::SetAudioSystemConnected(bool bSetTo)
   m_bHasConnectedAudioSystem = bSetTo;
 }
 
-void CPeripheralCecAdapter::ScheduleVolumeUp(void)
-{
-  {
-    CSingleLock lock(m_critSection);
-    m_volumeChangeQueue.push(VOLUME_CHANGE_UP);
-  }
-  Sleep(5);
-}
-
-void CPeripheralCecAdapter::ScheduleVolumeDown(void)
-{
-  {
-    CSingleLock lock(m_critSection);
-    m_volumeChangeQueue.push(VOLUME_CHANGE_DOWN);
-  }
-  Sleep(5);
-}
-
-void CPeripheralCecAdapter::ScheduleMute(void)
-{
-  {
-    CSingleLock lock(m_critSection);
-    m_volumeChangeQueue.push(VOLUME_CHANGE_MUTE);
-  }
-  Sleep(5);
-}
-
 void CPeripheralCecAdapter::ProcessVolumeChange(void)
 {
   bool bSendRelease(false);
@@ -558,7 +531,7 @@ void CPeripheralCecAdapter::VolumeDown(void)
   }
 }
 
-void CPeripheralCecAdapter::Mute(void)
+void CPeripheralCecAdapter::ToggleMute(void)
 {
   if (HasConnectedAudioSystem())
   {
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.h b/xbmc/peripherals/devices/PeripheralCecAdapter.h
index c681e60..c3a7ad1 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.h
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.h
@@ -92,12 +92,9 @@ namespace PERIPHERALS
     void Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data);
     bool HasConnectedAudioSystem(void);
     void SetAudioSystemConnected(bool bSetTo);
-    void ScheduleVolumeUp(void);
     void VolumeUp(void);
-    void ScheduleVolumeDown(void);
     void VolumeDown(void);
-    void ScheduleMute(void);
-    void Mute(void);
+    void ToggleMute(void);
     bool IsMuted(void);
 
     void OnSettingChanged(const CStdString &strChangedSetting);

From f9ce65d315b2ce9c595f58519c7644e42b85b561 Mon Sep 17 00:00:00 2001
From: Lars Op den Kamp <lars@opdenkamp.eu>
Date: Mon, 11 Mar 2013 00:57:40 +0100
Subject: [PATCH 26/38] removed no longer used TranslateComPort()

---
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 13 -------------
 xbmc/peripherals/devices/PeripheralCecAdapter.h   |  2 --
 2 files changed, 15 deletions(-)

diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 7dd6316..1dc8413 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -1188,19 +1188,6 @@ int CPeripheralCecAdapter::CecLogMessage(void *cbParam, const cec_log_message me
   return 1;
 }
 
-bool CPeripheralCecAdapter::TranslateComPort(CStdString &strLocation)
-{
-  if ((strLocation.Left(18).Equals("peripherals://cec/")) &&
-       strLocation.Right(4).Equals(".dev"))
-  {
-    strLocation = strLocation.Right(strLocation.length() - 18);
-    strLocation = strLocation.Left(strLocation.length() - 4);
-    return true;
-  }
-
-  return false;
-}
-
 void CPeripheralCecAdapter::SetConfigurationFromLibCEC(const CEC::libcec_configuration &config)
 {
   bool bChanged(false);
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.h b/xbmc/peripherals/devices/PeripheralCecAdapter.h
index c3a7ad1..87f543b 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.h
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.h
@@ -134,8 +134,6 @@ namespace PERIPHERALS
     void Process(void);
     void ProcessVolumeChange(void);
     void SetMenuLanguage(const char *strLanguage);
-    static bool FindConfigLocation(CStdString &strString);
-    static bool TranslateComPort(CStdString &strPort);
 
     void ResetMembers(void);
 

From 8351421039e7c00d2ee1da87a37a988c22b7c86d Mon Sep 17 00:00:00 2001
From: Lars Op den Kamp <lars@opdenkamp.eu>
Date: Mon, 11 Mar 2013 01:03:13 +0100
Subject: [PATCH 27/38] cosmetics. made some methods private that don't need to
 be public

---
 xbmc/peripherals/Peripherals.cpp                  |  4 +-
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 10 ++---
 xbmc/peripherals/devices/PeripheralCecAdapter.h   | 48 ++++++++++++++---------
 3 files changed, 36 insertions(+), 26 deletions(-)

diff --git a/xbmc/peripherals/Peripherals.cpp b/xbmc/peripherals/Peripherals.cpp
index d246bc4..b73f98f 100644
--- a/xbmc/peripherals/Peripherals.cpp
+++ b/xbmc/peripherals/Peripherals.cpp
@@ -603,7 +603,7 @@ bool CPeripherals::OnAction(const CAction &action)
       for (unsigned int iPeripheralPtr = 0; iPeripheralPtr < peripherals.size(); iPeripheralPtr++)
       {
         CPeripheralCecAdapter *cecDevice = (CPeripheralCecAdapter *) peripherals.at(iPeripheralPtr);
-        if (cecDevice && cecDevice->HasConnectedAudioSystem())
+        if (cecDevice && cecDevice->HasAudioControl())
         {
           if (action.GetID() == ACTION_VOLUME_UP)
             cecDevice->VolumeUp();
@@ -642,7 +642,7 @@ bool CPeripherals::ToggleMute(void)
     for (unsigned int iPeripheralPtr = 0; iPeripheralPtr < peripherals.size(); iPeripheralPtr++)
     {
       CPeripheralCecAdapter *cecDevice = (CPeripheralCecAdapter *) peripherals.at(iPeripheralPtr);
-      if (cecDevice && cecDevice->HasConnectedAudioSystem())
+      if (cecDevice && cecDevice->HasAudioControl())
       {
         cecDevice->ToggleMute();
         return true;
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 1dc8413..70d98e6 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -437,7 +437,7 @@ void CPeripheralCecAdapter::Process(void)
   }
 }
 
-bool CPeripheralCecAdapter::HasConnectedAudioSystem(void)
+bool CPeripheralCecAdapter::HasAudioControl(void)
 {
   CSingleLock lock(m_critSection);
   return m_bHasConnectedAudioSystem;
@@ -515,7 +515,7 @@ void CPeripheralCecAdapter::ProcessVolumeChange(void)
 
 void CPeripheralCecAdapter::VolumeUp(void)
 {
-  if (HasConnectedAudioSystem())
+  if (HasAudioControl())
   {
     CSingleLock lock(m_critSection);
     m_volumeChangeQueue.push(VOLUME_CHANGE_UP);
@@ -524,7 +524,7 @@ void CPeripheralCecAdapter::VolumeUp(void)
 
 void CPeripheralCecAdapter::VolumeDown(void)
 {
-  if (HasConnectedAudioSystem())
+  if (HasAudioControl())
   {
     CSingleLock lock(m_critSection);
     m_volumeChangeQueue.push(VOLUME_CHANGE_DOWN);
@@ -533,7 +533,7 @@ void CPeripheralCecAdapter::VolumeDown(void)
 
 void CPeripheralCecAdapter::ToggleMute(void)
 {
-  if (HasConnectedAudioSystem())
+  if (HasAudioControl())
   {
     CSingleLock lock(m_critSection);
     m_volumeChangeQueue.push(VOLUME_CHANGE_MUTE);
@@ -542,7 +542,7 @@ void CPeripheralCecAdapter::ToggleMute(void)
 
 bool CPeripheralCecAdapter::IsMuted(void)
 {
-  if (HasConnectedAudioSystem())
+  if (HasAudioControl())
   {
     CSingleLock lock(m_critSection);
     return m_bIsMuted;
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.h b/xbmc/peripherals/devices/PeripheralCecAdapter.h
index 87f543b..6848f61 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.h
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.h
@@ -30,7 +30,7 @@ namespace PERIPHERALS
   class CPeripheralCecAdapter : public CPeripheral
   {
   public:
-    bool HasConnectedAudioSystem(void) { return false; }
+    bool HasAudioControl(void) { return false; }
     void ScheduleVolumeUp(void) {}
     void ScheduleVolumeDown(void) {}
     bool IsMuted(void) { return false; }
@@ -90,52 +90,62 @@ namespace PERIPHERALS
     virtual ~CPeripheralCecAdapter(void);
 
     void Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data);
-    bool HasConnectedAudioSystem(void);
-    void SetAudioSystemConnected(bool bSetTo);
+
+    // audio control
+    bool HasAudioControl(void);
     void VolumeUp(void);
     void VolumeDown(void);
     void ToggleMute(void);
     bool IsMuted(void);
 
+    // CPeripheral callbacks
     void OnSettingChanged(const CStdString &strChangedSetting);
     void OnDeviceRemoved(void);
 
+    // input
     int GetButton(void);
     unsigned int GetHoldTime(void);
     void ResetButton(void);
 
-    void PushCecKeypress(const CEC::cec_keypress &key);
-
+    // public CEC methods
     void ActivateSource(void);
     void StandbyDevices(void);
 
-  protected:
+  private:
+    bool InitialiseFeature(const PeripheralFeature feature);
+    void ResetMembers(void);
+    void Process(void);
+    bool IsRunning(void) const;
+
     bool OpenConnection(void);
+    bool ReopenConnection(void);
+
     void SetConfigurationFromSettings(void);
     void SetConfigurationFromLibCEC(const CEC::libcec_configuration &config);
     void SetVersionInfo(const CEC::libcec_configuration &configuration);
+
     static void ReadLogicalAddresses(const CStdString &strString, CEC::cec_logical_addresses &addresses);
     static void ReadLogicalAddresses(int iLocalisedId, CEC::cec_logical_addresses &addresses);
     bool WriteLogicalAddresses(const CEC::cec_logical_addresses& addresses, const std::string& strSettingName, const std::string& strAdvancedSettingName);
-    static int CecKeyPress(void *cbParam, const CEC::cec_keypress key);
-    void PushCecKeypress(const CecButtonPress &key);
-    static int CecLogMessage(void *cbParam, const CEC::cec_log_message message);
-    static int CecCommand(void *cbParam, const CEC::cec_command command);
-    static int CecConfiguration(void *cbParam, const CEC::libcec_configuration config);
-    static int CecAlert(void *cbParam, const CEC::libcec_alert alert, const CEC::libcec_parameter data);
-    static void CecSourceActivated(void *param, const CEC::cec_logical_address address, const uint8_t activated);
-    bool IsRunning(void) const;
-    bool ReopenConnection(void);
+
     void ProcessActivateSource(void);
     void ProcessStandbyDevices(void);
+    void ProcessVolumeChange(void);
 
+    void PushCecKeypress(const CEC::cec_keypress &key);
+    void PushCecKeypress(const CecButtonPress &key);
     void GetNextKey(void);
-    bool InitialiseFeature(const PeripheralFeature feature);
-    void Process(void);
-    void ProcessVolumeChange(void);
+
+    void SetAudioSystemConnected(bool bSetTo);
     void SetMenuLanguage(const char *strLanguage);
 
-    void ResetMembers(void);
+    // callbacks from libCEC
+    static int CecLogMessage(void *cbParam, const CEC::cec_log_message message);
+    static int CecCommand(void *cbParam, const CEC::cec_command command);
+    static int CecConfiguration(void *cbParam, const CEC::libcec_configuration config);
+    static int CecAlert(void *cbParam, const CEC::libcec_alert alert, const CEC::libcec_parameter data);
+    static void CecSourceActivated(void *param, const CEC::cec_logical_address address, const uint8_t activated);
+    static int CecKeyPress(void *cbParam, const CEC::cec_keypress key);
 
     DllLibCEC*                        m_dll;
     CEC::ICECAdapter*                 m_cecAdapter;

From 2ba18db6b09a346559bea1327c1c619548ed4506 Mon Sep 17 00:00:00 2001
From: Lars Op den Kamp <lars@opdenkamp.eu>
Date: Tue, 12 Mar 2013 13:50:54 +0100
Subject: [PATCH 28/38] fixed compilation without libcec-dev on the system
 after 95d87f545665674f76f691197bbad3360b807981. updated the method names of
 the dummy CPeripheralCecAdapter implementation so they match the ones in the
 real implementation

---
 xbmc/peripherals/devices/PeripheralCecAdapter.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.h b/xbmc/peripherals/devices/PeripheralCecAdapter.h
index 6848f61..29852e5 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.h
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.h
@@ -31,10 +31,10 @@ namespace PERIPHERALS
   {
   public:
     bool HasAudioControl(void) { return false; }
-    void ScheduleVolumeUp(void) {}
-    void ScheduleVolumeDown(void) {}
+    void VolumeUp(void) {}
+    void VolumeDown(void) {}
     bool IsMuted(void) { return false; }
-    void ScheduleMute(void) {}
+    void ToggleMute(void) {}
 
     int GetButton(void) { return 0; }
     unsigned int GetHoldTime(void) { return 0; }

From ac63512c5fbbe49f34d1275b50d375d4f7b2d8a1 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 11:32:23 +0100
Subject: [PATCH 29/38] Update lib

---
 lib/cximage-6.0/CxImage/DllInterface.cpp |  2 ++
 lib/cximage-6.0/CxImage/ximadsp.cpp      |  6 ++++++
 lib/cximage-6.0/CxImage/ximaenc.cpp      |  4 ++++
 lib/cximage-6.0/CxImage/xmemfile.cpp     | 16 ++++++++++++--
 lib/cximage-6.0/png/pngwutil.c           |  3 +--
 lib/cximage-6.0/raw/dcraw.c              | 13 +++++++-----
 lib/cximage-6.0/raw/libdcr.c             | 36 ++++++++++++++++++++++++--------
 lib/timidity/timidity/readmidi.c         |  1 +
 8 files changed, 63 insertions(+), 18 deletions(-)

diff --git a/lib/cximage-6.0/CxImage/DllInterface.cpp b/lib/cximage-6.0/CxImage/DllInterface.cpp
index 6a8e6d3..2c16e94 100644
--- a/lib/cximage-6.0/CxImage/DllInterface.cpp
+++ b/lib/cximage-6.0/CxImage/DllInterface.cpp
@@ -94,6 +94,8 @@ int DetectFileType(const BYTE* pBuffer, int nBufSize)
     // don't include the last APP0 byte (0xE0), as some (non-conforming) JPEG/JFIF files might have some other
     // APPn-specific data here, and we should skip over this.
     return CXIMAGE_FORMAT_JPG;
+  if (pBuffer[0] == 'G' && pBuffer[1] == 'I' && pBuffer[2] == 'F')
+    return CXIMAGE_FORMAT_GIF;
   return CXIMAGE_FORMAT_UNKNOWN;
 }
 
diff --git a/lib/cximage-6.0/CxImage/ximadsp.cpp b/lib/cximage-6.0/CxImage/ximadsp.cpp
index f54ffd6..a21c066 100644
--- a/lib/cximage-6.0/CxImage/ximadsp.cpp
+++ b/lib/cximage-6.0/CxImage/ximadsp.cpp
@@ -654,6 +654,7 @@ bool CxImage::Colorize(BYTE hue, BYTE sat, float blend)
 						hsl.rgbRed=hue;
 						hsl.rgbGreen=sat;
 						hsl.rgbBlue = (BYTE)RGB2GRAY(color.rgbRed,color.rgbGreen,color.rgbBlue);
+						hsl.rgbReserved = (BYTE)0;
 						hsl = HSLtoRGB(hsl);
 						//BlendPixelColor(x,y,hsl,blend);
 						//color.rgbRed = (BYTE)(hsl.rgbRed * blend + color.rgbRed * (1.0f - blend));
@@ -679,6 +680,7 @@ bool CxImage::Colorize(BYTE hue, BYTE sat, float blend)
 				hsl.rgbRed=hue;
 				hsl.rgbGreen=sat;
 				hsl.rgbBlue = (BYTE)RGB2GRAY(color.rgbRed,color.rgbGreen,color.rgbBlue);
+				hsl.rgbReserved = (BYTE)0;
 				hsl = HSLtoRGB(hsl);
 				color.rgbRed = (BYTE)(hsl.rgbRed * blend + color.rgbRed * (1.0f - blend));
 				color.rgbBlue = (BYTE)(hsl.rgbBlue * blend + color.rgbBlue * (1.0f - blend));
@@ -1802,6 +1804,7 @@ bool CxImage::Combine(CxImage* r,CxImage* g,CxImage* b,CxImage* a, long colorspa
 			c.rgbRed=r->GetPixelIndex(x,y);
 			c.rgbGreen=g->GetPixelIndex(x,y);
 			c.rgbBlue=b->GetPixelIndex(x,y);
+			c.rgbReserved = (BYTE)0;
 			switch (colorspace){
 			case 1:
 				BlindSetPixelColor(x,y,HSLtoRGB(c));
@@ -2700,7 +2703,10 @@ bool CxImage::UnsharpMask(float radius /*= 5.0*/, float amount /*= 0.5*/, int th
 		pPalette = new RGBQUAD[head.biClrUsed];
 		memcpy(pPalette, GetPalette(),GetPaletteSize());
 		if (!IncreaseBpp(24))
+		{
+			delete [] pPalette;
 			return false;
+		}
 	}
 
 	CxImage iDst;
diff --git a/lib/cximage-6.0/CxImage/ximaenc.cpp b/lib/cximage-6.0/CxImage/ximaenc.cpp
index 14e7890..ed8b779 100644
--- a/lib/cximage-6.0/CxImage/ximaenc.cpp
+++ b/lib/cximage-6.0/CxImage/ximaenc.cpp
@@ -815,10 +815,12 @@ bool CxImage::Decode(CxFile *hFile, DWORD imagetype)
             if (newima.Decode( &hMemFile ))
             {
               Transfer(newima);
+              free(buffer);
               return true;
             }
             else
               hFile->Seek(pos, SEEK_SET);
+            free(buffer);
           }
           else
           {
@@ -1063,11 +1065,13 @@ bool CxImage::Decode(CxFile *hFile, DWORD imagetype)
         if (newima.Decode( &hMemFile ))
         {
           Transfer(newima);
+          free(buffer);
           return true;
         }
         else
         {
           strcpy(info.szLastError,newima.GetLastError());
+          free(buffer);
           return false;
         }
        }
diff --git a/lib/cximage-6.0/CxImage/xmemfile.cpp b/lib/cximage-6.0/CxImage/xmemfile.cpp
index af8db94..5a72200 100644
--- a/lib/cximage-6.0/CxImage/xmemfile.cpp
+++ b/lib/cximage-6.0/CxImage/xmemfile.cpp
@@ -186,9 +186,21 @@ bool CxMemFile::Alloc(DWORD dwNewLen)
 
 		// allocate new buffer
 		if (m_pBuffer == NULL) m_pBuffer = (BYTE*)malloc(dwNewBufferSize);
-		else	m_pBuffer = (BYTE*)realloc(m_pBuffer, dwNewBufferSize);
+		else
+		{
+			BYTE* new_buf = (BYTE*)realloc(m_pBuffer, dwNewBufferSize);
+			if (!new_buf)
+			{
+				free(m_pBuffer);
+				m_bFreeOnClose = false;
+				return false;
+			}
+			else
+				m_pBuffer = new_buf;
+		}
 		// I own this buffer now (caller knows nothing about it)
-		m_bFreeOnClose = true;
+		if (m_pBuffer)
+			m_bFreeOnClose = true;
 
 		m_Edge = dwNewBufferSize;
 	}
diff --git a/lib/cximage-6.0/png/pngwutil.c b/lib/cximage-6.0/png/pngwutil.c
index fef38ae..7f4ba12 100644
--- a/lib/cximage-6.0/png/pngwutil.c
+++ b/lib/cximage-6.0/png/pngwutil.c
@@ -1721,7 +1721,6 @@ png_write_tIME(png_structp png_ptr, png_timep mod_time)
    png_write_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
 }
 #endif
-
 /* initializes the row writing capability of libpng */
 void /* PRIVATE */
 png_write_start_row(png_structp png_ptr)
@@ -1790,8 +1789,8 @@ png_write_start_row(png_structp png_ptr)
             (png_ptr->rowbytes + 1));
          png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
       }
-#endif /* PNG_NO_WRITE_FILTERING */
    }
+#endif /* PNG_NO_WRITE_FILTERING */
 
 #ifdef PNG_WRITE_INTERLACING_SUPPORTED
    /* if interlaced, we need to set up width and height of pass */
diff --git a/lib/cximage-6.0/raw/dcraw.c b/lib/cximage-6.0/raw/dcraw.c
index d57b915..45cd7a9 100644
--- a/lib/cximage-6.0/raw/dcraw.c
+++ b/lib/cximage-6.0/raw/dcraw.c
@@ -3485,6 +3485,7 @@ void CLASS subtract (char *fname)
       BAYER(row,col) = MAX (BAYER(row,col) - ntohs(pixel[col]), 0);
   }
   free (pixel);
+  fclose(fp);
   black = 0;
 }
 
@@ -4774,7 +4775,7 @@ void CLASS romm_coeff (float romm_cam[3][3])
 void CLASS parse_mos (int offset)
 {
   char data[40];
-  int skip, from, i, c, neut[4], planes=0, frot=0;
+  int skip, from, i, j, c, neut[4], planes=0, frot=0;
   static const char *mod[] =
   { "","DCB2","Volare","Cantare","CMost","Valeo 6","Valeo 11","Valeo 22",
     "Valeo 11p","Valeo 17","","Aptus 17","Aptus 22","Aptus 75","Aptus 65",
@@ -4802,13 +4803,15 @@ void CLASS parse_mos (int offset)
 	strcpy (model, mod[i]);
     }
     if (!strcmp(data,"icc_camera_to_tone_matrix")) {
-      for (i=0; i < 9; i++)
-	romm_cam[0][i] = int_to_float(get4());
+      for (i=0; i < 3; i++)
+		for (j=0; j < 3; j++)
+			romm_cam[i][j] = int_to_float(get4());
       romm_coeff (romm_cam);
     }
     if (!strcmp(data,"CaptProf_color_matrix")) {
-      for (i=0; i < 9; i++)
-	fscanf (ifp, "%f", &romm_cam[0][i]);
+      for (i=0; i < 3; i++)
+		for (j=0; j < 3; j++)
+			fscanf (ifp, "%f", &romm_cam[i][j]);
       romm_coeff (romm_cam);
     }
     if (!strcmp(data,"CaptProf_number_of_planes"))
diff --git a/lib/cximage-6.0/raw/libdcr.c b/lib/cximage-6.0/raw/libdcr.c
index 81bf2fb..7e357f2 100644
--- a/lib/cximage-6.0/raw/libdcr.c
+++ b/lib/cximage-6.0/raw/libdcr.c
@@ -837,6 +837,9 @@ int DCR_CLASS dcr_ljpeg_diff (DCRAW* p, struct dcr_decode *dindex)
 {
 	int len, diff;
 
+	if (!dindex)
+		longjmp (p->failure, 2);
+
 	while (dindex->branch[0])
 		dindex = dindex->branch[dcr_getbits(p, 1)];
 	len = dindex->leaf;
@@ -894,6 +897,10 @@ void DCR_CLASS dcr_lossless_jpeg_load_raw(DCRAW* p)
 	ushort *rp;
 
 	if (!dcr_ljpeg_start (p,&jh, 0)) return;
+
+	if (jh.wide<1 || jh.high<1 || jh.clrs<1 || jh.bits<1)
+		longjmp (p->failure, 2);
+
 	jwide = jh.wide * jh.clrs;
 
 	for (jrow=0; jrow < jh.high; jrow++) {
@@ -913,6 +920,8 @@ void DCR_CLASS dcr_lossless_jpeg_load_raw(DCRAW* p)
 			}
 			if (p->raw_width == 3984 && (col -= 2) < 0)
 				col += (row--,p->raw_width);
+			if (row > p->raw_height)
+				longjmp (p->failure, 3);
 			if ((unsigned) (row-p->top_margin) < p->height) {
 				if ((unsigned) (col-p->left_margin) < p->width) {
 					BAYER(row-p->top_margin,col-p->left_margin) = val;
@@ -4735,7 +4744,7 @@ void DCR_CLASS dcr_romm_coeff (DCRAW* p, float romm_cam[3][3])
 void DCR_CLASS dcr_parse_mos (DCRAW* p, int offset)
 {
 	char data[40];
-	int skip, from, i=0, c, neut[4], planes=0, frot=0;
+	int skip, from, i=0, j, c, neut[4], planes=0, frot=0;
 	static const char *mod[] =
 	{ "","DCB2","Volare","Cantare","CMost","Valeo 6","Valeo 11","Valeo 22",
     "Valeo 11p","Valeo 17","","Aptus 17","Aptus 22","Aptus 75","Aptus 65",
@@ -4763,13 +4772,15 @@ void DCR_CLASS dcr_parse_mos (DCRAW* p, int offset)
 				strcpy (p->model, mod[i]);
 		}
 		if (!strcmp(data,"icc_camera_to_tone_matrix")) {
-			for (i=0; i < 9; i++)
-				romm_cam[0][i] = dcr_int_to_float(dcr_get4(p));
+			for (i=0; i < 3; i++)
+				for (j=0; j < 3; j++)
+					romm_cam[i][j] = dcr_int_to_float(dcr_get4(p));
 			dcr_romm_coeff (p,romm_cam);
 		}
 		if (!strcmp(data,"CaptProf_color_matrix")) {
-			for (i=0; i < 9; i++)
-				dcr_fscanf(p->obj_, "%f", &romm_cam[0][i]);
+			for (i=0; i < 3; i++)
+				for (j=0; j < 3; j++)
+					dcr_fscanf(p->obj_, "%f", &romm_cam[i][j]);
 			dcr_romm_coeff (p,romm_cam);
 		}
 		if (!strcmp(data,"CaptProf_number_of_planes"))
@@ -4971,6 +4982,7 @@ int DCR_CLASS dcr_parse_tiff_ifd (DCRAW* p, int base)
 				p->data_offset = dcr_get4(p)+base;
 				ifd++;  break;
 			}
+			if(len > 1000) len=1000; /* 1000 SubIFDs is enough */
 			while (len--) {
 				i = dcr_ftell(p->obj_);
 				dcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);
@@ -5159,7 +5171,7 @@ int DCR_CLASS dcr_parse_tiff_ifd (DCRAW* p, int base)
 		case 50714:			/* BlackLevel */
 		case 50715:			/* BlackLevelDeltaH */
 		case 50716:			/* BlackLevelDeltaV */
-			for (dblack=i=0; i < (int)len; i++)
+			for (dblack=i=0; i < (int)len && i < 65536; i++)
 				dblack += dcr_getreal(p, type);
 			p->black += (unsigned int)(dblack/len + 0.5);
 			break;
@@ -5273,9 +5285,11 @@ void DCR_CLASS dcr_parse_tiff (DCRAW* p, int base)
 	if (p->thumb_offset) {
 		dcr_fseek(p->obj_, p->thumb_offset, SEEK_SET);
 		if (dcr_ljpeg_start (p,&jh, 1)) {
-			p->thumb_misc   = jh.bits;
-			p->thumb_width  = jh.wide;
-			p->thumb_height = jh.high;
+			if ((unsigned)jh.bits<17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000) {
+				p->thumb_misc   = jh.bits;
+				p->thumb_width  = jh.wide;
+				p->thumb_height = jh.high;
+			}
 		}
 	}
 	for (i=0; i < (int)p->tiff_nifds; i++) {
@@ -5283,6 +5297,8 @@ void DCR_CLASS dcr_parse_tiff (DCRAW* p, int base)
 			max_samp = p->tiff_ifd[i].samples;
 		if (max_samp > 3) max_samp = 3;
 		if ((p->tiff_ifd[i].comp != 6 || p->tiff_ifd[i].samples != 3) &&
+		        (unsigned)(p->tiff_ifd[i].width | p->tiff_ifd[i].height) < 0x10000 &&
+			(unsigned)p->tiff_ifd[i].bps < 33 && (unsigned)p->tiff_ifd[i].samples < 13 &&
 			p->tiff_ifd[i].width*p->tiff_ifd[i].height > p->raw_width*p->raw_height) {
 			p->raw_width     = p->tiff_ifd[i].width;
 			p->raw_height    = p->tiff_ifd[i].height;
@@ -5346,6 +5362,8 @@ void DCR_CLASS dcr_parse_tiff (DCRAW* p, int base)
 	if (p->tiff_bps == 8 && p->tiff_samples == 4) p->is_raw = 0;
 	for (i=0; i < (int)p->tiff_nifds; i++)
 		if (i != raw && p->tiff_ifd[i].samples == max_samp &&
+			p->tiff_ifd[i].bps>0 && p->tiff_ifd[i].bps < 33 &&
+			(unsigned)(p->tiff_ifd[i].width | p->tiff_ifd[i].height) < 0x10000 &&
 			p->tiff_ifd[i].width * p->tiff_ifd[i].height / SQR(p->tiff_ifd[i].bps+1) >
 			(int)(p->thumb_width *       p->thumb_height / SQR(p->thumb_misc+1))) {
 			p->thumb_width  = p->tiff_ifd[i].width;
diff --git a/lib/timidity/timidity/readmidi.c b/lib/timidity/timidity/readmidi.c
index 452b792..068cb3c 100644
--- a/lib/timidity/timidity/readmidi.c
+++ b/lib/timidity/timidity/readmidi.c
@@ -615,6 +615,7 @@ static int set_xg_reverb_type(int msb, int lsb)
 		break;
 	    case 0x03:
 		type = 3;			/* Stage 1 -> Hall 1 */
+		break;
 	    case 0x04:
 		type = 5;			/* Plate */
 		break;

From c6155f9cd75f05887b6638d3a3324628cb569a8c Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 11:58:46 +0100
Subject: [PATCH 30/38] Update threads

---
 xbmc/threads/Event.cpp                        | 14 ++++++++++----
 xbmc/threads/Event.h                          |  3 +++
 xbmc/threads/LockFree.cpp                     |  2 ++
 xbmc/threads/Lockables.h                      | 27 +++++++++++++++++++--------
 xbmc/threads/SharedSection.h                  |  2 +-
 xbmc/threads/SystemClock.cpp                  |  4 ++++
 xbmc/threads/Thread.cpp                       |  5 +++--
 xbmc/threads/platform/pthreads/Condition.h    | 21 +++++++++------------
 xbmc/threads/platform/pthreads/ThreadImpl.cpp |  6 ++++++
 xbmc/utils/TimeUtils.cpp                      |  4 ++++
 10 files changed, 61 insertions(+), 27 deletions(-)

diff --git a/xbmc/threads/Event.cpp b/xbmc/threads/Event.cpp
index 50592d8..9ea5598 100644
--- a/xbmc/threads/Event.cpp
+++ b/xbmc/threads/Event.cpp
@@ -151,10 +151,15 @@ namespace XbmcThreads
     va_list ap;
 
     va_start(ap, v1);
-    events.push_back(v1);
+    if (v1)
+      events.push_back(v1);
     num--; // account for v1
-    for (;num > 0; num--)
-      events.push_back(va_arg(ap,CEvent*));
+    for (; num > 0; num--)
+    {
+      CEvent* const cur = va_arg(ap, CEvent*);
+      if (cur)
+        events.push_back(cur);
+    }
     va_end(ap);
 
     // we preping for a wait, so we need to set the group value on
@@ -169,7 +174,8 @@ namespace XbmcThreads
     va_list ap;
 
     va_start(ap, v1);
-    events.push_back(v1);
+    if (v1)
+      events.push_back(v1);
     bool done = false;
     while(!done)
     {
diff --git a/xbmc/threads/Event.h b/xbmc/threads/Event.h
index 46696ec..005c0c1 100644
--- a/xbmc/threads/Event.h
+++ b/xbmc/threads/Event.h
@@ -74,6 +74,9 @@ class CEvent : public XbmcThreads::NonCopyable
   inline void Reset() { CSingleLock lock(mutex); signaled = false; }
   void Set();
 
+  /** Returns true if Event has been triggered and not reset, false otherwise. */
+  inline bool Signaled() { CSingleLock lock(mutex); return signaled; }
+
   /**
    * This will wait up to 'milliSeconds' milliseconds for the Event
    *  to be triggered. The method will return 'true' if the Event
diff --git a/xbmc/threads/LockFree.cpp b/xbmc/threads/LockFree.cpp
index cc1146e..c2bf762 100644
--- a/xbmc/threads/LockFree.cpp
+++ b/xbmc/threads/LockFree.cpp
@@ -112,6 +112,8 @@ void lf_heap_grow(lf_heap* pHeap, size_t size /*= 0*/)
   // Allocate the first chunk from the general heap and link it into the chunk list
   long mallocSize = size +  sizeof(lf_heap_chunk);
   lf_heap_chunk* pChunk = (lf_heap_chunk*) malloc(mallocSize);
+  if (!pChunk)
+    return;
   pChunk->size = mallocSize;
   SPINLOCK_ACQUIRE(pHeap->alloc_lock); // Lock the chunk list. Contention here is VERY unlikely, so use the simplest possible sync mechanism.
   pChunk->next = pHeap->top_chunk;
diff --git a/xbmc/threads/Lockables.h b/xbmc/threads/Lockables.h
index f4eb26d..61bd64a 100644
--- a/xbmc/threads/Lockables.h
+++ b/xbmc/threads/Lockables.h
@@ -48,6 +48,7 @@ namespace XbmcThreads
    */
   template<class L> class CountingLockable : public NonCopyable
   {
+    friend class ConditionVariable;
   protected:
     L mutex;
     unsigned int count;
@@ -62,21 +63,31 @@ namespace XbmcThreads
 
     /**
      * This implements the "exitable" behavior mentioned above.
+     *
+     * This can be used to ALMOST exit, but not quite, by passing
+     *  the number of locks to leave. This is used in the windows
+     *  ConditionVariable which requires that the lock be entered
+     *  only once, and so it backs out ALMOST all the way, but
+     *  leaves one still there.
      */
-    inline unsigned int exit() 
+    inline unsigned int exit(unsigned int leave = 0)
     { 
       // it's possibe we don't actually own the lock
       // so we will try it.
       unsigned int ret = 0;
       if (try_lock())
       {
-        ret = count - 1;  // The -1 is because we don't want 
-                          //  to count the try_lock increment.
-        // We must NOT compare "count" in this loop since 
-        // as soon as the last unlock is called another thread
-        // can modify it.
-        for (unsigned int i = 0; i <= ret; i++) // This will also unlock the try_lock.
-          unlock();
+        if (leave < (count - 1))
+        {
+          ret = count - 1 - leave;  // The -1 is because we don't want
+                                    //  to count the try_lock increment.
+          // We must NOT compare "count" in this loop since
+          // as soon as the last unlock is called another thread
+          // can modify it.
+          for (unsigned int i = 0; i < ret; i++)
+            unlock();
+        }
+        unlock(); // undo the try_lock before returning
       }
 
       return ret; 
diff --git a/xbmc/threads/SharedSection.h b/xbmc/threads/SharedSection.h
index 47eb77d..66b433f 100644
--- a/xbmc/threads/SharedSection.h
+++ b/xbmc/threads/SharedSection.h
@@ -38,7 +38,7 @@ class CSharedSection
 public:
   inline CSharedSection() : cond(actualCv,XbmcThreads::InversePredicate<unsigned int&>(sharedCount)), sharedCount(0)  {}
 
-  inline void lock() { CSingleLock l(sec); if (sharedCount) cond.wait(l); sec.lock(); }
+  inline void lock() { CSingleLock l(sec); while (sharedCount) cond.wait(l); sec.lock(); }
   inline bool try_lock() { return (sec.try_lock() ? ((sharedCount == 0) ? true : (sec.unlock(), false)) : false); }
   inline void unlock() { sec.unlock(); }
 
diff --git a/xbmc/threads/SystemClock.cpp b/xbmc/threads/SystemClock.cpp
index 172fb50..7e4e5f7 100644
--- a/xbmc/threads/SystemClock.cpp
+++ b/xbmc/threads/SystemClock.cpp
@@ -42,7 +42,11 @@ namespace XbmcThreads
     now_time = (uint64_t)timeGetTime();
 #else
     struct timespec ts = {};
+#ifdef CLOCK_MONOTONIC_RAW
+    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
+#else
     clock_gettime(CLOCK_MONOTONIC, &ts);
+#endif // CLOCK_MONOTONIC_RAW
     now_time = (ts.tv_sec * 1000) + (ts.tv_nsec / 1000000);
 #endif
     if (!start_time_set)
diff --git a/xbmc/threads/Thread.cpp b/xbmc/threads/Thread.cpp
index 91eb023..f296ac2 100644
--- a/xbmc/threads/Thread.cpp
+++ b/xbmc/threads/Thread.cpp
@@ -23,6 +23,7 @@
 #include "threads/ThreadLocal.h"
 #include "threads/SingleLock.h"
 #include "commons/Exception.h"
+#include <stdlib.h>
 
 #define __STDC_FORMAT_MACROS
 #include <inttypes.h>
@@ -138,12 +139,12 @@ THREADFUNC CThread::staticThread(void* data)
 
   if (autodelete)
   {
-    LOG(LOGDEBUG,"Thread %s %"PRIu64" terminating (autodelete)", name.c_str(), (uint64_t)id);
+    LOG(LOGDEBUG,"Thread %s %" PRIu64" terminating (autodelete)", name.c_str(), (uint64_t)id);
     delete pThread;
     pThread = NULL;
   }
   else
-    LOG(LOGDEBUG,"Thread %s %"PRIu64" terminating", name.c_str(), (uint64_t)id);
+    LOG(LOGDEBUG,"Thread %s %" PRIu64" terminating", name.c_str(), (uint64_t)id);
 
   return 0;
 }
diff --git a/xbmc/threads/platform/pthreads/Condition.h b/xbmc/threads/platform/pthreads/Condition.h
index 161881b..6621ceb 100644
--- a/xbmc/threads/platform/pthreads/Condition.h
+++ b/xbmc/threads/platform/pthreads/Condition.h
@@ -47,16 +47,7 @@ namespace XbmcThreads
   public:
     inline ConditionVariable() 
     {
-      /* PLEX */
-#ifdef HAVE_PTHREAD_CONDATTR_SETCLOCK
-      pthread_condattr_t attr;
-      pthread_condattr_init(&attr);
-      pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
-      pthread_cond_init(&cond, &attr);
-#else
-      /* END PLEX */
       pthread_cond_init(&cond,NULL);
-#endif
     }
 
     inline ~ConditionVariable() 
@@ -65,8 +56,11 @@ namespace XbmcThreads
     }
 
     inline void wait(CCriticalSection& lock) 
-    { 
+    {
+      int count  = lock.count;
+      lock.count = 0;
       pthread_cond_wait(&cond,&lock.get_underlying().mutex);
+      lock.count = count;
     }
 
     inline bool wait(CCriticalSection& lock, unsigned long milliseconds) 
@@ -85,8 +79,11 @@ namespace XbmcThreads
       ts.tv_nsec += milliseconds % 1000 * 1000000;
       ts.tv_sec  += milliseconds / 1000 + ts.tv_nsec / 1000000000;
       ts.tv_nsec %= 1000000000;
-
-      return (pthread_cond_timedwait(&cond,&lock.get_underlying().mutex,&ts) == 0);
+      int count  = lock.count;
+      lock.count = 0;
+      int res    = pthread_cond_timedwait(&cond,&lock.get_underlying().mutex,&ts);
+      lock.count = count;
+      return res == 0;
     }
 
     inline void wait(CSingleLock& lock) { wait(lock.get_underlying()); }
diff --git a/xbmc/threads/platform/pthreads/ThreadImpl.cpp b/xbmc/threads/platform/pthreads/ThreadImpl.cpp
index 43df0c4..1b3b077 100644
--- a/xbmc/threads/platform/pthreads/ThreadImpl.cpp
+++ b/xbmc/threads/platform/pthreads/ThreadImpl.cpp
@@ -97,6 +97,9 @@ void CThread::SetThreadInfo()
   else
     userMaxPrio = 0;
 
+  if (geteuid() == 0)
+    userMaxPrio = GetMaxPriority();
+
   // if the user does not have an entry in limits.conf the following
   // call will fail
   if (userMaxPrio > 0)
@@ -169,6 +172,9 @@ bool CThread::SetPriority(const int iPriority)
     else
       userMaxPrio = 0;
 
+    if (geteuid() == 0)
+      userMaxPrio = GetMaxPriority();
+
     // keep priority in bounds
     int prio = iPriority;
     if (prio >= GetMaxPriority())
diff --git a/xbmc/utils/TimeUtils.cpp b/xbmc/utils/TimeUtils.cpp
index 9d0c504..2c8e2de 100644
--- a/xbmc/utils/TimeUtils.cpp
+++ b/xbmc/utils/TimeUtils.cpp
@@ -43,7 +43,11 @@ int64_t CurrentHostCounter(void)
   return( (int64_t)PerformanceCount.QuadPart );
 #else
   struct timespec now;
+#ifdef CLOCK_MONOTONIC_RAW
+  clock_gettime(CLOCK_MONOTONIC_RAW, &now);
+#else
   clock_gettime(CLOCK_MONOTONIC, &now);
+#endif // CLOCK_MONOTONIC_RAW
   return( ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec );
 #endif
 }

From 15256cfe1ed6bd0067b2c57e1a0c7fdfd3eb9c24 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 12:06:24 +0100
Subject: [PATCH 31/38] Update rbp

---
 plex/Utility/PlexJobs.cpp         |   2 +-
 xbmc/TextureCacheJob.cpp          |   2 +-
 xbmc/cores/omxplayer/DllOMX.h     | 122 ---------
 xbmc/cores/omxplayer/OMXImage.cpp | 556 +++++++++++++++++++++++---------------
 xbmc/cores/omxplayer/OMXImage.h   |  49 ++--
 xbmc/guilib/TexturePi.cpp         |   4 +-
 xbmc/linux/OMXCore.cpp            |  44 +--
 xbmc/linux/OMXCore.h              |  32 +--
 xbmc/linux/RBP.cpp                |  83 +++++-
 xbmc/linux/RBP.h                  |  12 +
 10 files changed, 485 insertions(+), 421 deletions(-)
 delete mode 100644 xbmc/cores/omxplayer/DllOMX.h

diff --git a/plex/Utility/PlexJobs.cpp b/plex/Utility/PlexJobs.cpp
index e745f82..af2c792 100644
--- a/plex/Utility/PlexJobs.cpp
+++ b/plex/Utility/PlexJobs.cpp
@@ -243,7 +243,7 @@ bool CPlexTextureCacheJob::CacheTexture(CBaseTexture **texture)
     m_details.height = height;
     m_details.file = m_cachePath + ".jpg";
     if (texture)
-      *texture = CTextureCacheJob::LoadImage(CTextureCache::GetCachedPath(m_details.file), width, height, additional_info);
+      *texture = CTextureCacheJob::LoadImage(CTextureCache::GetCachedPath(m_details.file), width, height, "" /* already flipped */);
     CLog::Log(LOGDEBUG, "Fast %s image '%s' to '%s': %p", m_oldHash.IsEmpty() ? "Caching" : "Recaching", image.c_str(), m_details.file.c_str(), texture);
     return true;
   }
diff --git a/xbmc/TextureCacheJob.cpp b/xbmc/TextureCacheJob.cpp
index f29ad223..54864df 100644
--- a/xbmc/TextureCacheJob.cpp
+++ b/xbmc/TextureCacheJob.cpp
@@ -98,7 +98,7 @@ bool CTextureCacheJob::CacheTexture(CBaseTexture **out_texture)
     m_details.height = height;
     m_details.file = m_cachePath + ".jpg";
     if (out_texture)
-      *out_texture = LoadImage(CTextureCache::GetCachedPath(m_details.file), width, height, additional_info);
+      *out_texture = LoadImage(CTextureCache::GetCachedPath(m_details.file), width, height, "" /* already flipped */);
     CLog::Log(LOGDEBUG, "Fast %s image '%s' to '%s': %p", m_oldHash.IsEmpty() ? "Caching" : "Recaching", image.c_str(), m_details.file.c_str(), out_texture);
     return true;
   }
diff --git a/xbmc/cores/omxplayer/DllOMX.h b/xbmc/cores/omxplayer/DllOMX.h
deleted file mode 100644
index 01aadd8..0000000
--- a/xbmc/cores/omxplayer/DllOMX.h
+++ /dev/null
@@ -1,122 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2012 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if defined(HAVE_OMXLIB)
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#ifndef __GNUC__
-#pragma warning(push)
-#pragma warning(disable:4244)
-#endif
-
-#include "DynamicDll.h"
-#include "utils/log.h"
-
-#include <IL/OMX_Core.h>
-#include <IL/OMX_Component.h>
-#include <IL/OMX_Index.h>
-#include <IL/OMX_Image.h>
-#include <IL/OMX_Video.h>
-#include <IL/OMX_Broadcom.h>
-
-////////////////////////////////////////////////////////////////////////////////////////////
-
-class DllOMXInterface
-{
-public:
-  virtual ~DllOMXInterface() {}
-
-  virtual OMX_ERRORTYPE OMX_Init(void) = 0;
-  virtual OMX_ERRORTYPE OMX_Deinit(void) = 0;
-  virtual OMX_ERRORTYPE OMX_GetHandle(OMX_HANDLETYPE *pHandle, OMX_STRING cComponentName, OMX_PTR pAppData, OMX_CALLBACKTYPE *pCallBacks) = 0;
-  virtual OMX_ERRORTYPE OMX_FreeHandle(OMX_HANDLETYPE hComponent) = 0;
-  virtual OMX_ERRORTYPE OMX_GetComponentsOfRole(OMX_STRING role, OMX_U32 *pNumComps, OMX_U8 **compNames) = 0;
-  virtual OMX_ERRORTYPE OMX_GetRolesOfComponent(OMX_STRING compName, OMX_U32 *pNumRoles, OMX_U8 **roles) = 0;
-  virtual OMX_ERRORTYPE OMX_ComponentNameEnum(OMX_STRING cComponentName, OMX_U32 nNameLength, OMX_U32 nIndex) = 0;
-  virtual OMX_ERRORTYPE OMX_SetupTunnel(OMX_HANDLETYPE hOutput, OMX_U32 nPortOutput, OMX_HANDLETYPE hInput, OMX_U32 nPortInput) = 0;
-
-};
-
-#if (defined USE_EXTERNAL_OMX)
-class DllOMX : public DllDynamic, DllOMXInterface
-{
-public:
-  virtual OMX_ERRORTYPE OMX_Init(void) 
-    { return ::OMX_Init(); };
-  virtual OMX_ERRORTYPE OMX_Deinit(void) 
-    { return ::OMX_Deinit(); };
-  virtual OMX_ERRORTYPE OMX_GetHandle(OMX_HANDLETYPE *pHandle, OMX_STRING cComponentName, OMX_PTR pAppData, OMX_CALLBACKTYPE *pCallBacks)
-    { return ::OMX_GetHandle(pHandle, cComponentName, pAppData, pCallBacks); };
-  virtual OMX_ERRORTYPE OMX_FreeHandle(OMX_HANDLETYPE hComponent)
-    { return ::OMX_FreeHandle(hComponent); };
-  virtual OMX_ERRORTYPE OMX_GetComponentsOfRole(OMX_STRING role, OMX_U32 *pNumComps, OMX_U8 **compNames) 
-    { return ::OMX_GetComponentsOfRole(role, pNumComps, compNames); };
-  virtual OMX_ERRORTYPE OMX_GetRolesOfComponent(OMX_STRING compName, OMX_U32 *pNumRoles, OMX_U8 **roles)
-    { return ::OMX_GetRolesOfComponent(compName, pNumRoles, roles); };
-  virtual OMX_ERRORTYPE OMX_ComponentNameEnum(OMX_STRING cComponentName, OMX_U32 nNameLength, OMX_U32 nIndex)
-    { return ::OMX_ComponentNameEnum(cComponentName, nNameLength, nIndex); };
-  virtual OMX_ERRORTYPE OMX_SetupTunnel(OMX_HANDLETYPE hOutput, OMX_U32 nPortOutput, OMX_HANDLETYPE hInput, OMX_U32 nPortInput)
-    { return ::OMX_SetupTunnel(hOutput, nPortOutput, hInput, nPortInput); };
-  virtual bool ResolveExports() 
-    { return true; }
-  virtual bool Load() 
-  {
-    CLog::Log(LOGDEBUG, "DllOMX: Using omx system library");
-    return true;
-  }
-  virtual void Unload() {}
-};
-#else
-class DllOMX : public DllDynamic, DllOMXInterface
-{
-  //DECLARE_DLL_WRAPPER(DllLibOpenMax, "/usr/lib/libnvomx.so")
-  DECLARE_DLL_WRAPPER(DllOMX, "/opt/vc/lib/libopenmaxil.so")
-
-  DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Init)
-  DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Deinit)
-  DEFINE_METHOD4(OMX_ERRORTYPE, OMX_GetHandle, (OMX_HANDLETYPE *p1, OMX_STRING p2, OMX_PTR p3, OMX_CALLBACKTYPE *p4))
-  DEFINE_METHOD1(OMX_ERRORTYPE, OMX_FreeHandle, (OMX_HANDLETYPE p1))
-  DEFINE_METHOD3(OMX_ERRORTYPE, OMX_GetComponentsOfRole, (OMX_STRING p1, OMX_U32 *p2, OMX_U8 **p3))
-  DEFINE_METHOD3(OMX_ERRORTYPE, OMX_GetRolesOfComponent, (OMX_STRING p1, OMX_U32 *p2, OMX_U8 **p3))
-  DEFINE_METHOD3(OMX_ERRORTYPE, OMX_ComponentNameEnum, (OMX_STRING p1, OMX_U32 p2, OMX_U32 p3))
-  DEFINE_METHOD4(OMX_ERRORTYPE, OMX_SetupTunnel, (OMX_HANDLETYPE p1, OMX_U32 p2, OMX_HANDLETYPE p3, OMX_U32 p4));
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(OMX_Init)
-    RESOLVE_METHOD(OMX_Deinit)
-    RESOLVE_METHOD(OMX_GetHandle)
-    RESOLVE_METHOD(OMX_FreeHandle)
-    RESOLVE_METHOD(OMX_GetComponentsOfRole)
-    RESOLVE_METHOD(OMX_GetRolesOfComponent)
-    RESOLVE_METHOD(OMX_ComponentNameEnum)
-    RESOLVE_METHOD(OMX_SetupTunnel)
-  END_METHOD_RESOLVE()
-
-public:
-  virtual bool Load()
-  {
-    return DllDynamic::Load();
-  }
-};
-#endif
-
-#endif
diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index e6d1c50..ce0481a 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -49,14 +49,40 @@
 #define EXIF_TAG_ORIENTATION    0x0112
 
 
+// A helper for restricting threads calling GPU functions to limit memory use
+// Experimentally, 3 outstanding operations is optimal
+static XbmcThreads::ConditionVariable g_count_cond;
+static CCriticalSection               g_count_lock;
+static int g_count_val;
+
+static void limit_calls_enter()
+{
+  CSingleLock lock(g_count_lock);
+  while (g_count_val >= 3)
+    g_count_cond.wait(lock);
+  g_count_val++;
+}
+
+static void limit_calls_leave()
+{
+  CSingleLock lock(g_count_lock);
+  g_count_val--;
+  g_count_cond.notifyAll();
+}
+
+
 #ifdef CLASSNAME
 #undef CLASSNAME
 #endif
 #define CLASSNAME "COMXImage"
 
+using namespace std;
+using namespace XFILE;
+
 COMXImage::COMXImage()
 : CThread("CRBPWorker")
 {
+  m_egl_context = EGL_NO_CONTEXT;
 }
 
 COMXImage::~COMXImage()
@@ -180,8 +206,9 @@ bool COMXImage::CreateThumb(const CStdString& srcFile, unsigned int maxHeight, u
   COMXImageReEnc reenc;
   void *pDestBuffer;
   unsigned int nDestSize;
+  int orientation = additional_info == "flipped" ? 1:0;
   if ((srcFile.substr(0, 13) == "plexserver://" || URIUtils::GetExtension(srcFile).Equals(".jpg") || URIUtils::GetExtension(srcFile).Equals(".tbn")) &&
-      file.ReadFile(srcFile) && reenc.ReEncode(file, maxWidth, maxHeight, pDestBuffer, nDestSize))
+      file.ReadFile(srcFile, orientation) && reenc.ReEncode(file, maxWidth, maxHeight, pDestBuffer, nDestSize))
   {
     XFILE::CFile outfile;
     if (outfile.OpenForWrite(destFile, true))
@@ -196,7 +223,39 @@ bool COMXImage::CreateThumb(const CStdString& srcFile, unsigned int maxHeight, u
   return okay;
 }
 
-void COMXImage::AllocTextureInternal(struct textureinfo *tex)
+bool COMXImage::SendMessage(bool (*callback)(EGLDisplay egl_display, EGLContext egl_context, void *cookie), void *cookie)
+{
+  // we can only call gl functions from the application thread or texture thread
+  if ( g_application.IsCurrentThread() )
+  {
+    return callback(g_Windowing.GetEGLDisplay(), GetEGLContext(), cookie);
+  }
+  struct callbackinfo mess;
+  mess.callback = callback;
+  mess.cookie = cookie;
+  mess.result = false;
+  mess.sync.Reset();
+  {
+    CSingleLock lock(m_texqueue_lock);
+    m_texqueue.push(&mess);
+    m_texqueue_cond.notifyAll();
+  }
+  // wait for function to have finished (in texture thread)
+  mess.sync.Wait();
+  // need to ensure texture thread has returned from mess.sync.Set() before we exit and free tex
+  CSingleLock lock(m_texqueue_lock);
+  return mess.result;
+}
+
+
+static bool AllocTextureCallback(EGLDisplay egl_display, EGLContext egl_context, void *cookie)
+{
+  struct COMXImage::textureinfo *tex = static_cast<struct COMXImage::textureinfo *>(cookie);
+  COMXImage *img = static_cast<COMXImage*>(tex->parent);
+  return img->AllocTextureInternal(egl_display, egl_context, tex);
+}
+
+bool COMXImage::AllocTextureInternal(EGLDisplay egl_display, EGLContext egl_context, struct textureinfo *tex)
 {
   glGenTextures(1, (GLuint*) &tex->texture);
   glBindTexture(GL_TEXTURE_2D, tex->texture);
@@ -204,11 +263,14 @@ void COMXImage::AllocTextureInternal(struct textureinfo *tex)
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, tex->width, tex->height, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, 0);
-  tex->egl_image = eglCreateImageKHR(m_egl_display, m_egl_context, EGL_GL_TEXTURE_2D_KHR, (EGLClientBuffer)tex->texture, NULL);
-  tex->sync.Set();
+  GLenum type = g_guiSettings.GetBool("videoscreen.textures32") ? GL_UNSIGNED_BYTE:GL_UNSIGNED_SHORT_5_6_5;
+  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, tex->width, tex->height, 0, GL_RGB, type, 0);
+  tex->egl_image = eglCreateImageKHR(egl_display, egl_context, EGL_GL_TEXTURE_2D_KHR, (EGLClientBuffer)tex->texture, NULL);
+  if (!tex->egl_image)
+    CLog::Log(LOGDEBUG, "%s: eglCreateImageKHR failed to allocate", __func__);
   GLint m_result;
   CheckError();
+  return true;
 }
 
 void COMXImage::GetTexture(void *userdata, GLuint *texture)
@@ -217,41 +279,30 @@ void COMXImage::GetTexture(void *userdata, GLuint *texture)
   *texture = tex->texture;
 }
 
-void COMXImage::DestroyTextureInternal(struct textureinfo *tex)
+static bool DestroyTextureCallback(EGLDisplay egl_display, EGLContext egl_context, void *cookie)
 {
-  bool s = true;
-  if (!tex->egl_image || !tex->texture)
-  {
-    CLog::Log(LOGNOTICE, "%s: Invalid image/texture %p:%d", __func__, tex->egl_image, tex->texture);
-    return;
-  }
-  s = eglDestroyImageKHR(m_egl_display, tex->egl_image);
-  if (!s)
-    CLog::Log(LOGNOTICE, "%s: failed to destroy texture", __func__);
-  glDeleteTextures(1, (GLuint*) &tex->texture);
-  tex->sync.Set();
+  struct COMXImage::textureinfo *tex = static_cast<struct COMXImage::textureinfo *>(cookie);
+  COMXImage *img = static_cast<COMXImage*>(tex->parent);
+  return img->DestroyTextureInternal(egl_display, egl_context, tex);
 }
 
 void COMXImage::DestroyTexture(void *userdata)
 {
-  struct textureinfo *tex = static_cast<struct textureinfo *>(userdata);
-  // we can only call gl functions from the application thread
+  SendMessage(DestroyTextureCallback, userdata);
+}
 
-  tex->action = TEXTURE_DELETE;
-  tex->sync.Reset();
-  if ( g_application.IsCurrentThread() )
-  {
-     DestroyTextureInternal(tex);
-  }
-  else
+bool COMXImage::DestroyTextureInternal(EGLDisplay egl_display, EGLContext egl_context, struct textureinfo *tex)
+{
+  bool s = true;
+  if (tex->egl_image)
   {
-    CSingleLock lock(m_texqueue_lock);
-    m_texqueue.push(tex);
-    m_texqueue_cond.notifyAll();
+    s = eglDestroyImageKHR(egl_display, tex->egl_image);
+    if (!s)
+      CLog::Log(LOGNOTICE, "%s: failed to destroy texture", __func__);
   }
-  // wait for function to have finished (in texture thread)
-  tex->sync.Wait();
-  delete tex;
+  if (tex->texture)
+    glDeleteTextures(1, (GLuint*) &tex->texture);
+  return s;
 }
 
 bool COMXImage::DecodeJpegToTexture(COMXImageFile *file, unsigned int width, unsigned int height, void **userdata)
@@ -269,22 +320,14 @@ bool COMXImage::DecodeJpegToTexture(COMXImageFile *file, unsigned int width, uns
   tex->texture = 0;
   tex->egl_image = NULL;
   tex->filename = file->GetFilename();
-  tex->action = TEXTURE_ALLOC;
-  tex->sync.Reset();
 
-  {
-    CSingleLock lock(m_texqueue_lock);
-    m_texqueue.push(tex);
-    m_texqueue_cond.notifyAll();
-  }
-
-  // wait for function to have finished (in texture thread)
-  tex->sync.Wait();
+  SendMessage(AllocTextureCallback, tex);
 
-  if (tex->egl_image && tex->texture && omx_image.Decode(file->GetImageBuffer(), file->GetImageSize(), width, height, tex->egl_image, m_egl_display))
+  if (tex->egl_image && tex->texture && omx_image.Decode(file->GetImageBuffer(), file->GetImageSize(), width, height, tex->egl_image))
   {
     ret = true;
     *userdata = tex;
+    CLog::Log(LOGDEBUG, "%s: decoded %s %dx%d", __func__, file->GetFilename(), width, height);
   }
   else
   {
@@ -294,6 +337,16 @@ bool COMXImage::DecodeJpegToTexture(COMXImageFile *file, unsigned int width, uns
   return ret;
 }
 
+EGLContext COMXImage::GetEGLContext()
+{
+  CSingleLock lock(m_texqueue_lock);
+  if (g_application.IsCurrentThread())
+    return g_Windowing.GetEGLContext();
+  if (m_egl_context == EGL_NO_CONTEXT)
+    CreateContext();
+  return m_egl_context;
+}
+
 static bool ChooseConfig(EGLDisplay display, const EGLint *configAttrs, EGLConfig *config)
 {
   EGLBoolean eglStatus = true;
@@ -338,9 +391,9 @@ void COMXImage::CreateContext()
 {
   EGLConfig egl_config;
   GLint m_result;
+  EGLDisplay egl_display = g_Windowing.GetEGLDisplay();
 
-  m_egl_display = g_Windowing.GetEGLDisplay();
-  eglInitialize(m_egl_display, NULL, NULL);
+  eglInitialize(egl_display, NULL, NULL);
   CheckError();
   eglBindAPI(EGL_OPENGL_ES_API);
   CheckError();
@@ -358,28 +411,28 @@ void COMXImage::CreateContext()
         EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
         EGL_NONE
   };
-  bool s = ChooseConfig(m_egl_display, configAttrs, &egl_config);
+  bool s = ChooseConfig(egl_display, configAttrs, &egl_config);
   CheckError();
   if (!s)
   {
     CLog::Log(LOGERROR, "%s: Could not find a compatible configuration",__FUNCTION__);
     return;
   }
-  m_egl_context = eglCreateContext(m_egl_display, egl_config, g_Windowing.GetEGLContext(), contextAttrs);
+  m_egl_context = eglCreateContext(egl_display, egl_config, g_Windowing.GetEGLContext(), contextAttrs);
   CheckError();
   if (m_egl_context == EGL_NO_CONTEXT)
   {
     CLog::Log(LOGERROR, "%s: Could not create a context",__FUNCTION__);
     return;
   }
-  EGLSurface egl_surface = eglCreatePbufferSurface(m_egl_display, egl_config, NULL);
+  EGLSurface egl_surface = eglCreatePbufferSurface(egl_display, egl_config, NULL);
   CheckError();
   if (egl_surface == EGL_NO_SURFACE)
   {
     CLog::Log(LOGERROR, "%s: Could not create a surface",__FUNCTION__);
     return;
   }
-  s = eglMakeCurrent(m_egl_display, egl_surface, egl_surface, m_egl_context);
+  s = eglMakeCurrent(egl_display, egl_surface, egl_surface, m_egl_context);
   CheckError();
   if (!s)
   {
@@ -390,36 +443,25 @@ void COMXImage::CreateContext()
 
 void COMXImage::Process()
 {
-  bool firsttime = true;
-
   while(!m_bStop)
   {
-    struct textureinfo *tex = NULL;
-    while (!m_bStop)
+    CSingleLock lock(m_texqueue_lock);
+    if (m_texqueue.empty())
     {
-      CSingleLock lock(m_texqueue_lock);
-      if (!m_texqueue.empty())
-      {
-        tex = m_texqueue.front();
-        m_texqueue.pop();
-        break;
-      }
       m_texqueue_cond.wait(lock);
     }
-
-    if (m_bStop)
-      return;
-
-    if (firsttime)
-      CreateContext();
-    firsttime = false;
-
-    if (tex && tex->action == TEXTURE_ALLOC)
-      AllocTextureInternal(tex);
-    else if (tex && tex->action == TEXTURE_DELETE)
-      DestroyTextureInternal(tex);
     else
-      CLog::Log(LOGERROR, "%s: Unexpected texture job: %p:%d", __func__, tex, tex ? tex->action : 0);
+    {
+      struct callbackinfo *mess = m_texqueue.front();
+      m_texqueue.pop();
+      lock.Leave();
+
+      mess->result = mess->callback(g_Windowing.GetEGLDisplay(), GetEGLContext(), mess->cookie);
+      {
+        CSingleLock lock(m_texqueue_lock);
+        mess->sync.Set();
+      }
+    }
   }
 }
 
@@ -552,7 +594,7 @@ static void inline SKIPN(uint8_t * &p, unsigned int n)
   p += n;
 }
 
-OMX_IMAGE_CODINGTYPE COMXImageFile::GetCodingType(unsigned int &width, unsigned int &height)
+OMX_IMAGE_CODINGTYPE COMXImageFile::GetCodingType(unsigned int &width, unsigned int &height, int orientation)
 {
   OMX_IMAGE_CODINGTYPE eCompressionFormat = OMX_IMAGE_CodingMax;
   bool progressive = false;
@@ -769,7 +811,7 @@ OMX_IMAGE_CODINGTYPE COMXImageFile::GetCodingType(unsigned int &width, unsigned
                 {
                   SKIPN(p, 1 * 7);
                   readBits += 7;
-                  m_orientation = READ8(p);
+                  m_orientation = READ8(p)-1;
                   readBits += 1;
                   SKIPN(p, 1 * 2);
                   readBits += 2;
@@ -778,7 +820,7 @@ OMX_IMAGE_CODINGTYPE COMXImageFile::GetCodingType(unsigned int &width, unsigned
                 {
                   SKIPN(p, 1 * 6);
                   readBits += 6;
-                  m_orientation = READ8(p);
+                  m_orientation = READ8(p)-1;
                   readBits += 1;
                   SKIPN(p, 1 * 3);
                   readBits += 3;
@@ -808,7 +850,9 @@ OMX_IMAGE_CODINGTYPE COMXImageFile::GetCodingType(unsigned int &width, unsigned
     }
   }
 
-  if(m_orientation > 8)
+  // apply input orientation
+  m_orientation = m_orientation ^ orientation;
+  if(m_orientation < 0 || m_orientation >= 8)
     m_orientation = 0;
 
   if(eCompressionFormat == OMX_IMAGE_CodingMax)
@@ -832,7 +876,7 @@ OMX_IMAGE_CODINGTYPE COMXImageFile::GetCodingType(unsigned int &width, unsigned
 }
 
 
-bool COMXImageFile::ReadFile(const CStdString& inputFile)
+bool COMXImageFile::ReadFile(const CStdString& inputFile, int orientation)
 {
   XFILE::CFile      m_pFile;
   m_filename = inputFile.c_str();
@@ -863,7 +907,7 @@ bool COMXImageFile::ReadFile(const CStdString& inputFile)
   m_pFile.Read(m_image_buffer, m_image_size);
   m_pFile.Close();
 
-  OMX_IMAGE_CODINGTYPE eCompressionFormat = GetCodingType(m_width, m_height);
+  OMX_IMAGE_CODINGTYPE eCompressionFormat = GetCodingType(m_width, m_height, orientation);
   if(eCompressionFormat != OMX_IMAGE_CodingJPEG)
   {
     CLog::Log(LOGERROR, "%s::%s %s GetCodingType=0x%x\n", CLASSNAME, __func__, inputFile.c_str(), eCompressionFormat);
@@ -886,8 +930,10 @@ bool COMXImageFile::ReadFile(const CStdString& inputFile)
 
 COMXImageDec::COMXImageDec()
 {
+  limit_calls_enter();
   m_decoded_buffer = NULL;
   OMX_INIT_STRUCTURE(m_decoded_format);
+  m_success = false;
 }
 
 COMXImageDec::~COMXImageDec()
@@ -896,21 +942,27 @@ COMXImageDec::~COMXImageDec()
 
   OMX_INIT_STRUCTURE(m_decoded_format);
   m_decoded_buffer = NULL;
+  limit_calls_leave();
 }
 
 void COMXImageDec::Close()
 {
   CSingleLock lock(m_OMXSection);
 
-  if(m_omx_decoder.IsInitialized())
+  if (!m_success)
   {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-  }
-  if(m_omx_resize.IsInitialized())
-  {
-    m_omx_resize.FlushOutput();
-    m_omx_resize.FreeOutputBuffers();
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.SetStateForComponent(OMX_StateIdle);
+      m_omx_resize.FlushOutput();
+      m_omx_resize.FreeOutputBuffers();
+    }
   }
   if(m_omx_tunnel_decode.IsInitialized())
     m_omx_tunnel_decode.Deestablish();
@@ -1163,6 +1215,7 @@ bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes
 
   memcpy( (char*)pixels, m_decoded_buffer->pBuffer, stride * height);
 
+  m_success = true;
   Close();
   return true;
 }
@@ -1174,9 +1227,11 @@ bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes
 
 COMXImageEnc::COMXImageEnc()
 {
+  limit_calls_enter();
   CSingleLock lock(m_OMXSection);
   OMX_INIT_STRUCTURE(m_encoded_format);
   m_encoded_buffer = NULL;
+  m_success = false;
 }
 
 COMXImageEnc::~COMXImageEnc()
@@ -1187,6 +1242,7 @@ COMXImageEnc::~COMXImageEnc()
   m_encoded_buffer = NULL;
   if(m_omx_encoder.IsInitialized())
     m_omx_encoder.Deinitialize();
+  limit_calls_leave();
 }
 
 bool COMXImageEnc::Encode(unsigned char *buffer, int size, unsigned width, unsigned height, unsigned int pitch)
@@ -1399,9 +1455,11 @@ bool COMXImageEnc::CreateThumbnailFromSurface(unsigned char* buffer, unsigned in
 
 COMXImageReEnc::COMXImageReEnc()
 {
+  limit_calls_enter();
   m_encoded_buffer = NULL;
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
+  m_success = false;
 }
 
 COMXImageReEnc::~COMXImageReEnc()
@@ -1411,21 +1469,31 @@ COMXImageReEnc::~COMXImageReEnc()
     free (m_pDestBuffer);
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
+  limit_calls_leave();
 }
 
 void COMXImageReEnc::Close()
 {
   CSingleLock lock(m_OMXSection);
 
-  if(m_omx_decoder.IsInitialized())
+  if (!m_success)
   {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-  }
-  if(m_omx_encoder.IsInitialized())
-  {
-    m_omx_encoder.FlushOutput();
-    m_omx_encoder.FreeOutputBuffers();
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.SetStateForComponent(OMX_StateIdle);
+    }
+    if(m_omx_encoder.IsInitialized())
+    {
+      m_omx_encoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_encoder.FlushOutput();
+      m_omx_encoder.FreeOutputBuffers();
+    }
   }
   if(m_omx_tunnel_decode.IsInitialized())
     m_omx_tunnel_decode.Deestablish();
@@ -1458,9 +1526,22 @@ bool COMXImageReEnc::HandlePortSettingChange(unsigned int resize_width, unsigned
       return false;
     }
 
+    if (resize_width != port_def.format.image.nFrameWidth || resize_height != port_def.format.image.nFrameHeight || (orientation & 4))
+    {
+      if(!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
+      {
+        CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize\n", CLASSNAME, __func__);
+        return false;
+      }
+    }
+
     // TODO: jpeg decoder can decimate by factors of 2
     port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
-    port_def.format.image.nSliceHeight = 16;//(port_def.format.image.nFrameHeight+15) & ~15;
+    if (m_omx_resize.IsInitialized())
+      port_def.format.image.nSliceHeight = 16;
+    else
+      port_def.format.image.nSliceHeight = (resize_height+15) & ~15;
+
     port_def.format.image.nStride = 0;
 
     m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
@@ -1470,38 +1551,35 @@ bool COMXImageReEnc::HandlePortSettingChange(unsigned int resize_width, unsigned
       return false;
     }
 
-    if(!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
+    if (m_omx_resize.IsInitialized())
     {
-      CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize\n", CLASSNAME, __func__);
-      return false;
-    }
-
-    port_def.nPortIndex = m_omx_resize.GetInputPort();
+      port_def.nPortIndex = m_omx_resize.GetInputPort();
 
-    m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
-      return false;
-    }
+      m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
 
-    port_def.nPortIndex = m_omx_resize.GetOutputPort();
-    m_omx_resize.GetParameter(OMX_IndexParamPortDefinition, &port_def);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "%s::%s m_omx_resize.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
-      return false;
-    }
-    port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
-    port_def.format.image.nFrameWidth = resize_width;
-    port_def.format.image.nFrameHeight = resize_height;
-    port_def.format.image.nSliceHeight = (resize_height+15) & ~15;
-    port_def.format.image.nStride = 0;
-    m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
-      return false;
+      port_def.nPortIndex = m_omx_resize.GetOutputPort();
+      m_omx_resize.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+      port_def.format.image.nFrameWidth = resize_width;
+      port_def.format.image.nFrameHeight = resize_height;
+      port_def.format.image.nSliceHeight = (resize_height+15) & ~15;
+      port_def.format.image.nStride = 0;
+      m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
     }
 
     if(!m_omx_encoder.Initialize("OMX.broadcom.image_encode", OMX_IndexParamImageInit))
@@ -1585,7 +1663,7 @@ bool COMXImageReEnc::HandlePortSettingChange(unsigned int resize_width, unsigned
       item.metadata.eValueCharset = OMX_MetadataCharsetASCII;
       item.metadata.sLanguageCountry = 0;
       item.metadata.nValueMaxSize = sizeof(item.metadata_space);
-      sprintf((char *)item.metadata.nValue, "%d", orientation);
+      sprintf((char *)item.metadata.nValue, "%d", orientation + 1);
       item.metadata.nValueSizeUsed = strlen((char *)item.metadata.nValue);
 
       omx_err = m_omx_encoder.SetParameter(OMX_IndexConfigMetadataItem, &item);
@@ -1602,31 +1680,44 @@ bool COMXImageReEnc::HandlePortSettingChange(unsigned int resize_width, unsigned
       return false;
     }
 
-    m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
-
-    omx_err = m_omx_tunnel_decode.Establish();
-    if(omx_err != OMX_ErrorNone)
+    if (m_omx_resize.IsInitialized())
     {
-      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish\n", CLASSNAME, __func__);
-      return false;
-    }
+      m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
+
+      omx_err = m_omx_tunnel_decode.Establish();
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish\n", CLASSNAME, __func__);
+        return false;
+      }
 
-    m_omx_tunnel_resize.Initialize(&m_omx_resize, m_omx_resize.GetOutputPort(), &m_omx_encoder, m_omx_encoder.GetInputPort());
+      m_omx_tunnel_resize.Initialize(&m_omx_resize, m_omx_resize.GetOutputPort(), &m_omx_encoder, m_omx_encoder.GetInputPort());
 
-    omx_err = m_omx_tunnel_resize.Establish();
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_resize.Establish\n", CLASSNAME, __func__);
-      return false;
-    }
+      omx_err = m_omx_tunnel_resize.Establish();
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_resize.Establish\n", CLASSNAME, __func__);
+        return false;
+      }
 
-    omx_err = m_omx_resize.SetStateForComponent(OMX_StateExecuting);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetStateForComponent result(0x%x)\n", CLASSNAME, __func__, omx_err);
-      return false;
+      omx_err = m_omx_resize.SetStateForComponent(OMX_StateExecuting);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetStateForComponent result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
     }
+    else
+    {
+      m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_encoder, m_omx_encoder.GetInputPort());
 
+      omx_err = m_omx_tunnel_decode.Establish();
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish\n", CLASSNAME, __func__);
+        return false;
+      }
+    }
     omx_err = m_omx_encoder.SetStateForComponent(OMX_StateExecuting);
     if (omx_err != OMX_ErrorNone)
     {
@@ -1643,24 +1734,27 @@ bool COMXImageReEnc::HandlePortSettingChange(unsigned int resize_width, unsigned
     // a little surprising, make a note
     CLog::Log(LOGDEBUG, "%s::%s m_omx_resize second port changed event\n", CLASSNAME, __func__);
     m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
-    m_omx_resize.DisablePort(m_omx_resize.GetInputPort(), true);
+    if (m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.DisablePort(m_omx_resize.GetInputPort(), true);
 
-    OMX_PARAM_PORTDEFINITIONTYPE port_def;
-    OMX_INIT_STRUCTURE(port_def);
+      OMX_PARAM_PORTDEFINITIONTYPE port_def;
+      OMX_INIT_STRUCTURE(port_def);
 
-    port_def.nPortIndex = m_omx_decoder.GetOutputPort();
-    m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
-    port_def.nPortIndex = m_omx_resize.GetInputPort();
-    m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+      port_def.nPortIndex = m_omx_decoder.GetOutputPort();
+      m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+      port_def.nPortIndex = m_omx_resize.GetInputPort();
+      m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
 
-    omx_err = m_omx_resize.WaitForEvent(OMX_EventPortSettingsChanged);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "%s::%s m_omx_resize.WaitForEvent=%x\n", CLASSNAME, __func__, omx_err);
-      return false;
+      omx_err = m_omx_resize.WaitForEvent(OMX_EventPortSettingsChanged);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.WaitForEvent=%x\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      m_omx_resize.EnablePort(m_omx_resize.GetInputPort(), true);
     }
     m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
-    m_omx_resize.EnablePort(m_omx_resize.GetInputPort(), true);
   }
   return true;
 }
@@ -1807,7 +1901,8 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
 
       if (nDestSize + m_encoded_buffer->nFilledLen > m_nDestAllocSize)
       {
-         m_nDestAllocSize = std::max(1024U*1024U, m_nDestAllocSize*2);
+         while (nDestSize + m_encoded_buffer->nFilledLen > m_nDestAllocSize)
+           m_nDestAllocSize = std::max(1024U*1024U, m_nDestAllocSize*2);
          m_pDestBuffer = realloc(m_pDestBuffer, m_nDestAllocSize);
       }
       memcpy((char *)m_pDestBuffer + nDestSize, m_encoded_buffer->pBuffer, m_encoded_buffer->nFilledLen);
@@ -1816,14 +1911,15 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
     }
   }
 
-  Close();
-
   if(m_omx_decoder.BadState())
     return false;
 
   pDestBuffer = m_pDestBuffer;
   CLog::Log(LOGDEBUG, "%s::%s : %s %dx%d -> %dx%d\n", CLASSNAME, __func__, srcFile.GetFilename(), srcFile.GetWidth(), srcFile.GetHeight(), maxWidth, maxHeight);
 
+  m_success = true;
+  Close();
+
   return true;
 }
 
@@ -1835,17 +1931,35 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
 
 COMXTexture::COMXTexture()
 {
+  limit_calls_enter();
+  m_success = false;
 }
 
 COMXTexture::~COMXTexture()
 {
   Close();
+  limit_calls_leave();
 }
 
 void COMXTexture::Close()
 {
   CSingleLock lock(m_OMXSection);
 
+  if (!m_success)
+  {
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_egl_render.IsInitialized())
+    {
+      m_omx_egl_render.SetStateForComponent(OMX_StateIdle);
+      m_omx_egl_render.FlushOutput();
+      m_omx_egl_render.FreeOutputBuffers();
+    }
+  }
   if (m_omx_tunnel_decode.IsInitialized())
     m_omx_tunnel_decode.Deestablish();
   if (m_omx_tunnel_egl.IsInitialized())
@@ -1859,8 +1973,9 @@ void COMXTexture::Close()
     m_omx_egl_render.Deinitialize();
 }
 
-bool COMXTexture::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, void *egl_image, void *egl_display, bool port_settings_changed)
+bool COMXTexture::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, void *egl_image, bool port_settings_changed)
 {
+  EGLDisplay egl_display = g_Windowing.GetEGLDisplay();
   OMX_ERRORTYPE omx_err;
 
   if (port_settings_changed)
@@ -1888,42 +2003,45 @@ bool COMXTexture::HandlePortSettingChange(unsigned int resize_width, unsigned in
     CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
     return false;
   }
-
-  if (!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
+  if (resize_width != port_def.format.image.nFrameWidth || resize_height != port_def.format.image.nFrameHeight)
   {
-    CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize", CLASSNAME, __func__);
-    return false;
+    if (!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
+    {
+      CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize", CLASSNAME, __func__);
+      return false;
+    }
   }
-
-  port_def.nPortIndex = m_omx_resize.GetInputPort();
-
-  omx_err = m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
-  if (omx_err != OMX_ErrorNone)
+  if (m_omx_resize.IsInitialized())
   {
-    CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
-    return false;
-  }
+    port_def.nPortIndex = m_omx_resize.GetInputPort();
 
-  port_def.nPortIndex = m_omx_resize.GetOutputPort();
-  omx_err = m_omx_resize.GetParameter(OMX_IndexParamPortDefinition, &port_def);
-  if (omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "%s::%s m_omx_resize.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
-    return false;
-  }
+    omx_err = m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
 
-  port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
-  port_def.format.image.nFrameWidth = resize_width;
-  port_def.format.image.nFrameHeight = resize_height;
-  port_def.format.image.nSliceHeight = 16;
-  port_def.format.image.nStride = 0;
-  omx_err = m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
-  if (omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
-    return false;
-  }
+    port_def.nPortIndex = m_omx_resize.GetOutputPort();
+    omx_err = m_omx_resize.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
 
+    port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+    port_def.format.image.nFrameWidth = resize_width;
+    port_def.format.image.nFrameHeight = resize_height;
+    port_def.format.image.nSliceHeight = 16;
+    port_def.format.image.nStride = 0;
+    omx_err = m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
   if (!m_omx_egl_render.Initialize("OMX.broadcom.egl_render", OMX_IndexParamVideoInit))
   {
     CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.Initialize", CLASSNAME, __func__);
@@ -1953,30 +2071,43 @@ bool COMXTexture::HandlePortSettingChange(unsigned int resize_width, unsigned in
     CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.UseEGLImage (%x)", CLASSNAME, __func__, omx_err);
     return false;
   }
+  if (m_omx_resize.IsInitialized())
+  {
+    m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
 
-  m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
+    omx_err = m_omx_tunnel_decode.Establish();
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish (%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
 
-  omx_err = m_omx_tunnel_decode.Establish();
-  if (omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish (%x)", CLASSNAME, __func__, omx_err);
-    return false;
-  }
+    m_omx_tunnel_egl.Initialize(&m_omx_resize, m_omx_resize.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
 
-  m_omx_tunnel_egl.Initialize(&m_omx_resize, m_omx_resize.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+    omx_err = m_omx_tunnel_egl.Establish();
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_egl.Establish (%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
 
-  omx_err = m_omx_tunnel_egl.Establish();
-  if (omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_egl.Establish (%x)", CLASSNAME, __func__, omx_err);
-    return false;
+    omx_err = m_omx_resize.SetStateForComponent(OMX_StateExecuting);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.GetParameter (%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
   }
-
-  omx_err = m_omx_resize.SetStateForComponent(OMX_StateExecuting);
-  if (omx_err != OMX_ErrorNone)
+  else
   {
-    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.GetParameter (%x)", CLASSNAME, __func__, omx_err);
-    return false;
+    m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+
+    omx_err = m_omx_tunnel_decode.Establish();
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish (%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
   }
 
   omx_err = m_omx_egl_render.SetStateForComponent(OMX_StateExecuting);
@@ -1989,7 +2120,7 @@ bool COMXTexture::HandlePortSettingChange(unsigned int resize_width, unsigned in
   return true;
 }
 
-bool COMXTexture::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes, unsigned int width, unsigned int height, void *egl_image, void *egl_display)
+bool COMXTexture::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes, unsigned int width, unsigned int height, void *egl_image)
 {
   CSingleLock lock(m_OMXSection);
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
@@ -2081,7 +2212,7 @@ bool COMXTexture::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes,
     omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, timeout);
     if (omx_err == OMX_ErrorNone)
     {
-      if (!HandlePortSettingChange(width, height, egl_image, egl_display, port_settings_changed))
+      if (!HandlePortSettingChange(width, height, egl_image, port_settings_changed))
       {
         CLog::Log(LOGERROR, "%s::%s - HandlePortSettingChange failed (%x)", CLASSNAME, __func__, omx_err);
         return false;
@@ -2129,6 +2260,7 @@ bool COMXTexture::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes,
       eos = true;
     }
   }
+  m_success = true;
   Close();
   return true;
 }
diff --git a/xbmc/cores/omxplayer/OMXImage.h b/xbmc/cores/omxplayer/OMXImage.h
index 41104a5..33e1744 100644
--- a/xbmc/cores/omxplayer/OMXImage.h
+++ b/xbmc/cores/omxplayer/OMXImage.h
@@ -39,30 +39,28 @@
 #include <EGL/eglext.h>
 #include "threads/Thread.h"
 
-using namespace XFILE;
-using namespace std;
-
 class COMXImageFile;
 
 class COMXImage : public CThread
 {
-enum TextureAction {TEXTURE_ALLOC, TEXTURE_DELETE };
-
-struct textureinfo {
-  TextureAction action;
-  int width, height;
-  GLuint texture;
-  EGLImageKHR egl_image;
-  void *parent;
-  const char *filename;
-  CEvent sync;
-};
-
+  struct callbackinfo {
+    CEvent sync;
+    bool (*callback)(EGLDisplay egl_display, EGLContext egl_context, void *cookie);
+    void *cookie;
+    bool result;
+  };
 protected:
   virtual void OnStartup();
   virtual void OnExit();
   virtual void Process();
 public:
+  struct textureinfo {
+    int width, height;
+    GLuint texture;
+    EGLImageKHR egl_image;
+    void *parent;
+    const char *filename;
+  };
   COMXImage();
   virtual ~COMXImage();
   void Initialize();
@@ -75,19 +73,20 @@ struct textureinfo {
       unsigned int format, unsigned int pitch, const CStdString& destFile);
   static bool ClampLimits(unsigned int &width, unsigned int &height, unsigned int m_width, unsigned int m_height, bool transposed = false);
   static bool CreateThumb(const CStdString& srcFile, unsigned int width, unsigned int height, std::string &additional_info, const CStdString& destFile);
+  bool SendMessage(bool (*callback)(EGLDisplay egl_display, EGLContext egl_context, void *cookie), void *cookie);
   bool DecodeJpegToTexture(COMXImageFile *file, unsigned int width, unsigned int height, void **userdata);
   void DestroyTexture(void *userdata);
   void GetTexture(void *userdata, GLuint *texture);
+  bool AllocTextureInternal(EGLDisplay egl_display, EGLContext egl_context, struct textureinfo *tex);
+  bool DestroyTextureInternal(EGLDisplay egl_display, EGLContext egl_context, struct textureinfo *tex);
 private:
-  EGLDisplay m_egl_display;
   EGLContext m_egl_context;
 
   void CreateContext();
+  EGLContext GetEGLContext();
   CCriticalSection               m_texqueue_lock;
   XbmcThreads::ConditionVariable m_texqueue_cond;
-  std::queue <struct textureinfo *> m_texqueue;
-  void AllocTextureInternal(struct textureinfo *tex);
-  void DestroyTextureInternal(struct textureinfo *tex);
+  std::queue <struct callbackinfo *> m_texqueue;
 };
 
 class COMXImageFile
@@ -95,7 +94,7 @@ class COMXImageFile
 public:
   COMXImageFile();
   virtual ~COMXImageFile();
-  bool ReadFile(const CStdString& inputFile);
+  bool ReadFile(const CStdString& inputFile, int orientation = 0);
   int  GetOrientation() { return m_orientation; };
   unsigned int GetWidth()  { return m_width; };
   unsigned int GetHeight() { return m_height; };
@@ -103,7 +102,7 @@ class COMXImageFile
   const uint8_t *GetImageBuffer() { return (const uint8_t *)m_image_buffer; };
   const char *GetFilename() { return m_filename; };
 protected:
-  OMX_IMAGE_CODINGTYPE GetCodingType(unsigned int &width, unsigned int &height);
+  OMX_IMAGE_CODINGTYPE GetCodingType(unsigned int &width, unsigned int &height, int orientation);
   uint8_t           *m_image_buffer;
   unsigned long     m_image_size;
   unsigned int      m_width;
@@ -133,6 +132,7 @@ class COMXImageDec
   OMX_BUFFERHEADERTYPE          *m_decoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_decoded_format;
   CCriticalSection              m_OMXSection;
+  bool                          m_success;
 };
 
 class COMXImageEnc
@@ -151,6 +151,7 @@ class COMXImageEnc
   OMX_BUFFERHEADERTYPE          *m_encoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_encoded_format;
   CCriticalSection              m_OMXSection;
+  bool                          m_success;
 };
 
 class COMXImageReEnc
@@ -174,6 +175,7 @@ class COMXImageReEnc
   CCriticalSection              m_OMXSection;
   void                          *m_pDestBuffer;
   unsigned int                  m_nDestAllocSize;
+  bool                          m_success;
 };
 
 class COMXTexture
@@ -184,9 +186,9 @@ class COMXTexture
 
   // Required overrides
   void Close(void);
-  bool Decode(const uint8_t *data, unsigned size, unsigned int width, unsigned int height, void *egl_image, void *egl_display);
+  bool Decode(const uint8_t *data, unsigned size, unsigned int width, unsigned int height, void *egl_image);
 protected:
-  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, void *egl_image, void *egl_display, bool port_settings_changed);
+  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, void *egl_image, bool port_settings_changed);
 
   // Components
   COMXCoreComponent m_omx_decoder;
@@ -198,6 +200,7 @@ class COMXTexture
 
   OMX_BUFFERHEADERTYPE *m_egl_buffer;
   CCriticalSection              m_OMXSection;
+  bool              m_success;
 };
 
 extern COMXImage g_OMXImage;
diff --git a/xbmc/guilib/TexturePi.cpp b/xbmc/guilib/TexturePi.cpp
index 62235cc..ff6f705 100644
--- a/xbmc/guilib/TexturePi.cpp
+++ b/xbmc/guilib/TexturePi.cpp
@@ -142,8 +142,8 @@ bool CPiTexture::LoadFromFileInternal(const CStdString& texturePath, unsigned in
       if (okay)
       {
         m_hasAlpha = false;
-        if (autoRotate && orientation)
-          m_orientation = orientation - 1;
+        if (autoRotate)
+          m_orientation = orientation;
         return true;
       }
     }
diff --git a/xbmc/linux/OMXCore.cpp b/xbmc/linux/OMXCore.cpp
index 01eea74..1481d65 100644
--- a/xbmc/linux/OMXCore.cpp
+++ b/xbmc/linux/OMXCore.cpp
@@ -79,11 +79,6 @@ void COMXCoreTunel::Initialize(COMXCoreComponent *src_component, unsigned int sr
   m_dst_port    = dst_port;
 }
 
-bool COMXCoreTunel::IsInitialized()
-{
-  return m_tunnel_set;
-}
-
 OMX_ERRORTYPE COMXCoreTunel::Deestablish(bool noWait)
 {
   if(!m_src_component || !m_dst_component || !IsInitialized())
@@ -416,30 +411,6 @@ OMX_ERRORTYPE COMXCoreComponent::FreeOutputBuffer(OMX_BUFFERHEADERTYPE *omx_buff
   return omx_err;
 }
 
-unsigned int COMXCoreComponent::GetInputBufferSize()
-{
-  int free = m_input_buffer_count * m_input_buffer_size;
-  return free;
-}
-
-unsigned int COMXCoreComponent::GetOutputBufferSize()
-{
-  int free = m_output_buffer_count * m_output_buffer_size;
-  return free;
-}
-
-unsigned int COMXCoreComponent::GetInputBufferSpace()
-{
-  int free = m_omx_input_avaliable.size() * m_input_buffer_size;
-  return free;
-}
-
-unsigned int COMXCoreComponent::GetOutputBufferSpace()
-{
-  int free = m_omx_output_available.size() * m_output_buffer_size;
-  return free;
-}
-
 void COMXCoreComponent::FlushAll()
 {
   FlushInput();
@@ -448,7 +419,7 @@ void COMXCoreComponent::FlushAll()
 
 void COMXCoreComponent::FlushInput()
 {
-  if(!m_handle)
+  if(!m_handle || m_resource_error)
     return;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
@@ -465,7 +436,7 @@ void COMXCoreComponent::FlushInput()
 
 void COMXCoreComponent::FlushOutput()
 {
-  if(!m_handle)
+  if(!m_handle || m_resource_error)
     return;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
@@ -1142,7 +1113,7 @@ OMX_ERRORTYPE COMXCoreComponent::SetStateForComponent(OMX_STATETYPE state)
   return omx_err;
 }
 
-OMX_STATETYPE COMXCoreComponent::GetState()
+OMX_STATETYPE COMXCoreComponent::GetState() const
 {
   if(!m_handle)
     return (OMX_STATETYPE)0;
@@ -1169,7 +1140,7 @@ OMX_ERRORTYPE COMXCoreComponent::SetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR
   return omx_err;
 }
 
-OMX_ERRORTYPE COMXCoreComponent::GetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR paramStruct)
+OMX_ERRORTYPE COMXCoreComponent::GetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR paramStruct) const
 {
   if(!m_handle)
     return OMX_ErrorUndefined;
@@ -1201,7 +1172,7 @@ OMX_ERRORTYPE COMXCoreComponent::SetConfig(OMX_INDEXTYPE configIndex, OMX_PTR co
   return omx_err;
 }
 
-OMX_ERRORTYPE COMXCoreComponent::GetConfig(OMX_INDEXTYPE configIndex, OMX_PTR configStruct)
+OMX_ERRORTYPE COMXCoreComponent::GetConfig(OMX_INDEXTYPE configIndex, OMX_PTR configStruct) const
 {
   if(!m_handle)
     return OMX_ErrorUndefined;
@@ -1471,11 +1442,6 @@ bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEX
   return true;
 }
 
-bool COMXCoreComponent::IsInitialized()
-{
-  return (m_handle != NULL);
-}
-
 void COMXCoreComponent::ResetEos()
 {
   pthread_mutex_lock(&m_omx_eos_mutex);
diff --git a/xbmc/linux/OMXCore.h b/xbmc/linux/OMXCore.h
index f345c7b..1876059 100644
--- a/xbmc/linux/OMXCore.h
+++ b/xbmc/linux/OMXCore.h
@@ -48,8 +48,6 @@
   (a).nVersion.s.nRevision = OMX_VERSION_REVISION; \
   (a).nVersion.s.nStep = OMX_VERSION_STEP
 
-#include "DllAvFormat.h"
-
 #define OMX_MAX_PORTS 10
 
 typedef struct omx_event {
@@ -70,7 +68,7 @@ class COMXCoreTunel
   ~COMXCoreTunel();
 
   void Initialize(COMXCoreComponent *src_component, unsigned int src_port, COMXCoreComponent *dst_component, unsigned int dst_port);
-  bool IsInitialized();
+  bool IsInitialized() const { return m_tunnel_set; }
   OMX_ERRORTYPE Deestablish(bool noWait = false);
   OMX_ERRORTYPE Establish(bool enable_ports = true, bool disable_ports = false);
 private:
@@ -88,10 +86,10 @@ class COMXCoreComponent
   COMXCoreComponent();
   ~COMXCoreComponent();
 
-  OMX_HANDLETYPE    GetComponent()   { return m_handle;        };
-  unsigned int      GetInputPort()   { return m_input_port;    };
-  unsigned int      GetOutputPort()  { return m_output_port;   };
-  std::string       GetName()        { return m_componentName; };
+  OMX_HANDLETYPE    GetComponent() const { return m_handle; }
+  unsigned int      GetInputPort() const { return m_input_port; }
+  unsigned int      GetOutputPort() const { return m_output_port; }
+  std::string       GetName() const { return m_componentName; }
 
   OMX_ERRORTYPE DisableAllPorts();
   void          RemoveEvent(OMX_EVENTTYPE eEvent, OMX_U32 nData1, OMX_U32 nData2);
@@ -99,18 +97,18 @@ class COMXCoreComponent
   OMX_ERRORTYPE WaitForEvent(OMX_EVENTTYPE event, long timeout = 300);
   OMX_ERRORTYPE WaitForCommand(OMX_U32 command, OMX_U32 nData2, long timeout = 2000);
   OMX_ERRORTYPE SetStateForComponent(OMX_STATETYPE state);
-  OMX_STATETYPE GetState();
+  OMX_STATETYPE GetState() const;
   OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR paramStruct);
-  OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR paramStruct);
+  OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE paramIndex, OMX_PTR paramStruct) const;
   OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE configIndex, OMX_PTR configStruct);
-  OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE configIndex, OMX_PTR configStruct);
+  OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE configIndex, OMX_PTR configStruct) const;
   OMX_ERRORTYPE SendCommand(OMX_COMMANDTYPE cmd, OMX_U32 cmdParam, OMX_PTR cmdParamData);
   OMX_ERRORTYPE EnablePort(unsigned int port, bool wait = true);
   OMX_ERRORTYPE DisablePort(unsigned int port, bool wait = true);
   OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex, OMX_PTR pAppPrivate, void* eglImage);
 
   bool          Initialize( const std::string &component_name, OMX_INDEXTYPE index);
-  bool          IsInitialized();
+  bool          IsInitialized() const { return m_handle != NULL; }
   bool          Deinitialize();
 
   // OMXCore Decoder delegate callback routines.
@@ -135,11 +133,11 @@ class COMXCoreComponent
   OMX_ERRORTYPE FillThisBuffer(OMX_BUFFERHEADERTYPE *omx_buffer);
   OMX_ERRORTYPE FreeOutputBuffer(OMX_BUFFERHEADERTYPE *omx_buffer);
 
-  unsigned int GetInputBufferSize();
-  unsigned int GetOutputBufferSize();
+  unsigned int GetInputBufferSize() const { return m_input_buffer_count * m_input_buffer_size; }
+  unsigned int GetOutputBufferSize() const { return m_output_buffer_count * m_output_buffer_size; }
 
-  unsigned int GetInputBufferSpace();
-  unsigned int GetOutputBufferSpace();
+  unsigned int GetInputBufferSpace() const { return m_omx_input_avaliable.size() * m_input_buffer_size; }
+  unsigned int GetOutputBufferSpace() const { return m_omx_output_available.size() * m_output_buffer_size; }
 
   void FlushAll();
   void FlushInput();
@@ -157,8 +155,8 @@ class COMXCoreComponent
   OMX_ERRORTYPE WaitForInputDone(long timeout=200);
   OMX_ERRORTYPE WaitForOutputDone(long timeout=200);
 
-  bool IsEOS() { return m_eos; };
-  bool BadState() { return m_resource_error; };
+  bool IsEOS() const { return m_eos; }
+  bool BadState() const { return m_resource_error; }
   void ResetEos();
   void IgnoreNextError(OMX_S32 error) { m_ignore_error = error; }
 
diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 8958ba0..a3531c5 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -23,6 +23,7 @@
 
 #include "utils/log.h"
 #include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
 
 #include "cores/omxplayer/OMXImage.h"
 
@@ -32,6 +33,7 @@ CRBP::CRBP()
   m_omx_initialized = false;
   m_DllBcmHost      = new DllBcmHost();
   m_OMX             = new COMXCore();
+  m_element = 0;
 }
 
 CRBP::~CRBP()
@@ -43,12 +45,19 @@ CRBP::~CRBP()
 
 bool CRBP::Initialize()
 {
+  CSingleLock lock (m_critSection);
+  if (m_initialized)
+    return true;
+
   m_initialized = m_DllBcmHost->Load();
   if(!m_initialized)
     return false;
 
   m_DllBcmHost->bcm_host_init();
 
+  uint32_t vc_image_ptr;
+  m_resource = vc_dispmanx_resource_create( VC_IMAGE_RGB565, 1, 1, &vc_image_ptr );
+
   m_omx_initialized = m_OMX->Initialize();
   if(!m_omx_initialized)
     return false;
@@ -56,13 +65,28 @@ bool CRBP::Initialize()
   char response[80] = "";
   m_arm_mem = 0;
   m_gpu_mem = 0;
+  m_codec_mpg2_enabled = false;
+  m_codec_wvc1_enabled = false;
+
   if (vc_gencmd(response, sizeof response, "get_mem arm") == 0)
     vc_gencmd_number_property(response, "arm", &m_arm_mem);
   if (vc_gencmd(response, sizeof response, "get_mem gpu") == 0)
     vc_gencmd_number_property(response, "gpu", &m_gpu_mem);
 
-  if (g_advancedSettings.m_streamSilence)
-    vc_gencmd(response, sizeof response, "force_audio hdmi 1");
+  if (vc_gencmd(response, sizeof response, "codec_enabled MPG2") == 0)
+    m_codec_mpg2_enabled = strcmp("MPG2=enabled", response) == 0;
+  if (vc_gencmd(response, sizeof response, "codec_enabled WVC1") == 0)
+    m_codec_wvc1_enabled = strcmp("WVC1=enabled", response) == 0;
+
+  if (m_gpu_mem < 128)
+    setenv("V3D_DOUBLE_BUFFER", "1", 1);
+
+  m_gui_resolution_limit = g_guiSettings.GetInt("videoscreen.limitgui");
+  if (!m_gui_resolution_limit)
+    m_gui_resolution_limit = m_gpu_mem < 128 ? 720:1080;
+
+  if (g_advancedSettings.m_cacheMemBufferSize == ~0U)
+    g_advancedSettings.m_cacheMemBufferSize = m_arm_mem < 256 ? 1024 * 1024 * 2 : 1024 * 1024 * 20;
 
   g_OMXImage.Initialize();
   m_omx_image_init = true;
@@ -71,11 +95,18 @@ bool CRBP::Initialize()
 
 void CRBP::LogFirmwareVerison()
 {
-  char  response[160];
+  char  response[1024];
   m_DllBcmHost->vc_gencmd(response, sizeof response, "version");
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s", response);
-  CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB", m_arm_mem, m_gpu_mem);
+  CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB MPG2:%d WVC1:%d", m_arm_mem, m_gpu_mem, m_codec_mpg2_enabled, m_codec_wvc1_enabled);
+  CLog::Log(LOGNOTICE, "cacheMemBufferSize: %dMB",  g_advancedSettings.m_cacheMemBufferSize >> 20);
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config int");
+  response[sizeof(response) - 1] = '\0';
+  CLog::Log(LOGNOTICE, "Config:\n%s", response);
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config str");
+  response[sizeof(response) - 1] = '\0';
+  CLog::Log(LOGNOTICE, "Config:\n%s", response);
 }
 
 void CRBP::GetDisplaySize(int &width, int &height)
@@ -134,6 +165,36 @@ unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool sw
   return image;
 }
 
+void CRBP::WaitVsync(void)
+{
+  DISPMANX_DISPLAY_HANDLE_T display = vc_dispmanx_display_open( 0 /*screen*/ );
+  DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
+
+  VC_DISPMANX_ALPHA_T alpha = { (DISPMANX_FLAGS_ALPHA_T)(DISPMANX_FLAGS_ALPHA_FROM_SOURCE | DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS), 120, /*alpha 0->255*/ 0 };
+  VC_RECT_T       src_rect;
+  VC_RECT_T       dst_rect;
+  vc_dispmanx_rect_set( &src_rect, 0, 0, 1 << 16, 1 << 16 );
+  vc_dispmanx_rect_set( &dst_rect, 0, 0, 1, 1 );
+
+  if (m_element)
+    vc_dispmanx_element_remove( update, m_element );
+
+  m_element = vc_dispmanx_element_add( update,
+                                            display,
+                                            2000,               // layer
+                                            &dst_rect,
+                                            m_resource,
+                                            &src_rect,
+                                            DISPMANX_PROTECTION_NONE,
+                                            &alpha,
+                                            NULL,             // clamp
+                                            (DISPMANX_TRANSFORM_T)0 );
+
+  vc_dispmanx_update_submit_sync(update);
+  vc_dispmanx_display_close( display );
+}
+
+
 void CRBP::Deinitialize()
 {
   if (m_omx_image_init)
@@ -151,4 +212,18 @@ void CRBP::Deinitialize()
   m_initialized     = false;
   m_omx_initialized = false;
 }
+
+double CRBP::AdjustHDMIClock(double adjust)
+{
+  char response[80];
+  vc_gencmd(response, sizeof response, "hdmi_adjust_clock %f", adjust);
+  float new_adjust = 1.0f;
+  char *p = strchr(response, '=');
+  if (p)
+    new_adjust = atof(p+1);
+  CLog::Log(LOGDEBUG, "CRBP::%s(%.4f) = %.4f", __func__, adjust, new_adjust);
+  return new_adjust;
+}
+
+
 #endif
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index 5246f1f..5408f1f 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -37,6 +37,7 @@
 #if defined(TARGET_RASPBERRY_PI)
 #include "DllBCM.h"
 #include "OMXCore.h"
+#include "threads/CriticalSection.h"
 
 class CRBP
 {
@@ -49,10 +50,15 @@ class CRBP
   void Deinitialize();
   int GetArmMem() { return m_arm_mem; }
   int GetGpuMem() { return m_gpu_mem; }
+  bool GetCodecMpg2() { return m_codec_mpg2_enabled; }
+  bool GetCodecWvc1() { return m_codec_wvc1_enabled; }
   void GetDisplaySize(int &width, int &height);
+  int GetGUIResolutionLimit() { return m_gui_resolution_limit; }
   // stride can be null for packed output
   unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
   DllOMX *GetDllOMX() { return m_OMX ? m_OMX->GetDll() : NULL; }
+  void WaitVsync();
+  double AdjustHDMIClock(double adjust);
 
 private:
   DllBcmHost *m_DllBcmHost;
@@ -61,8 +67,14 @@ class CRBP
   bool       m_omx_image_init;
   int        m_arm_mem;
   int        m_gpu_mem;
+  int        m_gui_resolution_limit;
+  bool       m_codec_mpg2_enabled;
+  bool       m_codec_wvc1_enabled;
   COMXCore   *m_OMX;
+  DISPMANX_RESOURCE_HANDLE_T m_resource;
+  DISPMANX_ELEMENT_HANDLE_T m_element;
   class DllLibOMXCore;
+  CCriticalSection m_critSection;
 };
 
 extern CRBP g_RBP;

From 2855d355fb5a5e4bdc4b56b0018e8a25e961a43c Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 12:08:10 +0100
Subject: [PATCH 32/38] Sync omxplayer with dvdplayer

---
 xbmc/cores/omxplayer/OMXPlayer.cpp | 517 ++++++++++++++++++++++++++++++++++++-
 xbmc/cores/omxplayer/OMXPlayer.h   |  71 +++++
 2 files changed, 583 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index 9582eb9..92bbfdc 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -18,6 +18,14 @@
  *
  */
 
+/* PLEX */
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/foreach.hpp>
+#include <boost/enable_shared_from_this.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/locks.hpp>
+/* END PLEX */
+
 #include "threads/SystemClock.h"
 #include "system.h"
 
@@ -120,6 +128,19 @@
 #include "LangInfo.h"
 #include "ApplicationMessenger.h"
 
+/* PLEX */
+#include "FileSystem/PlexDirectory.h"
+#include "Client/PlexServerManager.h"
+
+#include <boost/lexical_cast.hpp>
+
+#include "Client/PlexMediaServerClient.h"
+#include "ApplicationMessenger.h"
+#include "Client/PlexTranscoderClient.h"
+#include "PlexApplication.h"
+#include "FileSystem/PlexFile.h"
+/* END PLEX */
+
 // video not playing from clock, but stepped
 #define TP(speed)  ((speed) < 0 || (speed) > 4*DVD_PLAYSPEED_NORMAL)
 // audio not playing
@@ -444,6 +465,11 @@ COMXPlayer::COMXPlayer(IPlayerCallback &callback)
       m_omxPlayerAudio(&m_av_clock, m_messenger),
       m_dvdPlayerSubtitle(&m_overlayContainer),
       m_dvdPlayerTeletext(),
+      /* PLEX */
+      m_hidingSub(false),
+      m_vobsubToDisplay(-1),
+      m_readRate(0),
+      /* END PLEX */
       m_ready(true)
 {
   m_pDemuxer          = NULL;
@@ -522,7 +548,17 @@ bool COMXPlayer::OpenFile(const CFileItem &file, const CPlayerOptions &options)
       {
         dialog->Show();
         while(!m_ready.WaitMSec(100))
+        {
+          /* PLEX */
+          if (dialog->IsCanceled())
+          {
+            m_bStop = true;
+            Abort();
+          }
+          /* END PLEX */
+
           g_windowManager.ProcessRenderLoop(false);
+        }
         dialog->Close();
       }
     }
@@ -566,7 +602,7 @@ bool COMXPlayer::CloseFile()
   // since this main thread cleans up all other resources and threads
   // we are done after the StopThread call
   StopThread();
-  
+
   m_Edl.Clear();
   m_EdlAutoSkipMarkers.Clear();
 
@@ -615,13 +651,25 @@ bool COMXPlayer::OpenInputStream()
   // before creating the input stream, if this is an HLS playlist then get the
   // most appropriate bitrate based on our network settings
   // ensure to strip off the url options by using a temp CURL object
+#ifndef __PLEX__
   if (filename.Left(7) == "http://" && CURL(filename).GetFileName().Right(5) == ".m3u8")
+#else
+  CURL url(filename);
+  if (url.GetFileName().Right(5) == ".m3u8" && (url.GetProtocol() == "http" || url.GetProtocol() == "https" || url.GetProtocol() == "plexserver"))
+#endif
   {
     // get the available bandwidth (as per user settings)
     int maxrate = g_guiSettings.GetInt("network.bandwidth");
     if(maxrate <= 0)
       maxrate = INT_MAX;
 
+    /* PLEX */
+    if (m_item.GetProperty("plexDidTranscode").asBoolean())
+      maxrate = INT_MAX;
+    else
+      maxrate = CPlexTranscoderClient::getBandwidthForQuality(g_guiSettings.GetInt("plexmediaserver.onlinemediaquality"));
+    /* END PLEX */
+
     // determine the most appropriate stream
     m_filename = PLAYLIST::CPlayListM3U::GetBestBandwidthStream(m_filename, (size_t)maxrate);
   }
@@ -652,6 +700,7 @@ bool COMXPlayer::OpenInputStream()
   &&  !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV)
   &&  !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_HTSP))
   {
+#ifndef __PLEX__
     // find any available external subtitles
     std::vector<CStdString> filenames;
     CUtil::ScanForExternalSubtitles( m_filename, filenames );
@@ -678,7 +727,117 @@ bool COMXPlayer::OpenInputStream()
         }
       }
     } // end loop over all subtitle files
+#else
+    CFileItemPtr part = m_item.m_selectedMediaPart;
+    if (part)
+    {
+      CFileItemPtr   lastIdxStream;
+      int            lastIdxSource = -1;
+
+      BOOST_FOREACH(CFileItemPtr stream, part->m_mediaPartStreams)
+      {
+        if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_SUBTITLE &&
+            (stream->GetProperty("index").asInteger(-1) == -1) &&
+          (!g_guiSettings.GetBool("plexmediaserver.transcodesubtitles")))
+        {
+          OMXSelectionStream s;
+          s.type     = STREAM_SUBTITLE;
+          s.id       = stream->GetProperty("subIndex").asInteger() >= 0 ? stream->GetProperty("subIndex").asInteger() : stream->GetProperty("id").asInteger();
+          s.plexID   = stream->GetProperty("id").asInteger();
+          s.filename = stream->GetProperty("key").asString();
+          s.name     = stream->GetProperty("language").asString();
+
+          if (stream->GetProperty("codec").asString() == "idx")
+          {
+            // All IDX streams have the same source.
+            if (lastIdxStream)
+              s.source = lastIdxSource;
+            else
+              s.source = m_SelectionStreams.Source(STREAM_SOURCE_DEMUX_SUB, stream->GetProperty("key").asString());
+          }
+          else
+          {
+            // New file, new source.
+            s.source = m_SelectionStreams.Source(STREAM_SOURCE_TEXT, stream->GetProperty("key").asString());
+          }
+
+          // Cache the subtitle locally. Since multiple streams can be served out of a single file,
+          // let's not download it multiple times, one for each stream.
+          //
+          CFileItemPtr idxStream = stream;
+          if (lastIdxStream)
+            idxStream = lastIdxStream;
+
+          CStdString path = "special://temp/subtitle.plex." + idxStream->GetProperty("id").asString() + "." + idxStream->GetProperty("codec").asString();
+          CLog::Log(LOGINFO, "Considering caching Plex subtitle locally for stream %s (codec: %s) to %s (exists: %d)",
+                    idxStream->GetProperty("id").asString().c_str(),
+                    idxStream->GetProperty("codec").asString().c_str(),
+                    path.c_str(),
+                    CFile::Exists(path));
+
+          CURL newUrl(idxStream->GetProperty("key").asString());
+          CStdString encoding = g_langInfo.GetSubtitleCharSet();
+          if (encoding == "UTF-8")
+            newUrl.SetOption("encoding", "utf-8");
+
+
+          /* PLEX */
+          if (CFile::Exists(path))
+          {
+            s.filename = path;
+            m_SelectionStreams.Update(s);
+          }
+          else
+          {
+            CURL plexUrl(newUrl);
+            CPlexFile::BuildHTTPURL(plexUrl);
+            if (g_plexApplication.busy.blockWaitingForJob(new CPlexDownloadFileJob(plexUrl.Get(), path), NULL))
+            {
+              CLog::Log(LOGDEBUG,"file %s was downloaded successfully", path.c_str());
+              s.filename = path;
+              m_SelectionStreams.Update(s);
+            }
+            else
+            {
+              CLog::Log(LOGERROR,"Failed to download  %s", path.c_str());
+              return false;
+            }
+          }
+          /* END PLEX */
+
+          // If it's an IDX, we need to cache the SUB file as well.
+          if (idxStream->GetProperty("codec").asString() == "idx")
+          {
+            CStdString path = "special://temp/subtitle.plex." + idxStream->GetProperty("id").asString() + ".sub";
+            if (CFile::Exists(path) == false)
+            {
+              CLog::Log(LOGINFO, "Caching Plex subtitle locally for stream %lld to %s", idxStream->GetProperty("id").asInteger(), path.c_str());
+
+              CURL subUrl(idxStream->GetProperty("key").asString());
+              subUrl.SetFileName(subUrl.GetFileName() + ".sub");
+
+              CURL plexUrl(subUrl);
+              CPlexFile::BuildHTTPURL(plexUrl);
+
+              if (g_plexApplication.busy.blockWaitingForJob(new CPlexDownloadFileJob(plexUrl.Get(), path), NULL))
+              {
+                CLog::Log(LOGDEBUG,"file %s was downloaded successfully", path.c_str());
+              }
+              else
+              {
+                CLog::Log(LOGERROR,"Failed to download  %s", path.c_str());
+                return false;
+              }
+            }
 
+            // Remember the last IDX stream.
+            lastIdxStream = idxStream;
+            lastIdxSource = s.source;
+          }
+        }
+      }
+    }
+#endif
     g_settings.m_currentVideoSettings.m_SubtitleCached = true;
   }
 
@@ -738,14 +897,27 @@ bool COMXPlayer::OpenDemuxStream()
   m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_NAV);
   m_SelectionStreams.Update(m_pInputStream, m_pDemuxer);
 
+  // Update Plex streams from the demuxer.
+  RelinkPlexStreams();
+  /* END PLEX */
+
+#if 0
   int64_t len = m_pInputStream->GetLength();
   int64_t tim = m_pDemuxer->GetStreamLength();
   if(len > 0 && tim > 0)
     m_pInputStream->SetReadRate(len * 1000 / tim);
+#else
+  /* There is probably a good reason why we limit the readRate in upsteam
+   * But I am just going to ignore that until I run into any problems.
+   */
+  m_readRate = g_advancedSettings.m_cacheReadRate;
+  m_pInputStream->SetReadRate(m_readRate);
+#endif
 
   return true;
 }
 
+#ifndef __PLEX__
 void COMXPlayer::OpenDefaultStreams(bool reset)
 {
   // if input stream dictate, we will open later
@@ -811,12 +983,13 @@ void COMXPlayer::OpenDefaultStreams(bool reset)
   if(!valid)
     CloseTeletextStream(true);
 }
+#endif
 
 bool COMXPlayer::ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream)
 {
 
   // check if we should read from subtitle demuxer
-  if(m_dvdPlayerSubtitle.AcceptsData() &&  m_pSubtitleDemuxer)
+  if(m_dvdPlayerSubtitle.AcceptsData() && m_pSubtitleDemuxer)
   {
     if(m_pSubtitleDemuxer)
       packet = m_pSubtitleDemuxer->Read();
@@ -886,6 +1059,27 @@ bool COMXPlayer::ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream)
       {
         m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_DEMUX);
         m_SelectionStreams.Update(m_pInputStream, m_pDemuxer);
+
+        /* PLEX */
+        // Make sure the Plex streams are still linked.
+        RelinkPlexStreams();
+
+        if (m_vobsubToDisplay != -1)
+        {
+          int count = m_SelectionStreams.Count(STREAM_SUBTITLE);
+          for (int i = 0; i<count; i++)
+          {
+            OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, i);
+            if (s.plexID == m_vobsubToDisplay && OpenSubtitleStream(s.id, s.source))
+            {
+              OpenSubtitleStream(s.id, s.source);
+              break;
+            }
+          }
+
+          m_vobsubToDisplay = -1;
+        }
+        /* END PLEX */
       }
     }
     return true;
@@ -989,11 +1183,30 @@ void COMXPlayer::Process()
   bool bOmxSentEOFs = false;
   float m_threshold = 0.2f;
 
+#ifndef __PLEX__
   if (!OpenInputStream())
   {
     m_bAbortRequest = true;
     return;
   }
+#else
+  m_EndPlaybackRequest = false;
+
+  try
+  {
+    if (!OpenInputStream())
+    {
+      m_bAbortRequest = true;
+      return;
+    }
+  }
+  catch (CRedirectException* ex)
+  {
+    CApplicationMessenger::Get().RestartWithNewPlayer(0, ex->m_pNewUrl->Get());
+    delete ex;
+    return;
+  }
+#endif
 
   if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
   {
@@ -1037,7 +1250,9 @@ void COMXPlayer::Process()
   if (m_CurrentVideo.id >= 0 && m_CurrentVideo.hint.fpsrate > 0 && m_CurrentVideo.hint.fpsscale > 0)
   {
     fFramesPerSecond = (float)m_CurrentVideo.hint.fpsrate / (float)m_CurrentVideo.hint.fpsscale;
+#ifndef __PLEX__
     m_Edl.ReadEditDecisionLists(m_filename, fFramesPerSecond, m_CurrentVideo.hint.height);
+#endif
   }
 
   /*
@@ -1447,6 +1662,16 @@ void COMXPlayer::Process()
     // check if in a cut or commercial break that should be automatically skipped
     CheckAutoSceneSkip();
   }
+
+  /* PLEX */
+  // We're done, if we transcoded we need to stop that now
+  if (m_item.GetProperty("plexDidTranscode").asBoolean() && g_plexApplication.serverManager)
+  {
+    CPlexServerPtr server = g_plexApplication.serverManager->FindByUUID(m_item.GetProperty("plexserver").asString());
+    if (server)
+      g_plexApplication.mediaServerClient->StopTranscodeSession(server);
+  }
+  /* END PLEX */
 }
 
 bool COMXPlayer::CheckDelayedChannelEntry(void)
@@ -2213,7 +2438,7 @@ void COMXPlayer::OnExit()
   // if we didn't stop playing, advance to the next item in xbmc's playlist
   if(m_PlayerOptions.identify == false)
   {
-    if (m_bAbortRequest)
+    if (m_bAbortRequest && !m_EndPlaybackRequest)
       m_callback.OnPlayBackStopped();
     else
       m_callback.OnPlayBackEnded();
@@ -2561,11 +2786,14 @@ void COMXPlayer::SetCaching(ECacheState state)
 {
   if(state == CACHESTATE_FLUSH)
   {
+#ifndef __PLEX__ // This makes little sense for streams, ask it to always fill my buffer instead
     double level, delay, offset;
     if(GetCachingTimes(level, delay, offset))
       state = CACHESTATE_FULL;
     else
       state = CACHESTATE_INIT;
+#endif
+    state = CACHESTATE_FULL;
   }
 
   if(m_caching == state)
@@ -2690,7 +2918,29 @@ void COMXPlayer::Seek(bool bPlus, bool bLargeStep)
     }
   }
 
+  /* PLEX */
   int64_t seek;
+#ifdef __PLEX__
+  if (bLargeStep)
+    seek = bPlus ? g_advancedSettings.m_videoTimeSeekForwardBig : g_advancedSettings.m_videoTimeSeekBackwardBig;
+  else
+    seek = bPlus ? g_advancedSettings.m_videoTimeSeekForward : g_advancedSettings.m_videoTimeSeekBackward;
+  seek *= 1000;
+
+  // if we are over movie length, then just move one sec before the end
+  // that's the maximum seek offset DVDPlayer will take into account.
+  if (seek + GetTime() > GetTotalTimeInMsec())
+  {
+    m_EndPlaybackRequest = true;
+    //seek = GetTotalTimeInMsec() - 1000;
+    CloseFile();
+    //return;
+  }
+  else
+  {
+    seek += GetTime();
+  }
+#else
   if (g_advancedSettings.m_videoUseTimeSeeking && GetTotalTime() > 2000*g_advancedSettings.m_videoTimeSeekForwardBig)
   {
     if (bLargeStep)
@@ -2709,7 +2959,8 @@ void COMXPlayer::Seek(bool bPlus, bool bLargeStep)
       percent = bPlus ? g_advancedSettings.m_videoPercentSeekForward : g_advancedSettings.m_videoPercentSeekBackward;
     seek = (int64_t)(GetTotalTimeInMsec()*(GetPercentage()+percent)/100);
   }
-
+#endif
+  /* END PLEX */
   bool restore = true;
   if (m_Edl.HasCut())
   {
@@ -2938,6 +3189,16 @@ void COMXPlayer::GetSubtitleLanguage(int iStream, CStdString &strStreamLang)
 void COMXPlayer::SetSubtitle(int iStream)
 {
   m_messenger.Put(new CDVDMsgPlayerSetSubtitleStream(iStream));
+
+  /* PLEX */
+  // Return the ID of the selected stream.
+  OMXStreamLock lock(this);
+  OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, iStream);
+
+  // Send the change to the Media Server.
+  CFileItemPtr item = g_application.CurrentFileItemPtr();
+  g_plexApplication.mediaServerClient->SelectStream(item, GetPlexMediaPartID(), g_settings.m_currentVideoSettings.m_SubtitleOn ? s.plexID : 0, -1);
+  /* END PLEX */
 }
 
 bool COMXPlayer::GetSubtitleVisible()
@@ -2958,6 +3219,17 @@ void COMXPlayer::SetSubtitleVisible(bool bVisible)
 {
   g_settings.m_currentVideoSettings.m_SubtitleOn = bVisible;
   m_messenger.Put(new CDVDMsgBool(CDVDMsg::PLAYER_SET_SUBTITLESTREAM_VISIBLE, bVisible));
+
+  /* PLEX */
+  // Send the change to the Media Server.
+  CFileItemPtr item = g_application.CurrentFileItemPtr();
+  int partID = GetPlexMediaPartID();
+  int subtitleStreamID = GetSubtitlePlexID();
+
+  // Don't send the message over if we're just hiding the initial sub.
+  if (m_hidingSub == false)
+    g_plexApplication.mediaServerClient->SelectStream(item, partID, g_settings.m_currentVideoSettings.m_SubtitleOn ? subtitleStreamID : 0, -1);
+  /* END PLEX */
 }
 
 int COMXPlayer::GetAudioStreamCount()
@@ -2984,11 +3256,19 @@ void COMXPlayer::GetAudioStreamName(int iStream, CStdString &strStreamName)
   if(s.type == STREAM_NONE)
     strStreamName += " (Invalid)";
 }
- 
+
 void COMXPlayer::SetAudioStream(int iStream)
 {
   m_messenger.Put(new CDVDMsgPlayerSetAudioStream(iStream));
   SynchronizeDemuxer(100);
+
+  /* PLEX */
+  OMXStreamLock lock(this);
+
+  // Notify the Plex Media Server.
+  CFileItemPtr item = g_application.CurrentFileItemPtr();
+  g_plexApplication.mediaServerClient->SelectStream(item, GetPlexMediaPartID(), -1, GetAudioStreamPlexID());
+  /* END PLEX */
 }
 
 TextCacheStruct_t* COMXPlayer::GetTeletextCache()
@@ -3208,6 +3488,14 @@ bool COMXPlayer::OpenVideoStream(int iStream, int source, bool reset)
 
 bool COMXPlayer::OpenSubtitleStream(int iStream, int source)
 {
+  /* PLEX */
+  if (g_guiSettings.GetBool("plexmediaserver.transcodesubtitles") && m_item.GetProperty("plexDidTranscode").asBoolean())
+  {
+    CLog::Log(LOGNOTICE, "Skipping Subtitle stream: %i source: %i, subtitles are transcoded", iStream, source);
+    return true;
+  }
+  /* END PLEX */
+
   CLog::Log(LOGNOTICE, "Opening Subtitle stream: %i source: %i", iStream, source);
 
   CDemuxStream* pStream = NULL;
@@ -4413,4 +4701,223 @@ void COMXPlayer::GetSubtitleCapabilities(std::vector<int> &subCaps)
   subCaps.push_back(IPC_SUBS_ALL);
 }
 
+/* PLEX */
+void COMXPlayer::OpenDefaultStreams(bool reset)
+{
+  int  count;
+  bool valid;
+  OMXSelectionStream st;
+
+  // open video stream
+  count = m_SelectionStreams.Count(STREAM_VIDEO);
+  valid = false;
+
+  if(!valid
+  && m_SelectionStreams.Get(STREAM_VIDEO, CDemuxStream::FLAG_DEFAULT, st))
+  {
+    if(OpenVideoStream(st.id, st.source, reset))
+      valid = true;
+    else
+      CLog::Log(LOGWARNING, "%s - failed to open default stream (%d)", __FUNCTION__, st.id);
+  }
+
+  for(int i = 0;i<count && !valid;i++)
+  {
+    OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_VIDEO, i);
+    if(OpenVideoStream(s.id, s.source, reset))
+      valid = true;
+  }
+  if(!valid)
+    CloseVideoStream(true);
+
+  if(!m_PlayerOptions.video_only)
+  {
+    // open audio stream
+    count = m_SelectionStreams.Count(STREAM_AUDIO);
+    valid = false;
+
+    // Pick selected audio stream.
+    CFileItemPtr part = m_item.m_selectedMediaPart;
+    if (part)
+    {
+      BOOST_FOREACH(CFileItemPtr stream, part->m_mediaPartStreams)
+      {
+        int streamType = stream->GetProperty("streamType").asInteger();
+        int streamId = stream->GetProperty("id").asInteger();
+        std::string streamLang = stream->GetProperty("language").asString();
+        bool selected = stream->GetProperty("selected").asBoolean();
+        CLog::Log(LOGINFO, "COMXPlayer::OpenDefaultStreams Considering Plex stream %d[%s] of type %d (selected: %d)",
+                  streamId, streamLang.c_str(), streamType, selected);
+
+        // If we've found the selected audio stream...
+        if (streamType == PLEX_STREAM_AUDIO && selected)
+        {
+          // ...see if we can match it up with our stream.
+          count = m_SelectionStreams.Count(STREAM_AUDIO);
+          for (int i=0; i<count && !valid; i++)
+          {
+            OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, i);
+            if (s.plexID == streamId && OpenAudioStream(s.id, s.source, reset))
+            {
+              CLog::Log(LOGINFO, "COMXPlayer::OpenDefaultStreams selected stream %d[%s]", streamId, streamLang.c_str());
+              valid = true;
+            }
+          }
+        }
+
+        if (valid) break;
+      }
+    }
+
+    // If that didn't work, just pick the first valid stream.
+    for(int i = 0; i<count && !valid; i++)
+    {
+      OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, i);
+      if(OpenAudioStream(s.id, s.source, reset))
+      {
+        CLog::Log(LOGINFO, "COMXPlayer::OpenDefaultStreams failed to find the stream based plexId, instead you will get %d[%s]", s.plexID, s.language.c_str());
+        valid = true;
+      }
+    }
+
+    // If we don't have an audio stream, close it.
+    if(!valid)
+      CloseAudioStream(true);
+  }
+
+  /* If user have selected to transcode subtitles we should not show it again here */
+  if (m_item.GetProperty("plexDidTranscode").asBoolean() && g_guiSettings.GetBool("plexmediaserver.transcodesubtitles"))
+    return;
+
+  // open subtitle stream
+  valid = false;
+  m_omxPlayerVideo.EnableSubtitle(true);
+
+  // Open subtitle stream.
+  CFileItemPtr part = m_item.m_selectedMediaPart;
+  if (part)
+  {
+    BOOST_FOREACH(CFileItemPtr stream, part->m_mediaPartStreams)
+    {
+      // If we've found the selected subtitle stream...
+      if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_SUBTITLE && stream->GetProperty("selected").asBoolean())
+      {
+        count = m_SelectionStreams.Count(STREAM_SUBTITLE);
+
+        for (int i = 0; i<count && !valid; i++)
+        {
+          OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, i);
+          if (s.plexID == stream->GetProperty("id").asInteger() && OpenSubtitleStream(s.id, s.source))
+          {
+            // We're going to need to open this later.
+            if (s.source == STREAM_SOURCE_DEMUX_SUB)
+              m_vobsubToDisplay = s.plexID;
+
+            valid = true;
+          }
+        }
+      }
+
+      if (valid) break;
+    }
+
+    // If that didn't pick one, just open the first stream and make it invisible.
+    if (valid == false && count > 0)
+    {
+      OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, 0);
+      OpenSubtitleStream(s.id, s.source);
+
+      if (s.source == STREAM_SOURCE_DEMUX_SUB)
+        m_vobsubToDisplay = s.plexID;
+    }
+
+    // Set them on/off based on whether we found one.
+    g_settings.m_currentVideoSettings.m_SubtitleOn = valid;
+
+    // We don't have subtitles to show, close.
+    if (valid == false)
+    {
+      m_hidingSub = true;
+      SetSubtitleVisible(false);
+      m_hidingSub = false;
+    }
+  }
+}
+
+void COMXPlayer::RelinkPlexStreams()
+{
+  CFileItemPtr part = m_item.m_selectedMediaPart;
+  if (part)
+  {
+    BOOST_FOREACH(CFileItemPtr stream, part->m_mediaPartStreams)
+    {
+      StreamType type = STREAM_NONE;
+
+      if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_SUBTITLE)
+        type = STREAM_SUBTITLE;
+      else if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_AUDIO)
+        type = STREAM_AUDIO;
+
+      if (type != STREAM_NONE)
+      {
+        // Look for the right index and set the Plex stream ID.
+        int count = m_SelectionStreams.Count(type);
+        for (int i=0; i<count; i++)
+        {
+          OMXSelectionStream& s = m_SelectionStreams.Get(type, i);
+
+          if (s.id == stream->GetProperty("index").asInteger() || s.id == stream->GetProperty("subIndex").asInteger())
+          {
+            s.plexID = stream->GetProperty("id").asInteger();
+            s.language = stream->GetProperty("language").asString();
+
+            if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_SUBTITLE)
+              s.name = stream->GetProperty("language").asString();
+          }
+        }
+      }
+    }
+  }
+}
+
+int COMXPlayer::GetAudioStreamPlexID()
+{
+  OMXSelectionStream& stream = m_SelectionStreams.Get(STREAM_AUDIO, m_SelectionStreams.IndexOf(STREAM_AUDIO, *this));
+  return stream.plexID;
+}
+
+int COMXPlayer::GetSubtitlePlexID()
+{
+  OMXSelectionStream& stream = m_SelectionStreams.Get(STREAM_SUBTITLE, m_SelectionStreams.IndexOf(STREAM_SUBTITLE, *this));
+  return stream.plexID;
+}
+
+void COMXPlayer::SetAudioStreamPlexID(int plexID)
+{
+  std::vector<OMXSelectionStream> audiost = m_SelectionStreams.Get(STREAM_AUDIO);
+  for (int i = 0; i < audiost.size(); i ++)
+  {
+    if (audiost[i].plexID == plexID)
+    {
+      SetAudioStream(audiost[i].type_index);
+      break;
+    }
+  }
+}
+
+void COMXPlayer::SetSubtitleStreamPlexID(int plexID)
+{
+  std::vector<OMXSelectionStream> subst = m_SelectionStreams.Get(STREAM_SUBTITLE);
+  for (int i = 0; i < subst.size(); i ++)
+  {
+    if (subst[i].plexID == plexID)
+    {
+      SetSubtitle(subst[i].type_index);
+      break;
+    }
+  }
+}
+
+/* END PLEX */
+
 #endif
diff --git a/xbmc/cores/omxplayer/OMXPlayer.h b/xbmc/cores/omxplayer/OMXPlayer.h
index 0f5ce6b..6411104 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.h
+++ b/xbmc/cores/omxplayer/OMXPlayer.h
@@ -106,7 +106,11 @@ class COMXCurrentStream
   }
 };
 
+#ifndef __PLEX__
 typedef struct
+#else
+struct OMXSelectionStream
+#endif
 {
   StreamType   type;
   int          type_index;
@@ -119,7 +123,41 @@ typedef struct
   int          id;
   std::string  codec;
   int          channels;
+
+
+  /* PLEX */
+  OMXSelectionStream()
+    : plexID(-1)
+    , plexSubIndex(-1)
+  {}
+
+  OMXSelectionStream& operator=(const OMXSelectionStream& other)
+  {
+    // Preserve Plex ID by *not* copying over plexID member
+    type = other.type;
+    filename = other.filename;
+
+    // Stream language from Plex stream.
+    if (type != STREAM_SUBTITLE)
+      name = other.name;
+    else if (language.size() != 3)
+      name = language;
+
+    language = other.language;
+    id = other.id;
+    flags = other.flags;
+    source = other.source;
+
+    return *this;
+  }
+  int plexID;
+  int plexSubIndex;
+  /* END PLEX */
+#ifndef __PLEX__
 } OMXSelectionStream;
+#else
+};
+#endif
 
 typedef std::vector<OMXSelectionStream> OMXSelectionStreams;
 
@@ -275,6 +313,23 @@ class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
   virtual void  GetScalingMethods(std::vector<int> &scalingMethods);
   virtual void  GetAudioCapabilities(std::vector<int> &audioCaps);
   virtual void  GetSubtitleCapabilities(std::vector<int> &subCaps);
+
+  /* PLEX */
+  virtual int GetSubtitlePlexID();
+  virtual int GetAudioStreamPlexID();
+  virtual void SetAudioStreamPlexID(int plexID);
+  virtual void SetSubtitleStreamPlexID(int plexID);
+  virtual int GetPlexMediaPartID()
+  {
+    CFileItemPtr part = m_item.m_selectedMediaPart;
+    if (part)
+      return part->GetProperty("id").asInteger();
+
+    return -1;
+  }
+  virtual bool CanOpenAsync() { return false; }
+  virtual void Abort() { m_bAbortRequest = true; }
+  /* END PLEX */
 protected:
   friend class COMXSelectionStreams;
 
@@ -351,6 +406,10 @@ class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
 
   bool m_bAbortRequest;
 
+  /* PLEX */
+  bool m_EndPlaybackRequest;
+  /* END PLEX */
+
   std::string           m_filename; // holds the actual filename
   std::string  m_mimetype;  // hold a hint to what content file contains (mime type)
   ECacheState  m_caching;
@@ -507,6 +566,18 @@ class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
 
   CPlayerOptions          m_PlayerOptions;
 
+  /* PLEX */
+  void RelinkPlexStreams();
+
+  CStdString   m_strError;
+  CFileItemPtr m_itemWithDetails;
+  bool         m_hidingSub;
+  int          m_vobsubToDisplay;
+
+  unsigned int m_readRate;
+  void UpdateReadRate();
+  /* END PLEX */
+
   bool m_HasVideo;
   bool m_HasAudio;
 };

From 1c80fea5ee2856ed92a99052775ea2e7d65df3fc Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 12:10:50 +0100
Subject: [PATCH 33/38] Update powermanagement

---
 xbmc/powermanagement/PowerManager.cpp              |  83 ++++--
 xbmc/powermanagement/linux/FallbackPowerSyscall.h  |  39 +++
 xbmc/powermanagement/linux/LogindUPowerSyscall.cpp | 308 +++++++++++++++++++++
 xbmc/powermanagement/linux/LogindUPowerSyscall.h   |  61 ++++
 xbmc/powermanagement/linux/Makefile                |   2 +-
 .../powermanagement/linux/SystemdUPowerSyscall.cpp | 125 ---------
 xbmc/powermanagement/linux/SystemdUPowerSyscall.h  |  43 ---
 xbmc/powermanagement/linux/UPowerSyscall.cpp       |   2 +-
 8 files changed, 477 insertions(+), 186 deletions(-)
 create mode 100644 xbmc/powermanagement/linux/FallbackPowerSyscall.h
 create mode 100644 xbmc/powermanagement/linux/LogindUPowerSyscall.cpp
 create mode 100644 xbmc/powermanagement/linux/LogindUPowerSyscall.h
 delete mode 100644 xbmc/powermanagement/linux/SystemdUPowerSyscall.cpp
 delete mode 100644 xbmc/powermanagement/linux/SystemdUPowerSyscall.h

diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 22147da..b9b52a9 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -31,6 +31,8 @@
 #include "interfaces/AnnouncementManager.h"
 #include "guilib/LocalizeStrings.h"
 #include "guilib/GraphicContext.h"
+#include "guilib/GUIWindowManager.h"
+#include "dialogs/GUIDialogBusy.h"
 #include "dialogs/GUIDialogKaiToast.h"
 
 #ifdef HAS_LCD
@@ -46,15 +48,18 @@
 
 #elif defined(TARGET_ANDROID)
 #include "android/AndroidPowerSyscall.h"
-#elif defined(_LINUX) && defined(HAS_DBUS)
+#elif defined(TARGET_POSIX)
+#include "linux/FallbackPowerSyscall.h"
+#if defined(HAS_DBUS)
 #include "linux/ConsoleUPowerSyscall.h"
 #include "linux/ConsoleDeviceKitPowerSyscall.h"
-#include "linux/SystemdUPowerSyscall.h"
+#include "linux/LogindUPowerSyscall.h"
 #include "linux/UPowerSyscall.h"
-#ifdef HAS_HAL
+#if defined(HAS_HAL)
 #include "linux/HALPowerSyscall.h"
-#endif
-#elif defined(_WIN32)
+#endif // HAS_HAL
+#endif // HAS_DBUS
+#elif defined(TARGET_WINDOWS)
 #include "powermanagement/windows/Win32PowerSyscall.h"
 extern HWND g_hWnd;
 #endif
@@ -79,20 +84,24 @@ void CPowerManager::Initialize()
   m_instance = new CCocoaPowerSyscall();
 #elif defined(TARGET_ANDROID)
   m_instance = new CAndroidPowerSyscall();
-#elif defined(_LINUX) && defined(HAS_DBUS)
+#elif defined(TARGET_POSIX)
+#if defined(HAS_DBUS)
   if (CConsoleUPowerSyscall::HasConsoleKitAndUPower())
     m_instance = new CConsoleUPowerSyscall();
   else if (CConsoleDeviceKitPowerSyscall::HasDeviceConsoleKit())
     m_instance = new CConsoleDeviceKitPowerSyscall();
-  else if (CSystemdUPowerSyscall::HasSystemdAndUPower())
-    m_instance = new CSystemdUPowerSyscall();
+  else if (CLogindUPowerSyscall::HasLogind())
+    m_instance = new CLogindUPowerSyscall();
   else if (CUPowerSyscall::HasUPower())
     m_instance = new CUPowerSyscall();
-#ifdef HAS_HAL
-  else
+#if defined(HAS_HAL)
+  else if(1)
     m_instance = new CHALPowerSyscall();
-#endif
-#elif defined(_WIN32)
+#endif // HAS_HAL
+  else
+#endif // HAS_DBUS
+    m_instance = new CFallbackPowerSyscall();
+#elif defined(TARGET_WINDOWS)
   m_instance = new CWin32PowerSyscall();
 #endif
 
@@ -146,25 +155,58 @@ void CPowerManager::SetDefaults()
 
 bool CPowerManager::Powerdown()
 {
-  return CanPowerdown() ? m_instance->Powerdown() : false;
+  if (CanPowerdown() && m_instance->Powerdown())
+  {
+    CGUIDialogBusy* dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
+    if (dialog)
+      dialog->Show();
+
+    return true;
+  }
+
+  return false;
 }
 
 bool CPowerManager::Suspend()
 {
-  return CanSuspend() ? m_instance->Suspend() : false;
+  if (CanSuspend() && m_instance->Suspend())
+  {
+    CGUIDialogBusy* dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
+    if (dialog)
+      dialog->Show();
+
+    return true;
+  }
+
+  return false;
 }
 
 bool CPowerManager::Hibernate()
 {
-  return CanHibernate() ? m_instance->Hibernate() : false;
+  if (CanHibernate() && m_instance->Hibernate())
+  {
+    CGUIDialogBusy* dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
+    if (dialog)
+      dialog->Show();
+
+    return true;
+  }
+
+  return false;
 }
 bool CPowerManager::Reboot()
 {
   bool success = CanReboot() ? m_instance->Reboot() : false;
 
   if (success)
+  {
     CAnnouncementManager::Announce(System, "xbmc", "OnRestart");
 
+    CGUIDialogBusy* dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
+    if (dialog)
+      dialog->Show();
+  }
+
   return success;
 }
 
@@ -190,7 +232,12 @@ int CPowerManager::BatteryLevel()
 }
 void CPowerManager::ProcessEvents()
 {
-  m_instance->PumpPowerEvents(this);
+  static int nesting = 0;
+
+  if (++nesting == 1)
+    m_instance->PumpPowerEvents(this);
+
+  nesting--;
 }
 
 void CPowerManager::OnSleep()
@@ -224,6 +271,10 @@ void CPowerManager::OnWake()
   // reset out timers
   g_application.ResetShutdownTimers();
 
+  CGUIDialogBusy* dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
+  if (dialog)
+    dialog->Close();
+
 #if defined(HAS_SDL) || defined(TARGET_WINDOWS)
   if (g_Windowing.IsFullScreen())
   {
diff --git a/xbmc/powermanagement/linux/FallbackPowerSyscall.h b/xbmc/powermanagement/linux/FallbackPowerSyscall.h
new file mode 100644
index 0000000..a6ed27b
--- /dev/null
+++ b/xbmc/powermanagement/linux/FallbackPowerSyscall.h
@@ -0,0 +1,39 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+#include "powermanagement/IPowerSyscall.h"
+#include "system.h"
+#if defined(TARGET_POSIX)
+
+class CFallbackPowerSyscall : public CPowerSyscallWithoutEvents
+{
+public:
+  virtual bool Powerdown() {return true; }
+  virtual bool Suspend() {return false; }
+  virtual bool Hibernate() {return false; }
+  virtual bool Reboot() {return true; }
+
+  virtual bool CanPowerdown() {return true; }
+  virtual bool CanSuspend() {return false; }
+  virtual bool CanHibernate() {return false; }
+  virtual bool CanReboot() {return true; }
+  virtual int  BatteryLevel() {return 0; }
+};
+#endif
diff --git a/xbmc/powermanagement/linux/LogindUPowerSyscall.cpp b/xbmc/powermanagement/linux/LogindUPowerSyscall.cpp
new file mode 100644
index 0000000..5a97fe6
--- /dev/null
+++ b/xbmc/powermanagement/linux/LogindUPowerSyscall.cpp
@@ -0,0 +1,308 @@
+/*
+ *      Copyright (C) 2012 Denis Yantarev
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "system.h"
+#include "LogindUPowerSyscall.h"
+#include "utils/log.h"
+
+#ifdef HAS_DBUS
+
+// logind DBus interface specification:
+// http://www.freedesktop.org/wiki/Software/Logind/logind
+//
+// Inhibitor Locks documentation:
+// http://www.freedesktop.org/wiki/Software/Logind/inhibit/
+
+#define LOGIND_DEST  "org.freedesktop.login1"
+#define LOGIND_PATH  "/org/freedesktop/login1"
+#define LOGIND_IFACE "org.freedesktop.login1.Manager"
+
+CLogindUPowerSyscall::CLogindUPowerSyscall()
+{
+  m_delayLockFd = -1;
+
+  CLog::Log(LOGINFO, "Selected Logind/UPower as PowerSyscall");
+
+  // Check if we have UPower. If not, we avoid any battery related operations.
+  CDBusMessage message("org.freedesktop.UPower", "/org/freedesktop/UPower", "org.freedesktop.UPower", "EnumerateDevices");
+  m_hasUPower = message.SendSystem() != NULL;
+
+  if (!m_hasUPower)
+    CLog::Log(LOGINFO, "LogindUPowerSyscall - UPower not found, battery information will not be available");
+
+  m_canPowerdown = LogindCheckCapability("CanPowerOff");
+  m_canReboot    = LogindCheckCapability("CanReboot");
+  m_canHibernate = LogindCheckCapability("CanHibernate");
+  m_canSuspend   = LogindCheckCapability("CanSuspend");
+
+  InhibitDelayLock();
+
+  m_batteryLevel = 0;
+  if (m_hasUPower)
+    UpdateBatteryLevel();
+
+  DBusError error;
+  dbus_error_init(&error);
+  m_connection = dbus_bus_get_private(DBUS_BUS_SYSTEM, &error);
+
+  if (dbus_error_is_set(&error))
+  {
+    CLog::Log(LOGERROR, "LogindUPowerSyscall: Failed to get dbus connection: %s", error.message);
+    dbus_connection_close(m_connection);
+    dbus_connection_unref(m_connection);
+    m_connection = NULL;
+    dbus_error_free(&error);
+    return;
+  }
+
+  dbus_connection_set_exit_on_disconnect(m_connection, false);
+  dbus_bus_add_match(m_connection, "type='signal',interface='org.freedesktop.login1.Manager',member='PrepareForSleep'", NULL);
+
+  if (m_hasUPower)
+    dbus_bus_add_match(m_connection, "type='signal',interface='org.freedesktop.UPower',member='DeviceChanged'", NULL);
+
+  dbus_connection_flush(m_connection);
+  dbus_error_free(&error);
+}
+
+CLogindUPowerSyscall::~CLogindUPowerSyscall()
+{
+  if (m_connection)
+  {
+    dbus_connection_close(m_connection);
+    dbus_connection_unref(m_connection);
+  }
+
+  ReleaseDelayLock();
+}
+
+bool CLogindUPowerSyscall::Powerdown()
+{
+  return LogindSetPowerState("PowerOff");
+}
+
+bool CLogindUPowerSyscall::Reboot()
+{
+  return LogindSetPowerState("Reboot");
+}
+
+bool CLogindUPowerSyscall::Suspend()
+{
+  return LogindSetPowerState("Suspend");
+}
+
+bool CLogindUPowerSyscall::Hibernate()
+{
+  return LogindSetPowerState("Hibernate");
+}
+
+bool CLogindUPowerSyscall::CanPowerdown()
+{
+  return m_canPowerdown;
+}
+
+bool CLogindUPowerSyscall::CanSuspend()
+{
+  return m_canSuspend;
+}
+
+bool CLogindUPowerSyscall::CanHibernate()
+{
+  return m_canHibernate;
+}
+
+bool CLogindUPowerSyscall::CanReboot()
+{
+  return m_canReboot;
+}
+
+bool CLogindUPowerSyscall::HasLogind()
+{
+  // recommended method by systemd devs. The seats directory
+  // doesn't exist unless logind created it and therefore is running.
+  // see also https://mail.gnome.org/archives/desktop-devel-list/2013-March/msg00092.html
+  return (access("/run/systemd/seats/", F_OK) >= 0);
+}
+
+bool CLogindUPowerSyscall::LogindSetPowerState(const char *state)
+{
+  CDBusMessage message(LOGIND_DEST, LOGIND_PATH, LOGIND_IFACE, state);
+  // The user_interaction boolean parameters can be used to control
+  // wether PolicyKit should interactively ask the user for authentication
+  // credentials if it needs to.
+  message.AppendArgument(false);
+  return message.SendSystem() != NULL;
+}
+
+bool CLogindUPowerSyscall::LogindCheckCapability(const char *capability)
+{
+  char *arg;
+  CDBusMessage message(LOGIND_DEST, LOGIND_PATH, LOGIND_IFACE, capability);
+  DBusMessage *reply = message.SendSystem();
+  if(reply && dbus_message_get_args(reply, NULL, DBUS_TYPE_STRING, &arg, DBUS_TYPE_INVALID))
+  {
+    // Returns one of "yes", "no" or "challenge". If "challenge" is
+    // returned the operation is available, but only after authorization.
+    return (strcmp(arg, "yes") == 0);
+  }
+  return false;
+}
+
+int CLogindUPowerSyscall::BatteryLevel()
+{
+  return m_batteryLevel;
+}
+
+void CLogindUPowerSyscall::UpdateBatteryLevel()
+{
+  char** source  = NULL;
+  int    length = 0;
+  double batteryLevelSum = 0;
+  int    batteryCount = 0;
+
+  CDBusMessage message("org.freedesktop.UPower", "/org/freedesktop/UPower", "org.freedesktop.UPower", "EnumerateDevices");
+  DBusMessage *reply = message.SendSystem();
+
+  if (!reply)
+    return;
+
+  if (!dbus_message_get_args(reply, NULL, DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH, &source, &length, DBUS_TYPE_INVALID))
+  {
+    CLog::Log(LOGWARNING, "LogindUPowerSyscall: failed to enumerate devices");
+    return;
+  }
+
+  for (int i = 0; i < length; i++)
+  {
+    CVariant properties = CDBusUtil::GetAll("org.freedesktop.UPower", source[i], "org.freedesktop.UPower.Device");
+    bool isRechargeable = properties["IsRechargeable"].asBoolean();
+
+    if (isRechargeable)
+    {
+      batteryCount++;
+      batteryLevelSum += properties["Percentage"].asDouble();
+    }
+  }
+
+  dbus_free_string_array(source);
+
+  if (batteryCount > 0)
+    m_batteryLevel = (int)(batteryLevelSum / (double)batteryCount);
+
+  m_lowBattery = CDBusUtil::GetVariant("org.freedesktop.UPower", "/org/freedesktop/UPower", "org.freedesktop.UPower", "OnLowBattery").asBoolean();
+}
+
+bool CLogindUPowerSyscall::PumpPowerEvents(IPowerEventsCallback *callback)
+{
+  bool result = false;
+  bool releaseLock = false;
+
+  if (m_connection)
+  {
+    dbus_connection_read_write(m_connection, 0);
+    DBusMessage *msg = dbus_connection_pop_message(m_connection);
+
+    if (msg)
+    {
+      if (dbus_message_is_signal(msg, "org.freedesktop.login1.Manager", "PrepareForSleep"))
+      {
+        dbus_bool_t arg;
+        // the boolean argument defines whether we are going to sleep (true) or just woke up (false)
+        dbus_message_get_args(msg, NULL, DBUS_TYPE_BOOLEAN, &arg, DBUS_TYPE_INVALID);
+        CLog::Log(LOGDEBUG, "LogindUPowerSyscall: Received PrepareForSleep with arg %i", (int)arg);
+        if (arg)
+        {
+          callback->OnSleep();
+          releaseLock = true;
+        }
+        else
+        {
+          callback->OnWake();
+          InhibitDelayLock();
+        }
+
+        result = true;
+      }
+      else if (dbus_message_is_signal(msg, "org.freedesktop.UPower", "DeviceChanged"))
+      {
+        bool lowBattery = m_lowBattery;
+        UpdateBatteryLevel();
+        if (m_lowBattery && !lowBattery)
+          callback->OnLowBattery();
+
+        result = true;
+      }
+      else
+        CLog::Log(LOGDEBUG, "LogindUPowerSyscall - Received unknown signal %s", dbus_message_get_member(msg));
+
+      dbus_message_unref(msg);
+    }
+  }
+
+  if (releaseLock)
+    ReleaseDelayLock();
+
+  return result;
+}
+
+void CLogindUPowerSyscall::InhibitDelayLock()
+{
+#ifdef DBUS_TYPE_UNIX_FD
+  CDBusMessage message("org.freedesktop.login1", "/org/freedesktop/login1", "org.freedesktop.login1.Manager", "Inhibit");
+  message.AppendArgument("sleep"); // what to inhibit
+  message.AppendArgument("XBMC"); // who
+  message.AppendArgument(""); // reason
+  message.AppendArgument("delay"); // mode
+
+  DBusMessage *reply = message.SendSystem();
+
+  if (!reply)
+  {
+    CLog::Log(LOGWARNING, "LogindUPowerSyscall - failed to inhibit sleep delay lock");
+    m_delayLockFd = -1;
+    return;
+  }
+
+  if (!dbus_message_get_args(reply, NULL, DBUS_TYPE_UNIX_FD, &m_delayLockFd, DBUS_TYPE_INVALID))
+  {
+    CLog::Log(LOGWARNING, "LogindUPowerSyscall - failed to get inhibit file descriptor");
+    m_delayLockFd = -1;
+    return;
+  }
+
+    CLog::Log(LOGDEBUG, "LogindUPowerSyscall - inhibit lock taken, fd %i", m_delayLockFd);
+#else
+    CLog::Log(LOGWARNING, "LogindUPowerSyscall - inhibit lock support not compiled in");
+#endif
+}
+
+void CLogindUPowerSyscall::ReleaseDelayLock()
+{
+  if (m_delayLockFd != -1)
+  {
+    close(m_delayLockFd);
+    m_delayLockFd = -1;
+    CLog::Log(LOGDEBUG, "LogindUPowerSyscall - delay lock released");
+  }
+}
+
+#endif
diff --git a/xbmc/powermanagement/linux/LogindUPowerSyscall.h b/xbmc/powermanagement/linux/LogindUPowerSyscall.h
new file mode 100644
index 0000000..d23daf9
--- /dev/null
+++ b/xbmc/powermanagement/linux/LogindUPowerSyscall.h
@@ -0,0 +1,61 @@
+/*
+ *      Copyright (C) 2012 Denis Yantarev
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifdef HAS_DBUS
+
+#include "powermanagement/IPowerSyscall.h"
+#include "DBusUtil.h"
+
+class CLogindUPowerSyscall : public IPowerSyscall
+{
+public:
+  CLogindUPowerSyscall();
+  ~CLogindUPowerSyscall();
+  virtual bool Powerdown();
+  virtual bool Suspend();
+  virtual bool Hibernate();
+  virtual bool Reboot();
+  virtual bool CanPowerdown();
+  virtual bool CanSuspend();
+  virtual bool CanHibernate();
+  virtual bool CanReboot();
+  virtual int BatteryLevel();
+  virtual bool PumpPowerEvents(IPowerEventsCallback *callback);
+  // we don't require UPower because everything except the battery level works fine without it
+  static bool HasLogind();
+private:
+  DBusConnection *m_connection;
+  bool m_canPowerdown;
+  bool m_canSuspend;
+  bool m_canHibernate;
+  bool m_canReboot;
+  bool m_hasUPower;
+  bool m_lowBattery;
+  int m_batteryLevel;
+  int m_delayLockFd; // file descriptor for the logind sleep delay lock
+  void UpdateBatteryLevel();
+  void InhibitDelayLock();
+  void ReleaseDelayLock();
+  static bool LogindSetPowerState(const char *state);
+  static bool LogindCheckCapability(const char *capability);
+};
+
+#endif
diff --git a/xbmc/powermanagement/linux/Makefile b/xbmc/powermanagement/linux/Makefile
index 11a91b0..fc6f8b5 100644
--- a/xbmc/powermanagement/linux/Makefile
+++ b/xbmc/powermanagement/linux/Makefile
@@ -2,7 +2,7 @@ SRCS=ConsoleDeviceKitPowerSyscall.cpp \
      ConsoleUPowerSyscall.cpp \
      HALPowerSyscall.cpp \
      UPowerSyscall.cpp \
-     SystemdUPowerSyscall.cpp
+     LogindUPowerSyscall.cpp
 
 LIB=powermanagement_linux.a
 
diff --git a/xbmc/powermanagement/linux/SystemdUPowerSyscall.cpp b/xbmc/powermanagement/linux/SystemdUPowerSyscall.cpp
deleted file mode 100644
index a80d97d..0000000
--- a/xbmc/powermanagement/linux/SystemdUPowerSyscall.cpp
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- *      Copyright (C) 2012 Denis Yantarev
- *      Copyright (C) 2005-2009 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#include "system.h"
-#include "SystemdUPowerSyscall.h"
-#include "utils/log.h"
-
-#ifdef HAS_DBUS
-#include "Application.h"
-
-// logind DBus interface specification:
-// http://www.freedesktop.org/wiki/Software/systemd/logind
-
-#define LOGIND_DEST  "org.freedesktop.login1"
-#define LOGIND_PATH  "/org/freedesktop/login1"
-#define LOGIND_IFACE "org.freedesktop.login1.Manager"
-
-CSystemdUPowerSyscall::CSystemdUPowerSyscall()
-{
-  UpdateCapabilities();
-}
-
-bool CSystemdUPowerSyscall::Powerdown()
-{
-  return SystemdSetPowerState("PowerOff");
-}
-
-bool CSystemdUPowerSyscall::Reboot()
-{
-  return SystemdSetPowerState("Reboot");
-}
-
-bool CSystemdUPowerSyscall::Suspend()
-{
-  return SystemdSetPowerState("Suspend");
-}
-
-bool CSystemdUPowerSyscall::Hibernate()
-{
-  return SystemdSetPowerState("Hibernate");
-}
-
-void CSystemdUPowerSyscall::UpdateCapabilities()
-{
-  m_CanPowerdown = SystemdCheckCapability("CanPowerOff");
-  m_CanReboot    = SystemdCheckCapability("CanReboot");
-  m_CanHibernate = SystemdCheckCapability("CanHibernate");
-  m_CanSuspend   = SystemdCheckCapability("CanSuspend");
-}
-
-bool CSystemdUPowerSyscall::HasSystemdAndUPower()
-{
-  DBusConnection *con;
-  DBusError error;
-  bool hasSystemd = false;
-
-  dbus_error_init(&error);
-  con = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
-
-  if(dbus_error_is_set(&error))
-  {
-    CLog::Log(LOGDEBUG, "SystemdUPowerSyscall: %s: %s", error.name, error.message);
-    dbus_error_free(&error);
-    return false;
-  }
-
-  CDBusMessage message(LOGIND_DEST, LOGIND_PATH, LOGIND_IFACE, "CanPowerOff");
-  message.Send(con, &error);
-
-  if(!dbus_error_is_set(&error))
-    hasSystemd = true;
-  else
-    CLog::Log(LOGDEBUG, "Systemd error: %s: %s", error.name, error.message);
-
-  dbus_error_free(&error);
-
-  return HasUPower() && hasSystemd;
-}
-
-bool CSystemdUPowerSyscall::SystemdSetPowerState(const char *state)
-{
-  bool arg = false;
-  CDBusMessage message(LOGIND_DEST, LOGIND_PATH, LOGIND_IFACE, state);
-  // The user_interaction boolean parameters can be used to control
-  // wether PolicyKit should interactively ask the user for authentication
-  // credentials if it needs to.
-  message.AppendArgument(arg);
-  return message.SendSystem() != NULL;
-}
-
-bool CSystemdUPowerSyscall::SystemdCheckCapability(const char *capability)
-{
-  bool result = false;
-  char *arg;
-  CDBusMessage message(LOGIND_DEST, LOGIND_PATH, LOGIND_IFACE, capability);
-  DBusMessage *reply = message.SendSystem();
-  if(reply && dbus_message_get_args(reply, NULL, DBUS_TYPE_STRING, &arg, DBUS_TYPE_INVALID))
-  {
-    // Returns one of "yes", "no" or "challenge". If "challenge" is
-    // returned the operation is available, but only after authorization.
-    result = (strcmp(arg, "yes") == 0);
-  }
-  return result;
-}
-
-#endif
diff --git a/xbmc/powermanagement/linux/SystemdUPowerSyscall.h b/xbmc/powermanagement/linux/SystemdUPowerSyscall.h
deleted file mode 100644
index 30b0141..0000000
--- a/xbmc/powermanagement/linux/SystemdUPowerSyscall.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- *      Copyright (C) 2012 Denis Yantarev
- *      Copyright (C) 2005-2009 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#ifdef HAS_DBUS
-
-#include "UPowerSyscall.h"
-
-class CSystemdUPowerSyscall : public CUPowerSyscall
-{
-public:
-  CSystemdUPowerSyscall();
-  virtual bool Powerdown();
-  virtual bool Suspend();
-  virtual bool Hibernate();
-  virtual bool Reboot();
-  static bool HasSystemdAndUPower();  
-protected:
-  void UpdateCapabilities();
-private:
-  static bool SystemdSetPowerState(const char *state);
-  static bool SystemdCheckCapability(const char *capability);
-};
-
-#endif
diff --git a/xbmc/powermanagement/linux/UPowerSyscall.cpp b/xbmc/powermanagement/linux/UPowerSyscall.cpp
index c3389c6..0f23d86 100644
--- a/xbmc/powermanagement/linux/UPowerSyscall.cpp
+++ b/xbmc/powermanagement/linux/UPowerSyscall.cpp
@@ -254,7 +254,7 @@ bool CUPowerSyscall::PumpPowerEvents(IPowerEventsCallback *callback)
           callback->OnLowBattery();
       }
       else
-        CLog::Log(LOGDEBUG, "UPower: Recieved an unknown signal %s", dbus_message_get_member(msg));
+        CLog::Log(LOGDEBUG, "UPower: Received an unknown signal %s", dbus_message_get_member(msg));
 
       dbus_message_unref(msg);
     }

From aed31e7de18eb79f292cb55d4c63355a0f9f3bc4 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 12:11:42 +0100
Subject: [PATCH 34/38] Update MathUtils

---
 xbmc/utils/MathUtils.h | 159 ++++++++++++++++++-------------------------------
 1 file changed, 57 insertions(+), 102 deletions(-)

diff --git a/xbmc/utils/MathUtils.h b/xbmc/utils/MathUtils.h
index c95171f..06b94f9 100644
--- a/xbmc/utils/MathUtils.h
+++ b/xbmc/utils/MathUtils.h
@@ -34,20 +34,10 @@
 
 #if defined(__ppc__) || \
     defined(__powerpc__) || \
-   (defined(__APPLE__) && defined(__arm__) && defined(__llvm__)) || \
-   (defined(__ANDROID__) && defined(__arm__)) || \
-    defined(TARGET_RASPBERRY_PI)
+    defined(__arm__)
   #define DISABLE_MATHUTILS_ASM_ROUND_INT
 #endif
 
-#if defined(__ppc__) || \
-    defined(__powerpc__) || \
-   (defined(__APPLE__) && defined(__llvm__)) || \
-   (defined(__ANDROID__) && defined(__arm__)) || \
-    defined(TARGET_RASPBERRY_PI)
-  #define DISABLE_MATHUTILS_ASM_TRUNCATE_INT
-#endif
-
 /*! \brief Math utility class.
  Note that the test() routine should return true for all implementations
 
@@ -73,64 +63,67 @@ namespace MathUtils
   {
     assert(x > static_cast<double>(INT_MIN / 2) - 1.0);
     assert(x < static_cast<double>(INT_MAX / 2) + 1.0);
-    const float round_to_nearest = 0.5f;
-    int i;
 
 #if defined(DISABLE_MATHUTILS_ASM_ROUND_INT)
-    i = floor(x + round_to_nearest);
-
-#elif defined(__arm__)
-    // From 'ARM-v7-M Architecture Reference Manual' page A7-569:
-    //  "The floating-point to integer operation (vcvt) [normally] uses the Round towards Zero rounding mode"
-    // Because of this...we must use some less-than-straightforward logic to perform this operation without
-    //  changing the rounding mode flags
-
-    /* The assembly below implements the following logic:
-     if (x < 0)
-       inc = -0.5f
-     else
-       inc = 0.5f
-     int_val = trunc(x+inc);
-     err = x - int_val;
-     if (err == 0.5f)
-       int_val++;
-     return int_val;
-    */
+    /* This implementation warrants some further explanation.
+     *
+     * First, a couple of notes on rounding:
+     * 1) C casts from float/double to integer round towards zero.
+     * 2) Float/double additions are rounded according to the normal rules,
+     *    in other words: on some architectures, it's fixed at compile-time,
+     *    and on others it can be set using fesetround()). The following
+     *    analysis assumes round-to-nearest with ties rounding to even. This
+     *    is a fairly sensible choice, and is the default with ARM VFP.
+     *
+     * What this function wants is round-to-nearest with ties rounding to
+     * +infinity. This isn't an IEEE rounding mode, even if we could guarantee
+     * that all architectures supported fesetround(), which they don't. Instead,
+     * this adds an offset of 2147483648.5 (= 0x80000000.8p0), then casts to
+     * an unsigned int (crucially, all possible inputs are now in a range where
+     * round to zero acts the same as round to -infinity) and then subtracts
+     * 0x80000000 in the integer domain. The 0.5 component of the offset
+     * converts what is effectively a round down into a round to nearest, with
+     * ties rounding up, as desired.
+     *
+     * There is a catch, that because there is a double rounding, there is a
+     * small region where the input falls just *below* a tie, where the addition
+     * of the offset causes a round *up* to an exact integer, due to the finite
+     * level of precision available in floating point. You need to be aware of
+     * this when calling this function, although at present it is not believed
+     * that XBMC ever attempts to round numbers in this window.
+     *
+     * It is worth proving the size of the affected window. Recall that double
+     * precision employs a mantissa of 52 bits.
+     * 1) For all inputs -0.5 <= x <= INT_MAX
+     *    Once the offset is applied, the most significant binary digit in the
+     *    floating-point representation is +2^31.
+     *    At this magnitude, the smallest step representable in double precision
+     *    is 2^31 / 2^52 = 0.000000476837158203125
+     *    So the size of the range which is rounded up due to the addition is
+     *    half the size of this step, or 0.0000002384185791015625
+     *
+     * 2) For all inputs INT_MIN/2 < x < -0.5
+     *    Once the offset is applied, the most significant binary digit in the
+     *    floating-point representation is +2^30.
+     *    At this magnitude, the smallest step representable in double precision
+     *    is 2^30 / 2^52 = 0.0000002384185791015625
+     *    So the size of the range which is rounded up due to the addition is
+     *    half the size of this step, or 0.00000011920928955078125
+     *
+     * 3) For all inputs INT_MIN <= x <= INT_MIN/2
+     *    The representation once the offset is applied has equal or greater
+     *    precision than the input, so the addition does not cause rounding.
+     */
+    return ((unsigned int) (x + 0x80000000.8p0)) - 0x80000000;
 
-    __asm__ __volatile__ (
-#if defined(__ARM_PCS_VFP)
-      "fconstd d1,#%G[rnd_val]     \n\t" // Copy round_to_nearest into a working register (d1 = 0.5)
 #else
-      "vmov.F64 d1,%[rnd_val]      \n\t"
-#endif
-      "fcmpezd %P[value]           \n\t" // Check value against zero (value == 0?)
-      "fmstat                      \n\t" // Copy the floating-point status flags into the general-purpose status flags
-      "it mi                       \n\t"
-      "vnegmi.F64 d1, d1           \n\t" // if N-flag is set, negate round_to_nearest (if (value < 0) d1 = -1 * d1)
-      "vadd.F64 d1,%P[value],d1    \n\t" // Add round_to_nearest to value, store result in working register (d1 += value)
-      "vcvt.S32.F64 s3,d1          \n\t" // Truncate(round towards zero) (s3 = (int)d1)
-      "vmov %[result],s3           \n\t" // Store the integer result in a general-purpose register (result = s3)
-      "vcvt.F64.S32 d1,s3          \n\t" // Convert back to floating-point (d1 = (double)s3)
-      "vsub.F64 d1,%P[value],d1    \n\t" // Calculate the error (d1 = value - d1)
-#if defined(__ARM_PCS_VFP)
-      "fconstd d2,#%G[rnd_val]     \n\t" // d2 = 0.5;
-#else
-      "vmov.F64 d2,%[rnd_val]      \n\t"
-#endif
-      "fcmped d1, d2               \n\t" // (d1 == 0.5?)
-      "fmstat                      \n\t" // Copy the floating-point status flags into the general-purpose status flags
-      "it eq                       \n\t"
-      "addeq %[result],#1          \n\t" // (if (d1 == d2) result++;)
-      : [result] "=r"(i)                                  // Outputs
-      : [rnd_val] "Dv" (round_to_nearest), [value] "w"(x) // Inputs
-      : "d1", "d2", "s3"                                  // Clobbers
-    );
-
-#elif defined(__SSE2__)
+    const float round_to_nearest = 0.5f;
+    int i;
+#if defined(__SSE2__)
     const float round_dn_to_nearest = 0.4999999f;
     i = (x > 0) ? _mm_cvttsd_si32(_mm_set_sd(x + round_to_nearest)) : _mm_cvttsd_si32(_mm_set_sd(x - round_dn_to_nearest));
 
-#elif defined(_WIN32)
+#elif defined(TARGET_WINDOWS)
     __asm
     {
       fld x
@@ -150,8 +143,8 @@ namespace MathUtils
     );
 
 #endif
-
     return i;
+#endif
   }
 
   /*! \brief Truncate to nearest integer.
@@ -165,45 +158,7 @@ namespace MathUtils
   {
     assert(x > static_cast<double>(INT_MIN / 2) - 1.0);
     assert(x < static_cast<double>(INT_MAX / 2) + 1.0);
-    int i;
-
-#if defined(DISABLE_MATHUTILS_ASM_TRUNCATE_INT)
-    return i = (int)x;
-
-#elif defined(__arm__)
-    __asm__ __volatile__ (
-      "vcvt.S32.F64 %[result],%P[value]   \n\t" // Truncate(round towards zero) and store the result
-      : [result] "=w"(i)                        // Outputs
-      : [value] "w"(x)                          // Inputs
-    );
-    return i;
-
-#elif defined(_WIN32)
-    const float round_towards_m_i = -0.5f;
-    __asm
-    {
-      fld x
-      fadd st, st (0)
-      fabs
-      fadd round_towards_m_i
-      fistp i
-      sar i, 1
-    }
-
-#else
-    const float round_towards_m_i = -0.5f;
-    __asm__ __volatile__ (
-      "fadd %%st\n\t"
-      "fabs\n\t"
-      "fadd %%st(1)\n\t"
-      "fistpl %0\n\t"
-      "sarl $1, %0\n"
-      : "=m"(i) : "u"(round_towards_m_i), "t"(x) : "st"
-    );
-#endif
-    if (x < 0)
-      i = -i;
-    return (i);
+    return x;
   }
 
   inline int64_t abs(int64_t a)

From 52a78f552a27df63e0e8036ffb9d55e72f9627f7 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 12:12:45 +0100
Subject: [PATCH 35/38] Add AESinkPi

---
 xbmc/cores/AudioEngine/AEFactory.cpp        |   8 -
 xbmc/cores/AudioEngine/AESinkFactory.cpp    |   9 +
 xbmc/cores/AudioEngine/Makefile.in          |   2 +
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp   | 421 ++++++++++++++++++++++++++++
 xbmc/cores/AudioEngine/Sinks/AESinkPi.h     |  65 +++++
 xbmc/cores/AudioEngine/Sinks/CMakeLists.txt |   4 +
 xbmc/cores/omxplayer/OMXAudio.cpp           |   7 +
 7 files changed, 508 insertions(+), 8 deletions(-)
 create mode 100644 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
 create mode 100644 xbmc/cores/AudioEngine/Sinks/AESinkPi.h

diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index 86392c1..1d7f506 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -42,10 +42,6 @@ IAE *CAEFactory::GetEngine()
 
 bool CAEFactory::LoadEngine()
 {
-#if defined(TARGET_RASPBERRY_PI)
-  return true;
-#endif
-
   bool loaded = false;
 
   std::string engine;
@@ -124,10 +120,6 @@ void CAEFactory::UnLoadEngine()
 
 bool CAEFactory::StartEngine()
 {
-#if defined(TARGET_RASPBERRY_PI)
-  return true;
-#endif
-
   if (!AE)
     return false;
 
diff --git a/xbmc/cores/AudioEngine/AESinkFactory.cpp b/xbmc/cores/AudioEngine/AESinkFactory.cpp
index b5bd692..2e2bc30 100644
--- a/xbmc/cores/AudioEngine/AESinkFactory.cpp
+++ b/xbmc/cores/AudioEngine/AESinkFactory.cpp
@@ -25,6 +25,8 @@
   #include "Sinks/AESinkDirectSound.h"
 #elif defined(TARGET_ANDROID)
   #include "Sinks/AESinkAUDIOTRACK.h"
+#elif defined(TARGET_RASPBERRY_PI)
+  #include "Sinks/AESinkPi.h"
 #elif defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
   #if defined(HAS_ALSA)
     #include "Sinks/AESinkALSA.h"
@@ -55,6 +57,8 @@ void CAESinkFactory::ParseDevice(std::string &device, std::string &driver)
         driver == "DIRECTSOUND" ||
 #elif defined(TARGET_ANDROID)
         driver == "AUDIOTRACK"  ||
+#elif defined(TARGET_RASPBERRY_PI)
+        driver == "PI"          ||
 #elif defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
   #if defined(HAS_ALSA)
         driver == "ALSA"        ||
@@ -110,6 +114,9 @@ IAESink *CAESinkFactory::Create(std::string &device, AEAudioFormat &desiredForma
 #elif defined(TARGET_ANDROID)
   if (driver.empty() || driver == "AUDIOTRACK")
     TRY_SINK(AUDIOTRACK)
+#elif defined(TARGET_RASPBERRY_PI)
+  if (driver.empty() || driver == "PI")
+    TRY_SINK(Pi)
 
 #elif defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
   #if defined(HAS_ALSA)
@@ -145,6 +152,8 @@ void CAESinkFactory::EnumerateEx(AESinkInfoList &list, bool force)
     ENUMERATE_SINK(WASAPI, force);
 #elif defined(TARGET_ANDROID)
     ENUMERATE_SINK(AUDIOTRACK, force);
+#elif defined(TARGET_RASPBERRY_PI)
+    ENUMERATE_SINK(Pi, force);
 #elif defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
   #if defined(HAS_ALSA)
     ENUMERATE_SINK(ALSA, force);
diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index 833dfab..b9a0401 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -39,6 +39,8 @@ SRCS += AESinkFactory.cpp
 SRCS += Sinks/AESinkNULL.cpp
 SRCS += Sinks/AESinkProfiler.cpp
 
+SRCS += Sinks/AESinkPi.cpp
+
 SRCS += Engines/SoftAE/SoftAE.cpp
 SRCS += Engines/SoftAE/SoftAEStream.cpp
 SRCS += Engines/SoftAE/SoftAESound.cpp
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
new file mode 100644
index 0000000..03ceec0
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -0,0 +1,421 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include <stdint.h>
+#include <limits.h>
+
+#include "AESinkPi.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
+#include "utils/log.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "linux/RBP.h"
+
+#define CLASSNAME "CAESinkPi"
+
+#define NUM_OMX_BUFFERS 2
+#define AUDIO_PLAYBUFFER (0.1) // 100ms
+
+static const unsigned int PassthroughSampleRates[] = { 8000, 11025, 16000, 22050, 24000, 32000, 41400, 48000, 88200, 96000, 176400, 192000 };
+
+CAEDeviceInfo CAESinkPi::m_info;
+
+CAESinkPi::CAESinkPi() :
+    m_sinkbuffer_sec_per_byte(0),
+    m_Initialized(false),
+    m_submitted(0)
+{
+}
+
+CAESinkPi::~CAESinkPi()
+{
+}
+
+void CAESinkPi::SetAudioDest()
+{
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+  OMX_CONFIG_BRCMAUDIODESTINATIONTYPE audioDest;
+  OMX_INIT_STRUCTURE(audioDest);
+  if (g_guiSettings.GetString("audiooutput.audiodevice") == "PI:Analogue")
+    strncpy((char *)audioDest.sName, "local", strlen("local"));
+  else
+    strncpy((char *)audioDest.sName, "hdmi", strlen("hdmi"));
+  omx_err = m_omx_render.SetConfig(OMX_IndexConfigBrcmAudioDestination, &audioDest);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - m_omx_render.SetConfig omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+}
+
+static void SetAudioProps(bool stream_channels, uint32_t channel_map)
+{
+  char command[80], response[80];
+
+  sprintf(command, "hdmi_stream_channels %d", stream_channels ? 1 : 0);
+  vc_gencmd(response, sizeof response, command);
+
+  sprintf(command, "hdmi_channel_map 0x%08x", channel_map);
+  vc_gencmd(response, sizeof response, command);
+
+  CLog::Log(LOGDEBUG, "%s:%s hdmi_stream_channels %d hdmi_channel_map %08x", CLASSNAME, __func__, stream_channels, channel_map);
+}
+
+static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
+{
+  unsigned int channels = format.m_channelLayout.Count();
+  uint32_t channel_map = 0;
+  if (passthrough)
+    return 0;
+
+  static const unsigned char map_normal[] =
+  {
+    0, //AE_CH_RAW ,
+    1, //AE_CH_FL
+    2, //AE_CH_FR
+    4, //AE_CH_FC
+    3, //AE_CH_LFE
+    7, //AE_CH_BL
+    8, //AE_CH_BR
+    1, //AE_CH_FLOC,
+    2, //AE_CH_FROC,
+    4, //AE_CH_BC,
+    5, //AE_CH_SL
+    6, //AE_CH_SR
+  };
+  static const unsigned char map_back[] =
+  {
+    0, //AE_CH_RAW ,
+    1, //AE_CH_FL
+    2, //AE_CH_FR
+    4, //AE_CH_FC
+    3, //AE_CH_LFE
+    5, //AE_CH_BL
+    6, //AE_CH_BR
+    1, //AE_CH_FLOC,
+    2, //AE_CH_FROC,
+    4, //AE_CH_BC,
+    5, //AE_CH_SL
+    6, //AE_CH_SR
+  };
+  const unsigned char *map = map_normal;
+  // According to CEA-861-D only RL and RR are known. In case of a format having SL and SR channels
+  // but no BR BL channels, we use the wide map in order to open only the num of channels really
+  // needed.
+  if (format.m_channelLayout.HasChannel(AE_CH_BL) && !format.m_channelLayout.HasChannel(AE_CH_SL))
+    map = map_back;
+
+  for (unsigned int i = 0; i < channels; ++i)
+  {
+    AEChannel c = format.m_channelLayout[i];
+    unsigned int chan = 0;
+    if ((unsigned int)c < sizeof map_normal / sizeof *map_normal)
+      chan = map[(unsigned int)c];
+    if (chan > 0)
+      channel_map |= (chan-1) << (3*i);
+  }
+  // These numbers are from Table 28 Audio InfoFrame Data byte 4 of CEA 861
+  // and describe the speaker layout
+  static const uint8_t cea_map[] = {
+    0xff, // 0
+    0xff, // 1
+    0x00, // 2.0
+    0x02, // 3.0
+    0x08, // 4.0
+    0x0a, // 5.0
+    0xff, // 6
+    0x12, // 7.0
+    0xff, // 8
+  };
+  static const uint8_t cea_map_lfe[] = {
+    0xff, // 0
+    0xff, // 1
+    0xff, // 2
+    0x01, // 2.1
+    0x03, // 3.1
+    0x09, // 4.1
+    0x0b, // 5.1
+    0xff, // 7
+    0x13, // 7.1
+  };
+  uint8_t cea = format.m_channelLayout.HasChannel(AE_CH_LFE) ? cea_map_lfe[channels] : cea_map[channels];
+  if (cea == 0xff)
+    CLog::Log(LOGERROR, "%s::%s - Unexpected CEA mapping %d,%d", CLASSNAME, __func__, format.m_channelLayout.HasChannel(AE_CH_LFE), channels);
+
+  channel_map |= cea << 24;
+
+  return channel_map;
+}
+
+bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
+{
+  // This may be called before Application calls g_RBP.Initialise, so call it here too
+  g_RBP.Initialize();
+
+  /* if we are raw need to let gpu know */
+  m_passthrough = AE_IS_RAW(format.m_dataFormat);
+
+  m_initDevice = device;
+  m_initFormat = format;
+
+  // analogue only supports stereo
+  if (g_guiSettings.GetString("audiooutput.audiodevice") == "PI:Analogue")
+    format.m_channelLayout = AE_CH_LAYOUT_2_0;
+
+  // setup for a 50ms sink feed from SoftAE
+  if (format.m_dataFormat != AE_FMT_FLOAT && format.m_dataFormat != AE_FMT_S32LE)
+    format.m_dataFormat = AE_FMT_S16LE;
+  unsigned int channels    = format.m_channelLayout.Count();
+  unsigned int sample_size = CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3;
+  format.m_frameSize     = sample_size * channels;
+  format.m_sampleRate    = std::max(8000U, std::min(192000U, format.m_sampleRate));
+  format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER;
+  format.m_frameSamples  = format.m_frames * channels;
+
+  SetAudioProps(m_passthrough, GetChannelMap(format, m_passthrough));
+
+  m_format = format;
+  m_sinkbuffer_sec_per_byte = 1.0 / (double)(m_format.m_frameSize * m_format.m_sampleRate);
+
+  CLog::Log(LOGDEBUG, "%s:%s Format:%d Channels:%d Samplerate:%d framesize:%d bufsize:%d bytes/s=%.2f", CLASSNAME, __func__,
+                m_format.m_dataFormat, channels, m_format.m_sampleRate, m_format.m_frameSize, m_format.m_frameSize * m_format.m_frames, 1.0/m_sinkbuffer_sec_per_byte);
+
+  CLog::Log(LOGDEBUG, "%s:%s", CLASSNAME, __func__);
+
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  if (!m_omx_render.Initialize("OMX.broadcom.audio_render", OMX_IndexParamAudioInit))
+    CLog::Log(LOGERROR, "%s::%s - m_omx_render.Initialize omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  OMX_INIT_STRUCTURE(m_pcm_input);
+  m_pcm_input.nPortIndex            = m_omx_render.GetInputPort();
+  m_pcm_input.eNumData              = OMX_NumericalDataSigned;
+  m_pcm_input.eEndian               = OMX_EndianLittle;
+  m_pcm_input.bInterleaved          = OMX_TRUE;
+  m_pcm_input.nBitPerSample         = sample_size * 8;
+  m_pcm_input.ePCMMode              = m_format.m_dataFormat == AE_FMT_FLOAT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  m_pcm_input.nChannels             = channels;
+  m_pcm_input.nSamplingRate         = m_format.m_sampleRate;
+
+  omx_err = m_omx_render.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_render SetParameter in omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  m_omx_render.ResetEos();
+
+  SetAudioDest();
+
+  // set up the number/size of buffers for decoder input
+  OMX_PARAM_PORTDEFINITIONTYPE port_param;
+  OMX_INIT_STRUCTURE(port_param);
+  port_param.nPortIndex = m_omx_render.GetInputPort();
+
+  omx_err = m_omx_render.GetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, (unsigned int)NUM_OMX_BUFFERS);
+  port_param.nBufferSize = m_format.m_frameSize * m_format.m_frames / port_param.nBufferCountActual;
+
+  omx_err = m_omx_render.SetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error set OMX_IndexParamPortDefinition (intput) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  omx_err = m_omx_render.AllocInputBuffers();
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - Error alloc buffers 0x%08x", CLASSNAME, __func__, omx_err);
+
+  omx_err = m_omx_render.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - m_omx_render OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  m_Initialized = true;
+  return true;
+}
+
+
+void CAESinkPi::Deinitialize()
+{
+  CLog::Log(LOGDEBUG, "%s:%s", CLASSNAME, __func__);
+  SetAudioProps(false, 0);
+  if (m_Initialized)
+  {
+    m_omx_render.FlushAll();
+    m_omx_render.Deinitialize();
+    m_Initialized = false;
+  }
+}
+
+bool CAESinkPi::IsCompatible(const AEAudioFormat format, const std::string device)
+{
+  bool compatible =
+      /* compare against the requested format and the real format */
+      (m_initFormat.m_sampleRate    == format.m_sampleRate    || m_format.m_sampleRate    == format.m_sampleRate   ) &&
+      (m_initFormat.m_dataFormat    == format.m_dataFormat    || m_format.m_dataFormat    == format.m_dataFormat   ) &&
+      (m_initFormat.m_channelLayout == format.m_channelLayout || m_format.m_channelLayout == format.m_channelLayout) &&
+      (m_initDevice == device);
+  CLog::Log(LOGDEBUG, "%s:%s Format:%d Channels:%d Samplerate:%d = %d", CLASSNAME, __func__, format.m_dataFormat, format.m_channelLayout.Count(), format.m_sampleRate, compatible);
+  return compatible;
+}
+
+double CAESinkPi::GetDelay()
+{
+  OMX_PARAM_U32TYPE param;
+  OMX_INIT_STRUCTURE(param);
+
+  if (!m_Initialized)
+    return 0.0;
+
+  param.nPortIndex = m_omx_render.GetInputPort();
+
+  OMX_ERRORTYPE omx_err = m_omx_render.GetConfig(OMX_IndexConfigAudioRenderingLatency, &param);
+
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error getting OMX_IndexConfigAudioRenderingLatency error 0x%08x",
+      CLASSNAME, __func__, omx_err);
+  }
+  double sinkbuffer_seconds_to_empty = m_sinkbuffer_sec_per_byte * param.nU32 * m_format.m_frameSize;
+  return sinkbuffer_seconds_to_empty;
+}
+
+double CAESinkPi::GetCacheTime()
+{
+  return GetDelay();
+}
+
+double CAESinkPi::GetCacheTotal()
+{
+  return AUDIO_PLAYBUFFER;
+}
+
+unsigned int CAESinkPi::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio)
+{
+  bool blocking = true;
+  unsigned int sent = 0;
+
+  if (!m_Initialized)
+    return frames;
+
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+  OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
+  while (sent < frames)
+  {
+    double delay = GetDelay();
+    double ideal_submission_time = AUDIO_PLAYBUFFER - delay;
+    // ideal amount of audio we'd like submit (to make delay match AUDIO_PLAYBUFFER)
+    int timeout = blocking ? 1000 : 0;
+    int ideal_submission_samples = ideal_submission_time / (m_sinkbuffer_sec_per_byte * m_format.m_frameSize);
+    // if we are almost full then sleep (to avoid repeatedly sending a few samples)
+    bool too_laggy = ideal_submission_time < 0.25 * AUDIO_PLAYBUFFER;
+    int sleeptime = (int)(AUDIO_PLAYBUFFER * 0.25 * 1000.0);
+    if (too_laggy)
+    {
+      if (blocking)
+      {
+        Sleep(sleeptime);
+        continue;
+      }
+      break;
+    }
+    omx_buffer = m_omx_render.GetInputBuffer(timeout);
+    if (omx_buffer == NULL)
+    {
+      if (blocking)
+        CLog::Log(LOGERROR, "COMXAudio::Decode timeout");
+      break;
+    }
+
+    unsigned int space = omx_buffer->nAllocLen / m_format.m_frameSize;
+    unsigned int samples = std::min(std::min(space, (unsigned int)ideal_submission_samples), frames - sent);
+
+    omx_buffer->nFilledLen = samples * m_format.m_frameSize;
+    omx_buffer->nTimeStamp = ToOMXTime(0);
+    omx_buffer->nFlags = 0;
+    memcpy(omx_buffer->pBuffer, (uint8_t *)data + sent * m_format.m_frameSize, omx_buffer->nFilledLen);
+
+    sent += samples;
+
+    if (sent == frames)
+      omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+
+    if (delay <= 0.0 && m_submitted)
+      CLog::Log(LOGNOTICE, "%s:%s Underrun (delay:%.2f frames:%d)", CLASSNAME, __func__, delay, frames);
+
+    omx_err = m_omx_render.EmptyThisBuffer(omx_buffer);
+    if (omx_err != OMX_ErrorNone)
+      CLog::Log(LOGERROR, "%s:%s frames=%d err=%x", CLASSNAME, __func__, frames, omx_err);
+    m_submitted++;
+  }
+
+  return sent;
+}
+
+void CAESinkPi::Drain()
+{
+  int delay = (int)(GetDelay() * 1000.0);
+  if (delay)
+    Sleep(delay);
+  CLog::Log(LOGDEBUG, "%s:%s delay:%dms now:%dms", CLASSNAME, __func__, delay, (int)(GetDelay() * 1000.0));
+}
+
+void CAESinkPi::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
+{
+  m_info.m_channels.Reset();
+  m_info.m_dataFormats.clear();
+  m_info.m_sampleRates.clear();
+
+  m_info.m_deviceType = AE_DEVTYPE_HDMI;
+  m_info.m_deviceName = "HDMI";
+  m_info.m_displayName = "HDMI";
+  m_info.m_displayNameExtra = "";
+  m_info.m_channels += AE_CH_FL;
+  m_info.m_channels += AE_CH_FR;
+  for (unsigned int i=0; i<sizeof PassthroughSampleRates/sizeof *PassthroughSampleRates; i++)
+    m_info.m_sampleRates.push_back(PassthroughSampleRates[i]);
+  m_info.m_dataFormats.push_back(AE_FMT_FLOAT);
+  m_info.m_dataFormats.push_back(AE_FMT_S32LE);
+  m_info.m_dataFormats.push_back(AE_FMT_S16LE);
+  m_info.m_dataFormats.push_back(AE_FMT_AC3);
+  m_info.m_dataFormats.push_back(AE_FMT_DTS);
+  m_info.m_dataFormats.push_back(AE_FMT_EAC3);
+
+  list.push_back(m_info);
+
+  m_info.m_channels.Reset();
+  m_info.m_dataFormats.clear();
+  m_info.m_sampleRates.clear();
+
+  m_info.m_deviceType = AE_DEVTYPE_PCM;
+  m_info.m_deviceName = "Analogue";
+  m_info.m_displayName = "Analogue";
+  m_info.m_displayNameExtra = "";
+  m_info.m_channels += AE_CH_FL;
+  m_info.m_channels += AE_CH_FR;
+  m_info.m_sampleRates.push_back(48000);
+  m_info.m_dataFormats.push_back(AE_FMT_FLOAT);
+  m_info.m_dataFormats.push_back(AE_FMT_S32LE);
+  m_info.m_dataFormats.push_back(AE_FMT_S16LE);
+
+  list.push_back(m_info);
+}
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.h b/xbmc/cores/AudioEngine/Sinks/AESinkPi.h
new file mode 100644
index 0000000..a3bf893
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.h
@@ -0,0 +1,65 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include "cores/AudioEngine/Interfaces/AESink.h"
+#include "cores/AudioEngine/Utils/AEDeviceInfo.h"
+
+#include "cores/omxplayer/OMXAudio.h"
+
+class CAESinkPi : public IAESink
+{
+public:
+  virtual const char *GetName() { return "SinkPi"; }
+
+  CAESinkPi();
+  virtual ~CAESinkPi();
+
+  virtual bool Initialize(AEAudioFormat &format, std::string &device);
+  virtual void Deinitialize();
+  virtual bool IsCompatible(const AEAudioFormat format, const std::string device);
+
+  virtual double       GetDelay        ();
+  virtual double       GetCacheTime    ();
+  virtual double       GetCacheTotal   ();
+  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio);
+  virtual void         Drain           ();
+
+  static void          EnumerateDevicesEx(AEDeviceInfoList &list, bool force = false);
+private:
+  void                 SetAudioDest();
+
+  std::string          m_initDevice;
+  AEAudioFormat        m_initFormat;
+  AEAudioFormat        m_format;
+  double               m_sinkbuffer_sec_per_byte;
+  static CAEDeviceInfo m_info;
+  bool                 m_Initialized;
+  uint32_t             m_submitted;
+  OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_input;
+  COMXCoreComponent    m_omx_render;
+  bool                 m_passthrough;
+};
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Sinks/CMakeLists.txt b/xbmc/cores/AudioEngine/Sinks/CMakeLists.txt
index 14a81d3..ee32f8f 100644
--- a/xbmc/cores/AudioEngine/Sinks/CMakeLists.txt
+++ b/xbmc/cores/AudioEngine/Sinks/CMakeLists.txt
@@ -4,6 +4,10 @@ if(DEFINED HAS_ALSA)
   set(ae_SRCS ${ae_SRCS} AESinkALSA.cpp AESinkALSA.h)
 endif()
 
+if(TARGET_RPI)
+  set(ae_SRCS ${ae_SRCS} AESinkPi.cpp AESinkPi.h)
+endif(TARGET_RPI)
+
 if(TARGET_WIN32)
   set(ae_SRCS ${ae_SRCS} AESinkWASAPI.cpp AESinkWASAPI.h AESinkDirectSound.cpp AESinkDirectSound.h)
 endif(TARGET_WIN32)
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 677a9f1..ccc4e1d 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -36,6 +36,7 @@
 #include "settings/Settings.h"
 #include "guilib/LocalizeStrings.h"
 #include "cores/AudioEngine/Utils/AEConvert.h"
+#include "cores/AudioEngine/AEFactory.h"
 
 using namespace std;
 
@@ -85,6 +86,10 @@ COMXAudio::COMXAudio() :
   m_vizBufferSize   = m_vizRemapBufferSize = VIS_PACKET_SIZE * sizeof(float);
   m_vizRemapBuffer  = (uint8_t *)_aligned_malloc(m_vizRemapBufferSize,16);
   m_vizBuffer       = (uint8_t *)_aligned_malloc(m_vizBufferSize,16);
+
+  CAEFactory::Suspend();
+  while (!CAEFactory::IsSuspended())
+    Sleep(10);
 }
 
 COMXAudio::~COMXAudio()
@@ -93,6 +98,8 @@ COMXAudio::~COMXAudio()
 
   _aligned_free(m_vizRemapBuffer);
   _aligned_free(m_vizBuffer);
+
+  CAEFactory::Resume();
 }
 
 bool COMXAudio::PortSettingsChanged()

From 52c27ccdd77b562b528393a3f38e4dc806e3c391 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 12:15:42 +0100
Subject: [PATCH 36/38] Enable menu sounds

---
 plex/Owned/GUISettings.cpp | 2 --
 1 file changed, 2 deletions(-)

diff --git a/plex/Owned/GUISettings.cpp b/plex/Owned/GUISettings.cpp
index b536f1b..afbd89a 100644
--- a/plex/Owned/GUISettings.cpp
+++ b/plex/Owned/GUISettings.cpp
@@ -399,13 +399,11 @@ void CGUISettings::Initialize()
 #endif
 #endif
 
-#if !defined(TARGET_RASPBERRY_PI)
   map<int,int> guimode;
   guimode.insert(make_pair(34121, AE_SOUND_IDLE  ));
   guimode.insert(make_pair(34122, AE_SOUND_ALWAYS));
   guimode.insert(make_pair(34123, AE_SOUND_OFF   ));
   AddInt(NULL, "audiooutput.guisoundmode", 34120, AE_SOUND_ALWAYS, guimode, SPIN_CONTROL_TEXT);
-#endif
 
 
 

From ee002f0925a29196c98edf552e2e59f8c533dcf6 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Fri, 6 Feb 2015 21:17:32 +0100
Subject: [PATCH 37/38] Add fonts and colors for OpenELEC-settings

---
 addons/skin.plex/720p/Font.xml       | 30 ++++++++++++++++++++++++++++++
 addons/skin.plex/Colors/Defaults.xml | 10 ++++++++++
 2 files changed, 40 insertions(+)

diff --git a/addons/skin.plex/720p/Font.xml b/addons/skin.plex/720p/Font.xml
index 592589a..6109c43 100644
--- a/addons/skin.plex/720p/Font.xml
+++ b/addons/skin.plex/720p/Font.xml
@@ -37,6 +37,26 @@
 		</font>
 		<!-- Regular -->
 		<font>
+			<name>font10</name>
+			<filename>PlexFont-Regular.ttf</filename>
+			<size>14</size>
+		</font>
+		<font>
+			<name>font12</name>
+			<filename>PlexFont-Regular.ttf</filename>
+			<size>17</size>
+		</font>
+		<font>
+			<name>font13</name>
+			<filename>PlexFont-Regular.ttf</filename>
+			<size>20</size>
+		</font>
+		<font>
+			<name>font16</name>
+			<filename>PlexFont-Regular.ttf</filename>
+			<size>25</size>
+		</font>
+		<font>
 			<name>Regular-12</name>
 			<filename>PlexFont-Regular.ttf</filename>
 			<size>12</size>
@@ -113,6 +133,16 @@
 		</font>
 		<!-- Bold -->
 		<font>
+			<name>font13_title</name>
+			<filename>PlexFont-Bold.ttf</filename>
+			<size>20</size>
+		</font>
+		<font>
+			<name>font24_title</name>
+			<filename>PlexFont-Bold.ttf</filename>
+			<size>24</size>
+		</font>
+		<font>
 			<name>Bold-10</name>
 			<filename>PlexFont-Bold.ttf</filename>
 			<size>10</size>
diff --git a/addons/skin.plex/Colors/Defaults.xml b/addons/skin.plex/Colors/Defaults.xml
index 0b61586..dbc1c10 100644
--- a/addons/skin.plex/Colors/Defaults.xml
+++ b/addons/skin.plex/Colors/Defaults.xml
@@ -1,5 +1,15 @@
 <?xml version="1.0"?>
 <colors>
+	<!-- confluence colors -->
+	<color name="white">FFF1F1F1</color>
+	<color name="grey">FFb4b4b4</color>
+	<color name="grey2">FF999999</color>
+	<color name="grey3">FF505050</color>
+	<color name="black">FF000000</color>
+	<color name="blue">FF0084ff</color>
+	<color name="selected">FFEB9E17</color>
+	<color name="invalid">FFFF0000</color>
+	<!-- plex colors -->
 	<color name="orange">FFd1801c</color>
 	<color name="orangeLight">FFf8a339</color>
 	<color name="greyLight">FFa5a4a4</color>

From ffeb8ec724e89103476e3e1237c4fef89678554c Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 7 Feb 2015 09:44:59 +0100
Subject: [PATCH 38/38] Do not pause rendering

---
 plex/GUI/GUIPlexMediaWindow.cpp | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/plex/GUI/GUIPlexMediaWindow.cpp b/plex/GUI/GUIPlexMediaWindow.cpp
index 44ba4ca..09958af 100755
--- a/plex/GUI/GUIPlexMediaWindow.cpp
+++ b/plex/GUI/GUIPlexMediaWindow.cpp
@@ -697,10 +697,6 @@ void CGUIPlexMediaWindow::LoadPage(int iPage)
   u.SetOption("X-Plex-Container-Start", boost::lexical_cast<std::string>(start));
   u.SetOption("X-Plex-Container-Size", boost::lexical_cast<std::string>(pageSize));
   
-#if TARGET_RASPBERRY_PI
-  PlexUtils::PauseRendering(true, true);
-#endif
-
   m_fetchJobs[iPage] = CJobManager::GetInstance().AddJob(new CPlexDirectoryFetchJob(u), this);
 }
 
@@ -730,9 +726,6 @@ void CGUIPlexMediaWindow::OnJobComplete(unsigned int jobID, bool success, CJob*
     }
   }
 
-#if TARGET_RASPBERRY_PI
-  PlexUtils::PauseRendering(false, true);
-#endif
   // remove FetchJob from List
   m_fetchJobs.erase(pageNum);
 #endif
